
// Generated from ./Lustre.g4 by ANTLR 4.13.1


#include "LustreListener.h"
#include "LustreVisitor.h"

#include "LustreParser.h"


using namespace antlrcpp;

using namespace antlr4;

namespace {

struct LustreParserStaticData final {
  LustreParserStaticData(std::vector<std::string> ruleNames,
                        std::vector<std::string> literalNames,
                        std::vector<std::string> symbolicNames)
      : ruleNames(std::move(ruleNames)), literalNames(std::move(literalNames)),
        symbolicNames(std::move(symbolicNames)),
        vocabulary(this->literalNames, this->symbolicNames) {}

  LustreParserStaticData(const LustreParserStaticData&) = delete;
  LustreParserStaticData(LustreParserStaticData&&) = delete;
  LustreParserStaticData& operator=(const LustreParserStaticData&) = delete;
  LustreParserStaticData& operator=(LustreParserStaticData&&) = delete;

  std::vector<antlr4::dfa::DFA> decisionToDFA;
  antlr4::atn::PredictionContextCache sharedContextCache;
  const std::vector<std::string> ruleNames;
  const std::vector<std::string> literalNames;
  const std::vector<std::string> symbolicNames;
  const antlr4::dfa::Vocabulary vocabulary;
  antlr4::atn::SerializedATNView serializedATN;
  std::unique_ptr<antlr4::atn::ATN> atn;
};

::antlr4::internal::OnceFlag lustreParserOnceFlag;
#if ANTLR4_USE_THREAD_LOCAL_CACHE
static thread_local
#endif
LustreParserStaticData *lustreParserStaticData = nullptr;

void lustreParserInitialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  if (lustreParserStaticData != nullptr) {
    return;
  }
#else
  assert(lustreParserStaticData == nullptr);
#endif
  auto staticData = std::make_unique<LustreParserStaticData>(
    std::vector<std::string>{
      "program", "include", "pack_list", "one_park", "pack_decl", "uses", 
      "pack_eq", "provides", "provide", "model_decl", "user_op_provide", 
      "decls", "type_block", "type_decl", "type_def", "type", "field_decl", 
      "const_block", "const_decl", "const_expr", "const_list", "const_label_expr", 
      "var_decls", "when_decl", "clock_expr", "last_decl", "user_op_decl", 
      "op_kind", "params", "op_body", "contract", "local_block", "let_block", 
      "external_contract", "contract_body", "kind2_contract_item", "mode_decl", 
      "mode_body", "requirement", "assurance", "kind2_const_item", "kind2_var_item", 
      "assume_item", "guarantee_item", "import_item", "kind2_if_block", 
      "kind2_if_body", "kind2_property", "kind2_frame_block", "frame_init", 
      "frame_body", "import_op_decl", "equation", "lhs", "return", "returns_var", 
      "state_machine", "state_decl", "data_def", "unless_tran", "until_tran", 
      "transition", "expr", "list", "kind2_expr", "activate_expr", "restart_expr", 
      "kind2_param", "activate", "restart", "tempo_expr", "bool_expr", "array_expr", 
      "struct_expr", "mixed_constructor", "label_expr", "index", "label_or_index", 
      "switch_expr", "case_expr", "pattern", "apply_expr", "prefix_operator", 
      "prefix_unary_operator", "prefix_binary_operator", "simple_expr", 
      "unary_arith_op", "bin_arith_op", "bin_relation_op", "bin_bool_op", 
      "atom", "merge_expr"
    },
    std::vector<std::string>{
      "", "'include'", "';'", "'package'", "'body'", "'end'", "'uses'", 
      "','", "'='", "'is'", "'provides'", "'model'", "'needs'", "'returns'", 
      "'type'", "'enum'", "'{'", "'}'", "'int'", "'bool'", "'char'", "'short'", 
      "'ushort'", "'uint'", "'float'", "'real'", "'struct'", "'^'", "':'", 
      "'const'", "'('", "')'", "'['", "']'", "'when'", "'not'", "'last'", 
      "'function'", "'node'", "'let'", "'tel'", "'(*@contract'", "'*)'", 
      "'/*@contract'", "'*/'", "'var'", "'fi'", "'contract'", "'mode'", 
      "'require'", "'ensure'", "'assume'", "'guarantee'", "'import'", "'if'", 
      "'then'", "'elsif'", "'else'", "'frame'", "'imported'", "'..'", "'automaton'", 
      "'state'", "'resume'", "'restart'", "'''", "'activate'", "'every'", 
      "'pre'", "'->'", "'fby'", "'merge'", "'#'", "'.'", "'default'", "'with'", 
      "'case'", "'of'", "'|'", "'-'", "'_'", "'map'", "'<<'", "'>>'", "'fold'", 
      "'mapi'", "'foldi'", "'mapfold'", "'mapw'", "'mapwi'", "'foldw'", 
      "'foldwi'", "'make'", "'flatten'", "'+$'", "'-$'", "'not$'", "'short$'", 
      "'int$'", "'float$'", "'real$'", "'$+$'", "'$-$'", "'$*$'", "'$/$'", 
      "'$mod$'", "'$div$'", "'$=$'", "'$<>$'", "'$<$'", "'$>$'", "'$<=$'", 
      "'$>=$'", "'$and$'", "'$or$'", "'$xor$'", "'+'", "'*'", "'/'", "'mod'", 
      "'div'", "'<>'", "'<'", "'>'", "'<='", "'>='", "'and'", "'or'", "'xor'", 
      "'initial'", "'final'", "'unless'", "'until'", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "'--%MAIN'"
    },
    std::vector<std::string>{
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "INITIAL", "FINAL", "UNLESS", 
      "UNTIL", "BOOL", "INTEGER", "UINT", "REAL", "CHAR", "FLOAT", "USHORT", 
      "SHORT", "ID", "SL_COMMENT", "ML_COMMENT", "PRAGMA", "STRING", "MAIN", 
      "PROPERTY", "CHECK", "WS", "ERROR"
    }
  );
  static const int32_t serializedATNSegment[] = {
  	4,1,150,1333,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,
  	2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,
  	7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,
  	7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,
  	7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,
  	7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,
  	7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,
  	7,49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,
  	7,56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,
  	7,63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,
  	7,70,2,71,7,71,2,72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,
  	7,77,2,78,7,78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,
  	7,84,2,85,7,85,2,86,7,86,2,87,7,87,2,88,7,88,2,89,7,89,2,90,7,90,2,91,
  	7,91,1,0,1,0,1,0,4,0,188,8,0,11,0,12,0,189,3,0,192,8,0,1,1,1,1,1,1,1,
  	1,1,2,4,2,199,8,2,11,2,12,2,200,1,3,1,3,1,3,3,3,206,8,3,1,4,1,4,1,4,1,
  	4,1,4,1,4,1,4,1,4,1,5,1,5,1,5,1,5,5,5,220,8,5,10,5,12,5,223,9,5,1,5,1,
  	5,1,6,1,6,1,6,1,6,1,6,1,7,1,7,1,7,1,7,1,7,1,7,5,7,238,8,7,10,7,12,7,241,
  	9,7,1,8,1,8,1,8,3,8,246,8,8,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,10,
  	1,10,1,10,1,10,1,10,1,10,1,11,1,11,1,11,1,11,1,11,3,11,268,8,11,1,12,
  	1,12,1,12,1,12,5,12,274,8,12,10,12,12,12,277,9,12,1,13,1,13,1,13,3,13,
  	282,8,13,1,14,1,14,1,14,1,14,1,14,1,14,5,14,290,8,14,10,14,12,14,293,
  	9,14,1,14,3,14,296,8,14,1,15,1,15,1,15,1,15,1,15,1,15,1,15,1,15,1,15,
  	1,15,1,15,3,15,309,8,15,1,15,1,15,1,15,1,15,5,15,315,8,15,10,15,12,15,
  	318,9,15,1,15,1,15,3,15,322,8,15,1,15,1,15,1,15,5,15,327,8,15,10,15,12,
  	15,330,9,15,1,16,1,16,1,16,1,16,1,17,1,17,1,17,1,17,5,17,340,8,17,10,
  	17,12,17,343,9,17,1,18,1,18,1,18,3,18,348,8,18,1,18,1,18,3,18,352,8,18,
  	1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,
  	1,19,1,19,1,19,1,19,5,19,372,8,19,10,19,12,19,375,9,19,1,19,1,19,3,19,
  	379,8,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,
  	5,19,393,8,19,10,19,12,19,396,9,19,1,20,1,20,1,20,5,20,401,8,20,10,20,
  	12,20,404,9,20,3,20,406,8,20,1,21,1,21,1,21,1,21,1,22,1,22,1,22,5,22,
  	415,8,22,10,22,12,22,418,9,22,1,22,1,22,1,22,3,22,423,8,22,1,22,3,22,
  	426,8,22,1,23,1,23,1,23,1,24,1,24,1,24,3,24,434,8,24,1,24,1,24,3,24,438,
  	8,24,3,24,440,8,24,1,25,1,25,1,25,1,25,1,26,1,26,1,26,1,26,1,26,1,26,
  	3,26,452,8,26,1,26,1,26,1,27,1,27,3,27,458,8,27,1,28,1,28,1,28,1,28,5,
  	28,464,8,28,10,28,12,28,467,9,28,3,28,469,8,28,1,28,3,28,472,8,28,1,28,
  	1,28,1,29,1,29,3,29,478,8,29,1,29,3,29,481,8,29,1,29,1,29,5,29,485,8,
  	29,10,29,12,29,488,9,29,1,29,1,29,3,29,492,8,29,3,29,494,8,29,1,30,1,
  	30,5,30,498,8,30,10,30,12,30,501,9,30,1,30,1,30,1,30,5,30,506,8,30,10,
  	30,12,30,509,9,30,1,30,3,30,512,8,30,1,31,1,31,1,31,1,31,5,31,518,8,31,
  	10,31,12,31,521,9,31,1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,3,32,531,
  	8,32,1,33,1,33,1,33,1,33,1,33,1,33,3,33,539,8,33,1,33,1,33,1,34,1,34,
  	4,34,545,8,34,11,34,12,34,546,1,34,1,34,1,35,1,35,1,35,1,35,1,35,1,35,
  	3,35,557,8,35,1,36,1,36,1,36,1,36,1,36,1,36,1,36,1,37,1,37,4,37,568,8,
  	37,11,37,12,37,569,1,38,1,38,5,38,574,8,38,10,38,12,38,577,9,38,1,38,
  	1,38,1,39,1,39,5,39,583,8,39,10,39,12,39,586,9,39,1,39,1,39,1,40,1,40,
  	1,40,3,40,593,8,40,1,40,1,40,5,40,597,8,40,10,40,12,40,600,9,40,1,40,
  	1,40,1,41,1,41,1,41,1,41,1,41,1,41,5,41,610,8,41,10,41,12,41,613,9,41,
  	1,41,1,41,1,42,1,42,5,42,619,8,42,10,42,12,42,622,9,42,1,42,1,42,1,43,
  	1,43,5,43,628,8,43,10,43,12,43,631,9,43,1,43,1,43,1,44,1,44,1,44,1,44,
  	1,44,1,44,5,44,641,8,44,10,44,12,44,644,9,44,1,44,1,44,1,44,1,44,1,44,
  	1,44,5,44,652,8,44,10,44,12,44,655,9,44,1,44,1,44,1,44,1,44,1,45,1,45,
  	1,45,1,45,1,45,1,45,4,45,667,8,45,11,45,12,45,668,1,45,5,45,672,8,45,
  	10,45,12,45,675,9,45,1,46,1,46,1,46,1,46,1,46,1,46,4,46,683,8,46,11,46,
  	12,46,684,1,46,1,46,1,46,1,46,4,46,691,8,46,11,46,12,46,692,3,46,695,
  	8,46,1,47,1,47,1,47,3,47,700,8,47,1,48,1,48,1,48,1,49,1,49,1,49,1,49,
  	1,49,5,49,710,8,49,10,49,12,49,713,9,49,1,49,1,49,1,49,1,49,5,49,719,
  	8,49,10,49,12,49,722,9,49,1,50,1,50,1,50,1,50,5,50,728,8,50,10,50,12,
  	50,731,9,50,1,50,1,50,1,51,1,51,1,51,1,51,1,51,1,51,1,51,1,52,1,52,1,
  	52,1,52,1,52,1,52,1,52,3,52,749,8,52,1,53,1,53,1,53,3,53,754,8,53,1,53,
  	1,53,1,53,5,53,759,8,53,10,53,12,53,762,9,53,1,53,3,53,765,8,53,3,53,
  	767,8,53,1,54,1,54,1,54,1,55,1,55,5,55,774,8,55,10,55,12,55,777,9,55,
  	1,55,3,55,780,8,55,1,56,1,56,3,56,784,8,56,1,56,4,56,787,8,56,11,56,12,
  	56,788,1,57,3,57,792,8,57,1,57,3,57,795,8,57,1,57,1,57,1,57,3,57,800,
  	8,57,1,57,1,57,3,57,804,8,57,1,58,1,58,3,58,808,8,58,1,58,1,58,1,58,1,
  	58,5,58,814,8,58,10,58,12,58,817,9,58,1,58,3,58,820,8,58,3,58,822,8,58,
  	1,59,1,59,1,59,1,59,4,59,828,8,59,11,59,12,59,829,1,60,1,60,1,60,1,60,
  	5,60,836,8,60,10,60,12,60,839,9,60,1,61,1,61,1,61,1,61,1,61,1,61,1,61,
  	1,61,1,61,1,61,3,61,851,8,61,1,62,1,62,1,62,1,62,1,62,1,62,1,62,1,62,
  	1,62,1,62,1,62,1,62,1,62,1,62,1,62,1,62,3,62,869,8,62,1,63,1,63,1,63,
  	5,63,874,8,63,10,63,12,63,877,9,63,3,63,879,8,63,1,64,1,64,3,64,883,8,
  	64,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,
  	65,1,65,3,65,900,8,65,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,66,1,
  	66,1,66,1,66,1,66,3,66,915,8,66,1,67,1,67,1,67,3,67,920,8,67,1,67,1,67,
  	1,67,3,67,925,8,67,5,67,927,8,67,10,67,12,67,930,9,67,1,67,1,67,1,68,
  	1,68,1,68,1,68,1,68,1,69,1,69,1,69,1,69,1,69,1,70,1,70,1,70,1,70,1,70,
  	1,70,1,70,1,70,1,70,1,70,1,70,1,70,1,70,1,70,1,70,5,70,959,8,70,10,70,
  	12,70,962,9,70,1,70,1,70,1,70,1,70,1,70,1,70,5,70,970,8,70,10,70,12,70,
  	973,9,70,1,70,1,70,1,70,1,70,1,70,1,70,1,70,1,70,1,70,1,70,1,70,1,70,
  	1,70,1,70,1,70,1,70,1,70,1,70,1,70,1,70,5,70,995,8,70,10,70,12,70,998,
  	9,70,1,70,1,70,3,70,1002,8,70,1,71,1,71,3,71,1006,8,71,1,71,1,71,3,71,
  	1010,8,71,1,72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,4,72,
  	1023,8,72,11,72,12,72,1024,1,72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,1,
  	72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,5,72,1043,8,72,10,72,12,72,1046,
  	9,72,3,72,1048,8,72,1,73,1,73,1,73,1,73,5,73,1054,8,73,10,73,12,73,1057,
  	9,73,1,73,1,73,1,74,1,74,1,74,1,74,4,74,1065,8,74,11,74,12,74,1066,1,
  	74,1,74,1,74,1,74,1,75,1,75,1,75,1,75,1,76,1,76,1,76,1,76,1,77,1,77,1,
  	77,3,77,1084,8,77,1,78,1,78,1,78,1,78,1,78,1,78,1,78,1,78,1,78,1,78,1,
  	78,1,78,4,78,1098,8,78,11,78,12,78,1099,1,78,1,78,3,78,1104,8,78,1,79,
  	1,79,1,79,1,79,1,79,1,80,1,80,1,80,3,80,1114,8,80,1,80,1,80,1,80,3,80,
  	1119,8,80,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,
  	1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,
  	1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,
  	1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,
  	1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,
  	1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,
  	1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,
  	1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,
  	1,81,3,81,1232,8,81,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,1,82,
  	1,82,3,82,1245,8,82,1,83,1,83,1,84,1,84,1,85,1,85,1,85,1,85,1,85,1,85,
  	1,85,5,85,1258,8,85,10,85,12,85,1261,9,85,1,85,1,85,1,85,1,85,1,85,1,
  	85,1,85,1,85,1,85,1,85,1,85,3,85,1274,8,85,1,85,1,85,1,85,1,85,1,85,1,
  	85,1,85,1,85,1,85,1,85,1,85,1,85,1,85,1,85,1,85,1,85,1,85,1,85,1,85,1,
  	85,5,85,1296,8,85,10,85,12,85,1299,9,85,1,86,1,86,1,86,3,86,1304,8,86,
  	1,87,1,87,1,87,1,87,1,87,1,87,3,87,1312,8,87,1,88,1,88,1,89,1,89,1,90,
  	1,90,1,90,1,90,1,90,1,90,1,90,1,90,3,90,1326,8,90,1,91,1,91,1,91,3,91,
  	1331,8,91,1,91,6,575,584,598,611,620,629,3,30,38,170,92,0,2,4,6,8,10,
  	12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,
  	58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,
  	104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,
  	140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,172,174,
  	176,178,180,182,0,7,1,0,8,9,2,0,2,2,7,7,2,0,60,60,141,141,1,0,94,100,
  	1,0,101,115,2,0,8,8,121,125,1,0,126,128,1440,0,191,1,0,0,0,2,193,1,0,
  	0,0,4,198,1,0,0,0,6,205,1,0,0,0,8,207,1,0,0,0,10,215,1,0,0,0,12,226,1,
  	0,0,0,14,231,1,0,0,0,16,245,1,0,0,0,18,247,1,0,0,0,20,256,1,0,0,0,22,
  	267,1,0,0,0,24,269,1,0,0,0,26,278,1,0,0,0,28,295,1,0,0,0,30,321,1,0,0,
  	0,32,331,1,0,0,0,34,335,1,0,0,0,36,344,1,0,0,0,38,378,1,0,0,0,40,405,
  	1,0,0,0,42,407,1,0,0,0,44,411,1,0,0,0,46,427,1,0,0,0,48,439,1,0,0,0,50,
  	441,1,0,0,0,52,445,1,0,0,0,54,457,1,0,0,0,56,459,1,0,0,0,58,493,1,0,0,
  	0,60,511,1,0,0,0,62,513,1,0,0,0,64,530,1,0,0,0,66,532,1,0,0,0,68,542,
  	1,0,0,0,70,556,1,0,0,0,72,558,1,0,0,0,74,567,1,0,0,0,76,571,1,0,0,0,78,
  	580,1,0,0,0,80,589,1,0,0,0,82,603,1,0,0,0,84,616,1,0,0,0,86,625,1,0,0,
  	0,88,634,1,0,0,0,90,660,1,0,0,0,92,694,1,0,0,0,94,699,1,0,0,0,96,701,
  	1,0,0,0,98,704,1,0,0,0,100,723,1,0,0,0,102,734,1,0,0,0,104,748,1,0,0,
  	0,106,766,1,0,0,0,108,768,1,0,0,0,110,775,1,0,0,0,112,781,1,0,0,0,114,
  	791,1,0,0,0,116,821,1,0,0,0,118,823,1,0,0,0,120,831,1,0,0,0,122,850,1,
  	0,0,0,124,868,1,0,0,0,126,878,1,0,0,0,128,882,1,0,0,0,130,899,1,0,0,0,
  	132,914,1,0,0,0,134,916,1,0,0,0,136,933,1,0,0,0,138,938,1,0,0,0,140,1001,
  	1,0,0,0,142,1003,1,0,0,0,144,1047,1,0,0,0,146,1049,1,0,0,0,148,1060,1,
  	0,0,0,150,1072,1,0,0,0,152,1076,1,0,0,0,154,1083,1,0,0,0,156,1103,1,0,
  	0,0,158,1105,1,0,0,0,160,1118,1,0,0,0,162,1231,1,0,0,0,164,1244,1,0,0,
  	0,166,1246,1,0,0,0,168,1248,1,0,0,0,170,1273,1,0,0,0,172,1303,1,0,0,0,
  	174,1311,1,0,0,0,176,1313,1,0,0,0,178,1315,1,0,0,0,180,1325,1,0,0,0,182,
  	1330,1,0,0,0,184,192,3,2,1,0,185,188,3,22,11,0,186,188,3,4,2,0,187,185,
  	1,0,0,0,187,186,1,0,0,0,188,189,1,0,0,0,189,187,1,0,0,0,189,190,1,0,0,
  	0,190,192,1,0,0,0,191,184,1,0,0,0,191,187,1,0,0,0,192,1,1,0,0,0,193,194,
  	5,1,0,0,194,195,5,145,0,0,195,196,5,2,0,0,196,3,1,0,0,0,197,199,3,6,3,
  	0,198,197,1,0,0,0,199,200,1,0,0,0,200,198,1,0,0,0,200,201,1,0,0,0,201,
  	5,1,0,0,0,202,206,3,18,9,0,203,206,3,8,4,0,204,206,3,12,6,0,205,202,1,
  	0,0,0,205,203,1,0,0,0,205,204,1,0,0,0,206,7,1,0,0,0,207,208,5,3,0,0,208,
  	209,5,141,0,0,209,210,3,10,5,0,210,211,3,14,7,0,211,212,5,4,0,0,212,213,
  	3,22,11,0,213,214,5,5,0,0,214,9,1,0,0,0,215,216,5,6,0,0,216,221,5,141,
  	0,0,217,218,5,7,0,0,218,220,5,141,0,0,219,217,1,0,0,0,220,223,1,0,0,0,
  	221,219,1,0,0,0,221,222,1,0,0,0,222,224,1,0,0,0,223,221,1,0,0,0,224,225,
  	5,2,0,0,225,11,1,0,0,0,226,227,5,3,0,0,227,228,5,141,0,0,228,229,7,0,
  	0,0,229,230,5,141,0,0,230,13,1,0,0,0,231,232,5,10,0,0,232,233,3,16,8,
  	0,233,239,5,2,0,0,234,235,3,16,8,0,235,236,5,2,0,0,236,238,1,0,0,0,237,
  	234,1,0,0,0,238,241,1,0,0,0,239,237,1,0,0,0,239,240,1,0,0,0,240,15,1,
  	0,0,0,241,239,1,0,0,0,242,246,3,34,17,0,243,246,3,24,12,0,244,246,3,20,
  	10,0,245,242,1,0,0,0,245,243,1,0,0,0,245,244,1,0,0,0,246,17,1,0,0,0,247,
  	248,5,11,0,0,248,249,5,141,0,0,249,250,3,10,5,0,250,251,5,12,0,0,251,
  	252,3,20,10,0,252,253,5,4,0,0,253,254,3,22,11,0,254,255,5,5,0,0,255,19,
  	1,0,0,0,256,257,3,54,27,0,257,258,5,141,0,0,258,259,3,56,28,0,259,260,
  	5,13,0,0,260,261,3,56,28,0,261,21,1,0,0,0,262,268,3,24,12,0,263,268,3,
  	34,17,0,264,268,3,102,51,0,265,268,3,52,26,0,266,268,3,66,33,0,267,262,
  	1,0,0,0,267,263,1,0,0,0,267,264,1,0,0,0,267,265,1,0,0,0,267,266,1,0,0,
  	0,268,23,1,0,0,0,269,275,5,14,0,0,270,271,3,26,13,0,271,272,5,2,0,0,272,
  	274,1,0,0,0,273,270,1,0,0,0,274,277,1,0,0,0,275,273,1,0,0,0,275,276,1,
  	0,0,0,276,25,1,0,0,0,277,275,1,0,0,0,278,281,5,141,0,0,279,280,5,8,0,
  	0,280,282,3,28,14,0,281,279,1,0,0,0,281,282,1,0,0,0,282,27,1,0,0,0,283,
  	296,3,30,15,0,284,285,5,15,0,0,285,286,5,16,0,0,286,291,5,141,0,0,287,
  	288,5,7,0,0,288,290,5,141,0,0,289,287,1,0,0,0,290,293,1,0,0,0,291,289,
  	1,0,0,0,291,292,1,0,0,0,292,294,1,0,0,0,293,291,1,0,0,0,294,296,5,17,
  	0,0,295,283,1,0,0,0,295,284,1,0,0,0,296,29,1,0,0,0,297,298,6,15,-1,0,
  	298,322,5,18,0,0,299,322,5,19,0,0,300,322,5,20,0,0,301,322,5,21,0,0,302,
  	322,5,22,0,0,303,322,5,23,0,0,304,322,5,24,0,0,305,322,5,25,0,0,306,322,
  	5,141,0,0,307,309,5,26,0,0,308,307,1,0,0,0,308,309,1,0,0,0,309,310,1,
  	0,0,0,310,311,5,16,0,0,311,316,3,32,16,0,312,313,7,1,0,0,313,315,3,32,
  	16,0,314,312,1,0,0,0,315,318,1,0,0,0,316,314,1,0,0,0,316,317,1,0,0,0,
  	317,319,1,0,0,0,318,316,1,0,0,0,319,320,5,17,0,0,320,322,1,0,0,0,321,
  	297,1,0,0,0,321,299,1,0,0,0,321,300,1,0,0,0,321,301,1,0,0,0,321,302,1,
  	0,0,0,321,303,1,0,0,0,321,304,1,0,0,0,321,305,1,0,0,0,321,306,1,0,0,0,
  	321,308,1,0,0,0,322,328,1,0,0,0,323,324,10,1,0,0,324,325,5,27,0,0,325,
  	327,3,38,19,0,326,323,1,0,0,0,327,330,1,0,0,0,328,326,1,0,0,0,328,329,
  	1,0,0,0,329,31,1,0,0,0,330,328,1,0,0,0,331,332,5,141,0,0,332,333,5,28,
  	0,0,333,334,3,30,15,0,334,33,1,0,0,0,335,341,5,29,0,0,336,337,3,36,18,
  	0,337,338,5,2,0,0,338,340,1,0,0,0,339,336,1,0,0,0,340,343,1,0,0,0,341,
  	339,1,0,0,0,341,342,1,0,0,0,342,35,1,0,0,0,343,341,1,0,0,0,344,347,5,
  	141,0,0,345,346,5,28,0,0,346,348,3,30,15,0,347,345,1,0,0,0,347,348,1,
  	0,0,0,348,351,1,0,0,0,349,350,5,8,0,0,350,352,3,38,19,0,351,349,1,0,0,
  	0,351,352,1,0,0,0,352,37,1,0,0,0,353,354,6,19,-1,0,354,379,5,141,0,0,
  	355,379,3,180,90,0,356,357,3,172,86,0,357,358,3,38,19,7,358,379,1,0,0,
  	0,359,360,5,30,0,0,360,361,3,38,19,0,361,362,5,31,0,0,362,379,1,0,0,0,
  	363,364,5,32,0,0,364,365,3,40,20,0,365,366,5,33,0,0,366,379,1,0,0,0,367,
  	368,5,16,0,0,368,373,3,42,21,0,369,370,5,7,0,0,370,372,3,42,21,0,371,
  	369,1,0,0,0,372,375,1,0,0,0,373,371,1,0,0,0,373,374,1,0,0,0,374,376,1,
  	0,0,0,375,373,1,0,0,0,376,377,5,17,0,0,377,379,1,0,0,0,378,353,1,0,0,
  	0,378,355,1,0,0,0,378,356,1,0,0,0,378,359,1,0,0,0,378,363,1,0,0,0,378,
  	367,1,0,0,0,379,394,1,0,0,0,380,381,10,5,0,0,381,382,3,174,87,0,382,383,
  	3,38,19,6,383,393,1,0,0,0,384,385,10,4,0,0,385,386,3,178,89,0,386,387,
  	3,38,19,5,387,393,1,0,0,0,388,389,10,3,0,0,389,390,3,176,88,0,390,391,
  	3,38,19,4,391,393,1,0,0,0,392,380,1,0,0,0,392,384,1,0,0,0,392,388,1,0,
  	0,0,393,396,1,0,0,0,394,392,1,0,0,0,394,395,1,0,0,0,395,39,1,0,0,0,396,
  	394,1,0,0,0,397,402,3,38,19,0,398,399,5,7,0,0,399,401,3,38,19,0,400,398,
  	1,0,0,0,401,404,1,0,0,0,402,400,1,0,0,0,402,403,1,0,0,0,403,406,1,0,0,
  	0,404,402,1,0,0,0,405,397,1,0,0,0,405,406,1,0,0,0,406,41,1,0,0,0,407,
  	408,5,141,0,0,408,409,5,28,0,0,409,410,3,38,19,0,410,43,1,0,0,0,411,416,
  	5,141,0,0,412,413,5,7,0,0,413,415,5,141,0,0,414,412,1,0,0,0,415,418,1,
  	0,0,0,416,414,1,0,0,0,416,417,1,0,0,0,417,419,1,0,0,0,418,416,1,0,0,0,
  	419,420,5,28,0,0,420,422,3,30,15,0,421,423,3,46,23,0,422,421,1,0,0,0,
  	422,423,1,0,0,0,423,425,1,0,0,0,424,426,3,50,25,0,425,424,1,0,0,0,425,
  	426,1,0,0,0,426,45,1,0,0,0,427,428,5,34,0,0,428,429,3,48,24,0,429,47,
  	1,0,0,0,430,440,5,141,0,0,431,433,5,35,0,0,432,434,5,30,0,0,433,432,1,
  	0,0,0,433,434,1,0,0,0,434,435,1,0,0,0,435,437,5,141,0,0,436,438,5,31,
  	0,0,437,436,1,0,0,0,437,438,1,0,0,0,438,440,1,0,0,0,439,430,1,0,0,0,439,
  	431,1,0,0,0,440,49,1,0,0,0,441,442,5,36,0,0,442,443,5,8,0,0,443,444,3,
  	38,19,0,444,51,1,0,0,0,445,446,3,54,27,0,446,447,5,141,0,0,447,448,3,
  	56,28,0,448,449,5,13,0,0,449,451,3,56,28,0,450,452,5,2,0,0,451,450,1,
  	0,0,0,451,452,1,0,0,0,452,453,1,0,0,0,453,454,3,58,29,0,454,53,1,0,0,
  	0,455,458,5,37,0,0,456,458,5,38,0,0,457,455,1,0,0,0,457,456,1,0,0,0,458,
  	55,1,0,0,0,459,468,5,30,0,0,460,465,3,44,22,0,461,462,5,2,0,0,462,464,
  	3,44,22,0,463,461,1,0,0,0,464,467,1,0,0,0,465,463,1,0,0,0,465,466,1,0,
  	0,0,466,469,1,0,0,0,467,465,1,0,0,0,468,460,1,0,0,0,468,469,1,0,0,0,469,
  	471,1,0,0,0,470,472,5,2,0,0,471,470,1,0,0,0,471,472,1,0,0,0,472,473,1,
  	0,0,0,473,474,5,31,0,0,474,57,1,0,0,0,475,494,5,2,0,0,476,478,3,60,30,
  	0,477,476,1,0,0,0,477,478,1,0,0,0,478,480,1,0,0,0,479,481,3,62,31,0,480,
  	479,1,0,0,0,480,481,1,0,0,0,481,482,1,0,0,0,482,486,5,39,0,0,483,485,
  	3,64,32,0,484,483,1,0,0,0,485,488,1,0,0,0,486,484,1,0,0,0,486,487,1,0,
  	0,0,487,489,1,0,0,0,488,486,1,0,0,0,489,491,5,40,0,0,490,492,5,2,0,0,
  	491,490,1,0,0,0,491,492,1,0,0,0,492,494,1,0,0,0,493,475,1,0,0,0,493,477,
  	1,0,0,0,494,59,1,0,0,0,495,499,5,41,0,0,496,498,3,70,35,0,497,496,1,0,
  	0,0,498,501,1,0,0,0,499,497,1,0,0,0,499,500,1,0,0,0,500,502,1,0,0,0,501,
  	499,1,0,0,0,502,512,5,42,0,0,503,507,5,43,0,0,504,506,3,70,35,0,505,504,
  	1,0,0,0,506,509,1,0,0,0,507,505,1,0,0,0,507,508,1,0,0,0,508,510,1,0,0,
  	0,509,507,1,0,0,0,510,512,5,44,0,0,511,495,1,0,0,0,511,503,1,0,0,0,512,
  	61,1,0,0,0,513,519,5,45,0,0,514,515,3,44,22,0,515,516,5,2,0,0,516,518,
  	1,0,0,0,517,514,1,0,0,0,518,521,1,0,0,0,519,517,1,0,0,0,519,520,1,0,0,
  	0,520,63,1,0,0,0,521,519,1,0,0,0,522,523,3,104,52,0,523,524,5,2,0,0,524,
  	531,1,0,0,0,525,531,3,94,47,0,526,527,3,90,45,0,527,528,5,46,0,0,528,
  	531,1,0,0,0,529,531,3,96,48,0,530,522,1,0,0,0,530,525,1,0,0,0,530,526,
  	1,0,0,0,530,529,1,0,0,0,531,65,1,0,0,0,532,533,5,47,0,0,533,534,5,141,
  	0,0,534,535,3,56,28,0,535,536,5,13,0,0,536,538,3,56,28,0,537,539,5,2,
  	0,0,538,537,1,0,0,0,538,539,1,0,0,0,539,540,1,0,0,0,540,541,3,68,34,0,
  	541,67,1,0,0,0,542,544,5,39,0,0,543,545,3,70,35,0,544,543,1,0,0,0,545,
  	546,1,0,0,0,546,544,1,0,0,0,546,547,1,0,0,0,547,548,1,0,0,0,548,549,5,
  	40,0,0,549,69,1,0,0,0,550,557,3,72,36,0,551,557,3,80,40,0,552,557,3,82,
  	41,0,553,557,3,84,42,0,554,557,3,86,43,0,555,557,3,88,44,0,556,550,1,
  	0,0,0,556,551,1,0,0,0,556,552,1,0,0,0,556,553,1,0,0,0,556,554,1,0,0,0,
  	556,555,1,0,0,0,557,71,1,0,0,0,558,559,5,48,0,0,559,560,5,141,0,0,560,
  	561,5,30,0,0,561,562,3,74,37,0,562,563,5,31,0,0,563,564,5,2,0,0,564,73,
  	1,0,0,0,565,568,3,76,38,0,566,568,3,78,39,0,567,565,1,0,0,0,567,566,1,
  	0,0,0,568,569,1,0,0,0,569,567,1,0,0,0,569,570,1,0,0,0,570,75,1,0,0,0,
  	571,575,5,49,0,0,572,574,9,0,0,0,573,572,1,0,0,0,574,577,1,0,0,0,575,
  	576,1,0,0,0,575,573,1,0,0,0,576,578,1,0,0,0,577,575,1,0,0,0,578,579,5,
  	2,0,0,579,77,1,0,0,0,580,584,5,50,0,0,581,583,9,0,0,0,582,581,1,0,0,0,
  	583,586,1,0,0,0,584,585,1,0,0,0,584,582,1,0,0,0,585,587,1,0,0,0,586,584,
  	1,0,0,0,587,588,5,2,0,0,588,79,1,0,0,0,589,592,5,141,0,0,590,591,5,28,
  	0,0,591,593,3,30,15,0,592,590,1,0,0,0,592,593,1,0,0,0,593,594,1,0,0,0,
  	594,598,5,8,0,0,595,597,9,0,0,0,596,595,1,0,0,0,597,600,1,0,0,0,598,599,
  	1,0,0,0,598,596,1,0,0,0,599,601,1,0,0,0,600,598,1,0,0,0,601,602,5,2,0,
  	0,602,81,1,0,0,0,603,604,5,45,0,0,604,605,5,141,0,0,605,606,5,28,0,0,
  	606,607,3,30,15,0,607,611,5,8,0,0,608,610,9,0,0,0,609,608,1,0,0,0,610,
  	613,1,0,0,0,611,612,1,0,0,0,611,609,1,0,0,0,612,614,1,0,0,0,613,611,1,
  	0,0,0,614,615,5,2,0,0,615,83,1,0,0,0,616,620,5,51,0,0,617,619,9,0,0,0,
  	618,617,1,0,0,0,619,622,1,0,0,0,620,621,1,0,0,0,620,618,1,0,0,0,621,623,
  	1,0,0,0,622,620,1,0,0,0,623,624,5,2,0,0,624,85,1,0,0,0,625,629,5,52,0,
  	0,626,628,9,0,0,0,627,626,1,0,0,0,628,631,1,0,0,0,629,630,1,0,0,0,629,
  	627,1,0,0,0,630,632,1,0,0,0,631,629,1,0,0,0,632,633,5,2,0,0,633,87,1,
  	0,0,0,634,635,5,53,0,0,635,636,5,141,0,0,636,642,5,30,0,0,637,638,3,124,
  	62,0,638,639,5,7,0,0,639,641,1,0,0,0,640,637,1,0,0,0,641,644,1,0,0,0,
  	642,640,1,0,0,0,642,643,1,0,0,0,643,645,1,0,0,0,644,642,1,0,0,0,645,646,
  	3,124,62,0,646,647,5,31,0,0,647,648,5,13,0,0,648,653,5,30,0,0,649,650,
  	5,141,0,0,650,652,5,7,0,0,651,649,1,0,0,0,652,655,1,0,0,0,653,651,1,0,
  	0,0,653,654,1,0,0,0,654,656,1,0,0,0,655,653,1,0,0,0,656,657,5,141,0,0,
  	657,658,5,31,0,0,658,659,5,2,0,0,659,89,1,0,0,0,660,661,5,54,0,0,661,
  	662,3,170,85,0,662,666,5,55,0,0,663,664,3,170,85,0,664,665,5,2,0,0,665,
  	667,1,0,0,0,666,663,1,0,0,0,667,668,1,0,0,0,668,666,1,0,0,0,668,669,1,
  	0,0,0,669,673,1,0,0,0,670,672,3,92,46,0,671,670,1,0,0,0,672,675,1,0,0,
  	0,673,671,1,0,0,0,673,674,1,0,0,0,674,91,1,0,0,0,675,673,1,0,0,0,676,
  	677,5,56,0,0,677,678,3,170,85,0,678,682,5,55,0,0,679,680,3,170,85,0,680,
  	681,5,2,0,0,681,683,1,0,0,0,682,679,1,0,0,0,683,684,1,0,0,0,684,682,1,
  	0,0,0,684,685,1,0,0,0,685,695,1,0,0,0,686,690,5,57,0,0,687,688,3,170,
  	85,0,688,689,5,2,0,0,689,691,1,0,0,0,690,687,1,0,0,0,691,692,1,0,0,0,
  	692,690,1,0,0,0,692,693,1,0,0,0,693,695,1,0,0,0,694,676,1,0,0,0,694,686,
  	1,0,0,0,695,93,1,0,0,0,696,700,5,146,0,0,697,700,5,147,0,0,698,700,5,
  	148,0,0,699,696,1,0,0,0,699,697,1,0,0,0,699,698,1,0,0,0,700,95,1,0,0,
  	0,701,702,3,98,49,0,702,703,3,100,50,0,703,97,1,0,0,0,704,705,5,58,0,
  	0,705,706,5,30,0,0,706,711,5,141,0,0,707,708,5,7,0,0,708,710,5,141,0,
  	0,709,707,1,0,0,0,710,713,1,0,0,0,711,709,1,0,0,0,711,712,1,0,0,0,712,
  	714,1,0,0,0,713,711,1,0,0,0,714,720,5,31,0,0,715,716,3,170,85,0,716,717,
  	5,2,0,0,717,719,1,0,0,0,718,715,1,0,0,0,719,722,1,0,0,0,720,718,1,0,0,
  	0,720,721,1,0,0,0,721,99,1,0,0,0,722,720,1,0,0,0,723,729,5,39,0,0,724,
  	725,3,104,52,0,725,726,5,2,0,0,726,728,1,0,0,0,727,724,1,0,0,0,728,731,
  	1,0,0,0,729,727,1,0,0,0,729,730,1,0,0,0,730,732,1,0,0,0,731,729,1,0,0,
  	0,732,733,5,40,0,0,733,101,1,0,0,0,734,735,5,37,0,0,735,736,5,59,0,0,
  	736,737,5,141,0,0,737,738,3,56,28,0,738,739,5,13,0,0,739,740,3,56,28,
  	0,740,103,1,0,0,0,741,742,3,106,53,0,742,743,5,8,0,0,743,744,3,124,62,
  	0,744,749,1,0,0,0,745,746,3,112,56,0,746,747,3,108,54,0,747,749,1,0,0,
  	0,748,741,1,0,0,0,748,745,1,0,0,0,749,105,1,0,0,0,750,751,5,30,0,0,751,
  	767,5,31,0,0,752,754,5,30,0,0,753,752,1,0,0,0,753,754,1,0,0,0,754,755,
  	1,0,0,0,755,760,5,141,0,0,756,757,5,7,0,0,757,759,5,141,0,0,758,756,1,
  	0,0,0,759,762,1,0,0,0,760,758,1,0,0,0,760,761,1,0,0,0,761,764,1,0,0,0,
  	762,760,1,0,0,0,763,765,5,31,0,0,764,763,1,0,0,0,764,765,1,0,0,0,765,
  	767,1,0,0,0,766,750,1,0,0,0,766,753,1,0,0,0,767,107,1,0,0,0,768,769,5,
  	13,0,0,769,770,3,110,55,0,770,109,1,0,0,0,771,772,5,141,0,0,772,774,5,
  	7,0,0,773,771,1,0,0,0,774,777,1,0,0,0,775,773,1,0,0,0,775,776,1,0,0,0,
  	776,779,1,0,0,0,777,775,1,0,0,0,778,780,7,2,0,0,779,778,1,0,0,0,779,780,
  	1,0,0,0,780,111,1,0,0,0,781,783,5,61,0,0,782,784,5,141,0,0,783,782,1,
  	0,0,0,783,784,1,0,0,0,784,786,1,0,0,0,785,787,3,114,57,0,786,785,1,0,
  	0,0,787,788,1,0,0,0,788,786,1,0,0,0,788,789,1,0,0,0,789,113,1,0,0,0,790,
  	792,5,129,0,0,791,790,1,0,0,0,791,792,1,0,0,0,792,794,1,0,0,0,793,795,
  	5,130,0,0,794,793,1,0,0,0,794,795,1,0,0,0,795,796,1,0,0,0,796,797,5,62,
  	0,0,797,799,5,141,0,0,798,800,3,118,59,0,799,798,1,0,0,0,799,800,1,0,
  	0,0,800,801,1,0,0,0,801,803,3,116,58,0,802,804,3,120,60,0,803,802,1,0,
  	0,0,803,804,1,0,0,0,804,115,1,0,0,0,805,822,3,104,52,0,806,808,3,62,31,
  	0,807,806,1,0,0,0,807,808,1,0,0,0,808,819,1,0,0,0,809,815,5,39,0,0,810,
  	811,3,104,52,0,811,812,5,2,0,0,812,814,1,0,0,0,813,810,1,0,0,0,814,817,
  	1,0,0,0,815,813,1,0,0,0,815,816,1,0,0,0,816,818,1,0,0,0,817,815,1,0,0,
  	0,818,820,5,40,0,0,819,809,1,0,0,0,819,820,1,0,0,0,820,822,1,0,0,0,821,
  	805,1,0,0,0,821,807,1,0,0,0,822,117,1,0,0,0,823,827,5,131,0,0,824,825,
  	3,122,61,0,825,826,5,2,0,0,826,828,1,0,0,0,827,824,1,0,0,0,828,829,1,
  	0,0,0,829,827,1,0,0,0,829,830,1,0,0,0,830,119,1,0,0,0,831,837,5,132,0,
  	0,832,833,3,122,61,0,833,834,5,2,0,0,834,836,1,0,0,0,835,832,1,0,0,0,
  	836,839,1,0,0,0,837,835,1,0,0,0,837,838,1,0,0,0,838,121,1,0,0,0,839,837,
  	1,0,0,0,840,841,5,54,0,0,841,842,3,124,62,0,842,843,5,63,0,0,843,844,
  	5,141,0,0,844,851,1,0,0,0,845,846,5,54,0,0,846,847,3,124,62,0,847,848,
  	5,64,0,0,848,849,5,141,0,0,849,851,1,0,0,0,850,840,1,0,0,0,850,845,1,
  	0,0,0,851,123,1,0,0,0,852,869,3,170,85,0,853,854,5,36,0,0,854,855,5,65,
  	0,0,855,869,5,141,0,0,856,869,3,140,70,0,857,869,3,142,71,0,858,869,3,
  	144,72,0,859,869,3,146,73,0,860,869,3,148,74,0,861,869,3,156,78,0,862,
  	863,5,30,0,0,863,864,3,124,62,0,864,865,5,31,0,0,865,869,1,0,0,0,866,
  	869,3,162,81,0,867,869,3,128,64,0,868,852,1,0,0,0,868,853,1,0,0,0,868,
  	856,1,0,0,0,868,857,1,0,0,0,868,858,1,0,0,0,868,859,1,0,0,0,868,860,1,
  	0,0,0,868,861,1,0,0,0,868,862,1,0,0,0,868,866,1,0,0,0,868,867,1,0,0,0,
  	869,125,1,0,0,0,870,875,3,170,85,0,871,872,5,7,0,0,872,874,3,170,85,0,
  	873,871,1,0,0,0,874,877,1,0,0,0,875,873,1,0,0,0,875,876,1,0,0,0,876,879,
  	1,0,0,0,877,875,1,0,0,0,878,870,1,0,0,0,878,879,1,0,0,0,879,127,1,0,0,
  	0,880,883,3,130,65,0,881,883,3,132,66,0,882,880,1,0,0,0,882,881,1,0,0,
  	0,883,129,1,0,0,0,884,885,5,30,0,0,885,886,3,136,68,0,886,887,5,31,0,
  	0,887,888,3,134,67,0,888,900,1,0,0,0,889,890,5,30,0,0,890,891,5,66,0,
  	0,891,892,5,30,0,0,892,893,3,138,69,0,893,894,5,31,0,0,894,895,5,67,0,
  	0,895,896,5,141,0,0,896,897,5,31,0,0,897,898,3,134,67,0,898,900,1,0,0,
  	0,899,884,1,0,0,0,899,889,1,0,0,0,900,131,1,0,0,0,901,902,5,30,0,0,902,
  	903,3,138,69,0,903,904,5,31,0,0,904,905,3,134,67,0,905,915,1,0,0,0,906,
  	907,5,30,0,0,907,908,3,136,68,0,908,909,5,64,0,0,909,910,5,67,0,0,910,
  	911,5,141,0,0,911,912,5,31,0,0,912,913,3,134,67,0,913,915,1,0,0,0,914,
  	901,1,0,0,0,914,906,1,0,0,0,915,133,1,0,0,0,916,919,5,30,0,0,917,920,
  	5,141,0,0,918,920,3,180,90,0,919,917,1,0,0,0,919,918,1,0,0,0,920,928,
  	1,0,0,0,921,924,5,7,0,0,922,925,5,141,0,0,923,925,3,180,90,0,924,922,
  	1,0,0,0,924,923,1,0,0,0,925,927,1,0,0,0,926,921,1,0,0,0,927,930,1,0,0,
  	0,928,926,1,0,0,0,928,929,1,0,0,0,929,931,1,0,0,0,930,928,1,0,0,0,931,
  	932,5,31,0,0,932,135,1,0,0,0,933,934,5,66,0,0,934,935,5,141,0,0,935,936,
  	5,67,0,0,936,937,5,141,0,0,937,137,1,0,0,0,938,939,5,64,0,0,939,940,5,
  	141,0,0,940,941,5,67,0,0,941,942,5,141,0,0,942,139,1,0,0,0,943,944,5,
  	68,0,0,944,1002,3,170,85,0,945,946,3,170,85,0,946,947,5,69,0,0,947,948,
  	3,140,70,0,948,1002,1,0,0,0,949,950,3,170,85,0,950,951,5,69,0,0,951,952,
  	3,170,85,0,952,1002,1,0,0,0,953,954,5,70,0,0,954,955,5,30,0,0,955,960,
  	3,170,85,0,956,957,5,7,0,0,957,959,3,170,85,0,958,956,1,0,0,0,959,962,
  	1,0,0,0,960,958,1,0,0,0,960,961,1,0,0,0,961,963,1,0,0,0,962,960,1,0,0,
  	0,963,964,5,2,0,0,964,965,3,38,19,0,965,966,5,2,0,0,966,971,3,170,85,
  	0,967,968,5,7,0,0,968,970,3,170,85,0,969,967,1,0,0,0,970,973,1,0,0,0,
  	971,969,1,0,0,0,971,972,1,0,0,0,972,974,1,0,0,0,973,971,1,0,0,0,974,975,
  	5,31,0,0,975,1002,1,0,0,0,976,977,3,170,85,0,977,978,5,70,0,0,978,979,
  	3,170,85,0,979,1002,1,0,0,0,980,981,3,170,85,0,981,982,5,34,0,0,982,983,
  	3,48,24,0,983,1002,1,0,0,0,984,985,5,71,0,0,985,986,5,141,0,0,986,987,
  	3,170,85,0,987,988,3,170,85,0,988,1002,1,0,0,0,989,990,5,71,0,0,990,991,
  	5,30,0,0,991,996,3,182,91,0,992,993,5,2,0,0,993,995,3,182,91,0,994,992,
  	1,0,0,0,995,998,1,0,0,0,996,994,1,0,0,0,996,997,1,0,0,0,997,999,1,0,0,
  	0,998,996,1,0,0,0,999,1000,5,31,0,0,1000,1002,1,0,0,0,1001,943,1,0,0,
  	0,1001,945,1,0,0,0,1001,949,1,0,0,0,1001,953,1,0,0,0,1001,976,1,0,0,0,
  	1001,980,1,0,0,0,1001,984,1,0,0,0,1001,989,1,0,0,0,1002,141,1,0,0,0,1003,
  	1005,5,72,0,0,1004,1006,5,30,0,0,1005,1004,1,0,0,0,1005,1006,1,0,0,0,
  	1006,1007,1,0,0,0,1007,1009,3,126,63,0,1008,1010,5,31,0,0,1009,1008,1,
  	0,0,0,1009,1010,1,0,0,0,1010,143,1,0,0,0,1011,1012,3,170,85,0,1012,1013,
  	5,32,0,0,1013,1014,5,134,0,0,1014,1015,5,60,0,0,1015,1016,5,134,0,0,1016,
  	1017,5,33,0,0,1017,1048,1,0,0,0,1018,1019,5,30,0,0,1019,1020,3,170,85,
  	0,1020,1022,5,73,0,0,1021,1023,3,152,76,0,1022,1021,1,0,0,0,1023,1024,
  	1,0,0,0,1024,1022,1,0,0,0,1024,1025,1,0,0,0,1025,1026,1,0,0,0,1026,1027,
  	5,74,0,0,1027,1028,3,170,85,0,1028,1029,5,31,0,0,1029,1048,1,0,0,0,1030,
  	1031,3,170,85,0,1031,1032,5,27,0,0,1032,1033,3,38,19,0,1033,1048,1,0,
  	0,0,1034,1035,5,32,0,0,1035,1036,3,126,63,0,1036,1044,5,33,0,0,1037,1038,
  	5,7,0,0,1038,1039,5,32,0,0,1039,1040,3,126,63,0,1040,1041,5,33,0,0,1041,
  	1043,1,0,0,0,1042,1037,1,0,0,0,1043,1046,1,0,0,0,1044,1042,1,0,0,0,1044,
  	1045,1,0,0,0,1045,1048,1,0,0,0,1046,1044,1,0,0,0,1047,1011,1,0,0,0,1047,
  	1018,1,0,0,0,1047,1030,1,0,0,0,1047,1034,1,0,0,0,1048,145,1,0,0,0,1049,
  	1050,5,16,0,0,1050,1055,3,150,75,0,1051,1052,7,1,0,0,1052,1054,3,150,
  	75,0,1053,1051,1,0,0,0,1054,1057,1,0,0,0,1055,1053,1,0,0,0,1055,1056,
  	1,0,0,0,1056,1058,1,0,0,0,1057,1055,1,0,0,0,1058,1059,5,17,0,0,1059,147,
  	1,0,0,0,1060,1061,5,30,0,0,1061,1062,5,141,0,0,1062,1064,5,75,0,0,1063,
  	1065,3,154,77,0,1064,1063,1,0,0,0,1065,1066,1,0,0,0,1066,1064,1,0,0,0,
  	1066,1067,1,0,0,0,1067,1068,1,0,0,0,1068,1069,5,8,0,0,1069,1070,3,170,
  	85,0,1070,1071,5,31,0,0,1071,149,1,0,0,0,1072,1073,5,141,0,0,1073,1074,
  	5,28,0,0,1074,1075,3,170,85,0,1075,151,1,0,0,0,1076,1077,5,32,0,0,1077,
  	1078,3,170,85,0,1078,1079,5,33,0,0,1079,153,1,0,0,0,1080,1081,5,73,0,
  	0,1081,1084,5,141,0,0,1082,1084,3,152,76,0,1083,1080,1,0,0,0,1083,1082,
  	1,0,0,0,1084,155,1,0,0,0,1085,1086,5,54,0,0,1086,1087,3,170,85,0,1087,
  	1088,5,55,0,0,1088,1089,3,170,85,0,1089,1090,5,57,0,0,1090,1091,3,170,
  	85,0,1091,1104,1,0,0,0,1092,1093,5,30,0,0,1093,1094,5,76,0,0,1094,1095,
  	3,170,85,0,1095,1097,5,77,0,0,1096,1098,3,158,79,0,1097,1096,1,0,0,0,
  	1098,1099,1,0,0,0,1099,1097,1,0,0,0,1099,1100,1,0,0,0,1100,1101,1,0,0,
  	0,1101,1102,5,31,0,0,1102,1104,1,0,0,0,1103,1085,1,0,0,0,1103,1092,1,
  	0,0,0,1104,157,1,0,0,0,1105,1106,5,78,0,0,1106,1107,3,160,80,0,1107,1108,
  	5,28,0,0,1108,1109,3,170,85,0,1109,159,1,0,0,0,1110,1119,5,141,0,0,1111,
  	1119,5,137,0,0,1112,1114,5,79,0,0,1113,1112,1,0,0,0,1113,1114,1,0,0,0,
  	1114,1115,1,0,0,0,1115,1119,5,134,0,0,1116,1119,5,133,0,0,1117,1119,5,
  	80,0,0,1118,1110,1,0,0,0,1118,1111,1,0,0,0,1118,1113,1,0,0,0,1118,1116,
  	1,0,0,0,1118,1117,1,0,0,0,1119,161,1,0,0,0,1120,1121,3,164,82,0,1121,
  	1122,5,30,0,0,1122,1123,3,126,63,0,1123,1124,5,31,0,0,1124,1232,1,0,0,
  	0,1125,1126,5,81,0,0,1126,1127,5,82,0,0,1127,1128,3,164,82,0,1128,1129,
  	5,2,0,0,1129,1130,3,38,19,0,1130,1131,5,83,0,0,1131,1132,5,30,0,0,1132,
  	1133,3,126,63,0,1133,1134,5,31,0,0,1134,1232,1,0,0,0,1135,1136,5,84,0,
  	0,1136,1137,5,82,0,0,1137,1138,3,164,82,0,1138,1139,5,2,0,0,1139,1140,
  	3,38,19,0,1140,1141,5,83,0,0,1141,1142,5,30,0,0,1142,1143,3,126,63,0,
  	1143,1144,5,31,0,0,1144,1232,1,0,0,0,1145,1146,5,85,0,0,1146,1147,5,82,
  	0,0,1147,1148,3,164,82,0,1148,1149,5,2,0,0,1149,1150,3,38,19,0,1150,1151,
  	5,83,0,0,1151,1152,5,30,0,0,1152,1153,3,126,63,0,1153,1154,5,31,0,0,1154,
  	1232,1,0,0,0,1155,1156,5,86,0,0,1156,1157,5,82,0,0,1157,1158,3,164,82,
  	0,1158,1159,5,2,0,0,1159,1160,3,38,19,0,1160,1161,5,83,0,0,1161,1162,
  	5,30,0,0,1162,1163,3,126,63,0,1163,1164,5,31,0,0,1164,1232,1,0,0,0,1165,
  	1166,5,87,0,0,1166,1167,5,82,0,0,1167,1168,3,164,82,0,1168,1169,5,2,0,
  	0,1169,1170,3,38,19,0,1170,1171,5,83,0,0,1171,1172,5,30,0,0,1172,1173,
  	3,126,63,0,1173,1174,5,31,0,0,1174,1232,1,0,0,0,1175,1176,5,88,0,0,1176,
  	1177,5,82,0,0,1177,1178,3,164,82,0,1178,1179,5,2,0,0,1179,1180,3,38,19,
  	0,1180,1181,5,83,0,0,1181,1182,5,54,0,0,1182,1183,3,170,85,0,1183,1184,
  	5,74,0,0,1184,1185,5,30,0,0,1185,1186,3,126,63,0,1186,1187,5,31,0,0,1187,
  	1188,5,30,0,0,1188,1189,3,126,63,0,1189,1190,5,31,0,0,1190,1232,1,0,0,
  	0,1191,1192,5,89,0,0,1192,1193,5,82,0,0,1193,1194,3,164,82,0,1194,1195,
  	5,2,0,0,1195,1196,3,38,19,0,1196,1197,5,83,0,0,1197,1198,5,54,0,0,1198,
  	1199,3,170,85,0,1199,1200,5,74,0,0,1200,1201,5,30,0,0,1201,1202,3,126,
  	63,0,1202,1203,5,31,0,0,1203,1204,5,30,0,0,1204,1205,3,126,63,0,1205,
  	1206,5,31,0,0,1206,1232,1,0,0,0,1207,1208,5,90,0,0,1208,1209,5,82,0,0,
  	1209,1210,3,164,82,0,1210,1211,5,2,0,0,1211,1212,3,38,19,0,1212,1213,
  	5,83,0,0,1213,1214,5,54,0,0,1214,1215,3,170,85,0,1215,1216,5,30,0,0,1216,
  	1217,3,126,63,0,1217,1218,5,31,0,0,1218,1232,1,0,0,0,1219,1220,5,91,0,
  	0,1220,1221,5,82,0,0,1221,1222,3,164,82,0,1222,1223,5,2,0,0,1223,1224,
  	3,38,19,0,1224,1225,5,83,0,0,1225,1226,5,54,0,0,1226,1227,3,170,85,0,
  	1227,1228,5,30,0,0,1228,1229,3,126,63,0,1229,1230,5,31,0,0,1230,1232,
  	1,0,0,0,1231,1120,1,0,0,0,1231,1125,1,0,0,0,1231,1135,1,0,0,0,1231,1145,
  	1,0,0,0,1231,1155,1,0,0,0,1231,1165,1,0,0,0,1231,1175,1,0,0,0,1231,1191,
  	1,0,0,0,1231,1207,1,0,0,0,1231,1219,1,0,0,0,1232,163,1,0,0,0,1233,1245,
  	5,141,0,0,1234,1245,3,166,83,0,1235,1245,3,168,84,0,1236,1237,5,30,0,
  	0,1237,1238,5,92,0,0,1238,1239,5,141,0,0,1239,1245,5,31,0,0,1240,1241,
  	5,30,0,0,1241,1242,5,93,0,0,1242,1243,5,141,0,0,1243,1245,5,31,0,0,1244,
  	1233,1,0,0,0,1244,1234,1,0,0,0,1244,1235,1,0,0,0,1244,1236,1,0,0,0,1244,
  	1240,1,0,0,0,1245,165,1,0,0,0,1246,1247,7,3,0,0,1247,167,1,0,0,0,1248,
  	1249,7,4,0,0,1249,169,1,0,0,0,1250,1251,6,85,-1,0,1251,1274,5,141,0,0,
  	1252,1274,3,180,90,0,1253,1254,5,30,0,0,1254,1259,3,170,85,0,1255,1256,
  	5,7,0,0,1256,1258,3,170,85,0,1257,1255,1,0,0,0,1258,1261,1,0,0,0,1259,
  	1257,1,0,0,0,1259,1260,1,0,0,0,1260,1262,1,0,0,0,1261,1259,1,0,0,0,1262,
  	1263,5,31,0,0,1263,1274,1,0,0,0,1264,1265,3,172,86,0,1265,1266,3,170,
  	85,6,1266,1274,1,0,0,0,1267,1268,3,30,15,0,1268,1269,3,170,85,2,1269,
  	1274,1,0,0,0,1270,1271,3,176,88,0,1271,1272,3,128,64,0,1272,1274,1,0,
  	0,0,1273,1250,1,0,0,0,1273,1252,1,0,0,0,1273,1253,1,0,0,0,1273,1264,1,
  	0,0,0,1273,1267,1,0,0,0,1273,1270,1,0,0,0,1274,1297,1,0,0,0,1275,1276,
  	10,5,0,0,1276,1277,3,174,87,0,1277,1278,3,170,85,6,1278,1296,1,0,0,0,
  	1279,1280,10,4,0,0,1280,1281,3,178,89,0,1281,1282,3,170,85,5,1282,1296,
  	1,0,0,0,1283,1284,10,3,0,0,1284,1285,3,176,88,0,1285,1286,3,170,85,4,
  	1286,1296,1,0,0,0,1287,1288,10,8,0,0,1288,1289,5,32,0,0,1289,1290,3,38,
  	19,0,1290,1291,5,33,0,0,1291,1296,1,0,0,0,1292,1293,10,7,0,0,1293,1294,
  	5,73,0,0,1294,1296,5,141,0,0,1295,1275,1,0,0,0,1295,1279,1,0,0,0,1295,
  	1283,1,0,0,0,1295,1287,1,0,0,0,1295,1292,1,0,0,0,1296,1299,1,0,0,0,1297,
  	1295,1,0,0,0,1297,1298,1,0,0,0,1298,171,1,0,0,0,1299,1297,1,0,0,0,1300,
  	1304,5,79,0,0,1301,1304,5,116,0,0,1302,1304,5,35,0,0,1303,1300,1,0,0,
  	0,1303,1301,1,0,0,0,1303,1302,1,0,0,0,1304,173,1,0,0,0,1305,1312,5,116,
  	0,0,1306,1312,5,79,0,0,1307,1312,5,117,0,0,1308,1312,5,118,0,0,1309,1312,
  	5,119,0,0,1310,1312,5,120,0,0,1311,1305,1,0,0,0,1311,1306,1,0,0,0,1311,
  	1307,1,0,0,0,1311,1308,1,0,0,0,1311,1309,1,0,0,0,1311,1310,1,0,0,0,1312,
  	175,1,0,0,0,1313,1314,7,5,0,0,1314,177,1,0,0,0,1315,1316,7,6,0,0,1316,
  	179,1,0,0,0,1317,1326,5,133,0,0,1318,1326,5,137,0,0,1319,1326,5,134,0,
  	0,1320,1326,5,135,0,0,1321,1326,5,138,0,0,1322,1326,5,136,0,0,1323,1326,
  	5,139,0,0,1324,1326,5,140,0,0,1325,1317,1,0,0,0,1325,1318,1,0,0,0,1325,
  	1319,1,0,0,0,1325,1320,1,0,0,0,1325,1321,1,0,0,0,1325,1322,1,0,0,0,1325,
  	1323,1,0,0,0,1325,1324,1,0,0,0,1326,181,1,0,0,0,1327,1331,5,141,0,0,1328,
  	1331,3,140,70,0,1329,1331,3,128,64,0,1330,1327,1,0,0,0,1330,1328,1,0,
  	0,0,1330,1329,1,0,0,0,1331,183,1,0,0,0,125,187,189,191,200,205,221,239,
  	245,267,275,281,291,295,308,316,321,328,341,347,351,373,378,392,394,402,
  	405,416,422,425,433,437,439,451,457,465,468,471,477,480,486,491,493,499,
  	507,511,519,530,538,546,556,567,569,575,584,592,598,611,620,629,642,653,
  	668,673,684,692,694,699,711,720,729,748,753,760,764,766,775,779,783,788,
  	791,794,799,803,807,815,819,821,829,837,850,868,875,878,882,899,914,919,
  	924,928,960,971,996,1001,1005,1009,1024,1044,1047,1055,1066,1083,1099,
  	1103,1113,1118,1231,1244,1259,1273,1295,1297,1303,1311,1325,1330
  };
  staticData->serializedATN = antlr4::atn::SerializedATNView(serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

  antlr4::atn::ATNDeserializer deserializer;
  staticData->atn = deserializer.deserialize(staticData->serializedATN);

  const size_t count = staticData->atn->getNumberOfDecisions();
  staticData->decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
  }
  lustreParserStaticData = staticData.release();
}

}

LustreParser::LustreParser(TokenStream *input) : LustreParser(input, antlr4::atn::ParserATNSimulatorOptions()) {}

LustreParser::LustreParser(TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options) : Parser(input) {
  LustreParser::initialize();
  _interpreter = new atn::ParserATNSimulator(this, *lustreParserStaticData->atn, lustreParserStaticData->decisionToDFA, lustreParserStaticData->sharedContextCache, options);
}

LustreParser::~LustreParser() {
  delete _interpreter;
}

const atn::ATN& LustreParser::getATN() const {
  return *lustreParserStaticData->atn;
}

std::string LustreParser::getGrammarFileName() const {
  return "Lustre.g4";
}

const std::vector<std::string>& LustreParser::getRuleNames() const {
  return lustreParserStaticData->ruleNames;
}

const dfa::Vocabulary& LustreParser::getVocabulary() const {
  return lustreParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView LustreParser::getSerializedATN() const {
  return lustreParserStaticData->serializedATN;
}


//----------------- ProgramContext ------------------------------------------------------------------

LustreParser::ProgramContext::ProgramContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LustreParser::IncludeContext* LustreParser::ProgramContext::include() {
  return getRuleContext<LustreParser::IncludeContext>(0);
}

std::vector<LustreParser::DeclsContext *> LustreParser::ProgramContext::decls() {
  return getRuleContexts<LustreParser::DeclsContext>();
}

LustreParser::DeclsContext* LustreParser::ProgramContext::decls(size_t i) {
  return getRuleContext<LustreParser::DeclsContext>(i);
}

std::vector<LustreParser::Pack_listContext *> LustreParser::ProgramContext::pack_list() {
  return getRuleContexts<LustreParser::Pack_listContext>();
}

LustreParser::Pack_listContext* LustreParser::ProgramContext::pack_list(size_t i) {
  return getRuleContext<LustreParser::Pack_listContext>(i);
}


size_t LustreParser::ProgramContext::getRuleIndex() const {
  return LustreParser::RuleProgram;
}

void LustreParser::ProgramContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProgram(this);
}

void LustreParser::ProgramContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProgram(this);
}


std::any LustreParser::ProgramContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitProgram(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::ProgramContext* LustreParser::program() {
  ProgramContext *_localctx = _tracker.createInstance<ProgramContext>(_ctx, getState());
  enterRule(_localctx, 0, LustreParser::RuleProgram);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(191);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LustreParser::T__0: {
        enterOuterAlt(_localctx, 1);
        setState(184);
        include();
        break;
      }

      case LustreParser::T__2:
      case LustreParser::T__10:
      case LustreParser::T__13:
      case LustreParser::T__28:
      case LustreParser::T__36:
      case LustreParser::T__37:
      case LustreParser::T__46: {
        enterOuterAlt(_localctx, 2);
        setState(187); 
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(187);
          _errHandler->sync(this);
          switch (_input->LA(1)) {
            case LustreParser::T__13:
            case LustreParser::T__28:
            case LustreParser::T__36:
            case LustreParser::T__37:
            case LustreParser::T__46: {
              setState(185);
              decls();
              break;
            }

            case LustreParser::T__2:
            case LustreParser::T__10: {
              setState(186);
              pack_list();
              break;
            }

          default:
            throw NoViableAltException(this);
          }
          setState(189); 
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 141150342105096) != 0));
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IncludeContext ------------------------------------------------------------------

LustreParser::IncludeContext::IncludeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LustreParser::IncludeContext::STRING() {
  return getToken(LustreParser::STRING, 0);
}


size_t LustreParser::IncludeContext::getRuleIndex() const {
  return LustreParser::RuleInclude;
}

void LustreParser::IncludeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInclude(this);
}

void LustreParser::IncludeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInclude(this);
}


std::any LustreParser::IncludeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitInclude(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::IncludeContext* LustreParser::include() {
  IncludeContext *_localctx = _tracker.createInstance<IncludeContext>(_ctx, getState());
  enterRule(_localctx, 2, LustreParser::RuleInclude);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(193);
    match(LustreParser::T__0);
    setState(194);
    match(LustreParser::STRING);
    setState(195);
    match(LustreParser::T__1);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pack_listContext ------------------------------------------------------------------

LustreParser::Pack_listContext::Pack_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<LustreParser::One_parkContext *> LustreParser::Pack_listContext::one_park() {
  return getRuleContexts<LustreParser::One_parkContext>();
}

LustreParser::One_parkContext* LustreParser::Pack_listContext::one_park(size_t i) {
  return getRuleContext<LustreParser::One_parkContext>(i);
}


size_t LustreParser::Pack_listContext::getRuleIndex() const {
  return LustreParser::RulePack_list;
}

void LustreParser::Pack_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPack_list(this);
}

void LustreParser::Pack_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPack_list(this);
}


std::any LustreParser::Pack_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitPack_list(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Pack_listContext* LustreParser::pack_list() {
  Pack_listContext *_localctx = _tracker.createInstance<Pack_listContext>(_ctx, getState());
  enterRule(_localctx, 4, LustreParser::RulePack_list);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(198); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(197);
              one_park();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(200); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 3, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- One_parkContext ------------------------------------------------------------------

LustreParser::One_parkContext::One_parkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LustreParser::Model_declContext* LustreParser::One_parkContext::model_decl() {
  return getRuleContext<LustreParser::Model_declContext>(0);
}

LustreParser::Pack_declContext* LustreParser::One_parkContext::pack_decl() {
  return getRuleContext<LustreParser::Pack_declContext>(0);
}

LustreParser::Pack_eqContext* LustreParser::One_parkContext::pack_eq() {
  return getRuleContext<LustreParser::Pack_eqContext>(0);
}


size_t LustreParser::One_parkContext::getRuleIndex() const {
  return LustreParser::RuleOne_park;
}

void LustreParser::One_parkContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOne_park(this);
}

void LustreParser::One_parkContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOne_park(this);
}


std::any LustreParser::One_parkContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitOne_park(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::One_parkContext* LustreParser::one_park() {
  One_parkContext *_localctx = _tracker.createInstance<One_parkContext>(_ctx, getState());
  enterRule(_localctx, 6, LustreParser::RuleOne_park);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(205);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 4, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(202);
      model_decl();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(203);
      pack_decl();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(204);
      pack_eq();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pack_declContext ------------------------------------------------------------------

LustreParser::Pack_declContext::Pack_declContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LustreParser::Pack_declContext::ID() {
  return getToken(LustreParser::ID, 0);
}

LustreParser::UsesContext* LustreParser::Pack_declContext::uses() {
  return getRuleContext<LustreParser::UsesContext>(0);
}

LustreParser::ProvidesContext* LustreParser::Pack_declContext::provides() {
  return getRuleContext<LustreParser::ProvidesContext>(0);
}

LustreParser::DeclsContext* LustreParser::Pack_declContext::decls() {
  return getRuleContext<LustreParser::DeclsContext>(0);
}


size_t LustreParser::Pack_declContext::getRuleIndex() const {
  return LustreParser::RulePack_decl;
}

void LustreParser::Pack_declContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPack_decl(this);
}

void LustreParser::Pack_declContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPack_decl(this);
}


std::any LustreParser::Pack_declContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitPack_decl(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Pack_declContext* LustreParser::pack_decl() {
  Pack_declContext *_localctx = _tracker.createInstance<Pack_declContext>(_ctx, getState());
  enterRule(_localctx, 8, LustreParser::RulePack_decl);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(207);
    match(LustreParser::T__2);
    setState(208);
    match(LustreParser::ID);
    setState(209);
    uses();
    setState(210);
    provides();
    setState(211);
    match(LustreParser::T__3);
    setState(212);
    decls();
    setState(213);
    match(LustreParser::T__4);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UsesContext ------------------------------------------------------------------

LustreParser::UsesContext::UsesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> LustreParser::UsesContext::ID() {
  return getTokens(LustreParser::ID);
}

tree::TerminalNode* LustreParser::UsesContext::ID(size_t i) {
  return getToken(LustreParser::ID, i);
}


size_t LustreParser::UsesContext::getRuleIndex() const {
  return LustreParser::RuleUses;
}

void LustreParser::UsesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUses(this);
}

void LustreParser::UsesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUses(this);
}


std::any LustreParser::UsesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitUses(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::UsesContext* LustreParser::uses() {
  UsesContext *_localctx = _tracker.createInstance<UsesContext>(_ctx, getState());
  enterRule(_localctx, 10, LustreParser::RuleUses);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(215);
    match(LustreParser::T__5);
    setState(216);
    match(LustreParser::ID);
    setState(221);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == LustreParser::T__6) {
      setState(217);
      match(LustreParser::T__6);
      setState(218);
      match(LustreParser::ID);
      setState(223);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(224);
    match(LustreParser::T__1);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pack_eqContext ------------------------------------------------------------------

LustreParser::Pack_eqContext::Pack_eqContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> LustreParser::Pack_eqContext::ID() {
  return getTokens(LustreParser::ID);
}

tree::TerminalNode* LustreParser::Pack_eqContext::ID(size_t i) {
  return getToken(LustreParser::ID, i);
}


size_t LustreParser::Pack_eqContext::getRuleIndex() const {
  return LustreParser::RulePack_eq;
}

void LustreParser::Pack_eqContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPack_eq(this);
}

void LustreParser::Pack_eqContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPack_eq(this);
}


std::any LustreParser::Pack_eqContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitPack_eq(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Pack_eqContext* LustreParser::pack_eq() {
  Pack_eqContext *_localctx = _tracker.createInstance<Pack_eqContext>(_ctx, getState());
  enterRule(_localctx, 12, LustreParser::RulePack_eq);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(226);
    match(LustreParser::T__2);
    setState(227);
    match(LustreParser::ID);
    setState(228);
    _la = _input->LA(1);
    if (!(_la == LustreParser::T__7

    || _la == LustreParser::T__8)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(229);
    match(LustreParser::ID);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ProvidesContext ------------------------------------------------------------------

LustreParser::ProvidesContext::ProvidesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<LustreParser::ProvideContext *> LustreParser::ProvidesContext::provide() {
  return getRuleContexts<LustreParser::ProvideContext>();
}

LustreParser::ProvideContext* LustreParser::ProvidesContext::provide(size_t i) {
  return getRuleContext<LustreParser::ProvideContext>(i);
}


size_t LustreParser::ProvidesContext::getRuleIndex() const {
  return LustreParser::RuleProvides;
}

void LustreParser::ProvidesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProvides(this);
}

void LustreParser::ProvidesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProvides(this);
}


std::any LustreParser::ProvidesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitProvides(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::ProvidesContext* LustreParser::provides() {
  ProvidesContext *_localctx = _tracker.createInstance<ProvidesContext>(_ctx, getState());
  enterRule(_localctx, 14, LustreParser::RuleProvides);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(231);
    match(LustreParser::T__9);
    setState(232);
    provide();
    setState(233);
    match(LustreParser::T__1);
    setState(239);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 412853747712) != 0)) {
      setState(234);
      provide();
      setState(235);
      match(LustreParser::T__1);
      setState(241);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ProvideContext ------------------------------------------------------------------

LustreParser::ProvideContext::ProvideContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LustreParser::Const_blockContext* LustreParser::ProvideContext::const_block() {
  return getRuleContext<LustreParser::Const_blockContext>(0);
}

LustreParser::Type_blockContext* LustreParser::ProvideContext::type_block() {
  return getRuleContext<LustreParser::Type_blockContext>(0);
}

LustreParser::User_op_provideContext* LustreParser::ProvideContext::user_op_provide() {
  return getRuleContext<LustreParser::User_op_provideContext>(0);
}


size_t LustreParser::ProvideContext::getRuleIndex() const {
  return LustreParser::RuleProvide;
}

void LustreParser::ProvideContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProvide(this);
}

void LustreParser::ProvideContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProvide(this);
}


std::any LustreParser::ProvideContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitProvide(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::ProvideContext* LustreParser::provide() {
  ProvideContext *_localctx = _tracker.createInstance<ProvideContext>(_ctx, getState());
  enterRule(_localctx, 16, LustreParser::RuleProvide);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(245);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LustreParser::T__28: {
        enterOuterAlt(_localctx, 1);
        setState(242);
        const_block();
        break;
      }

      case LustreParser::T__13: {
        enterOuterAlt(_localctx, 2);
        setState(243);
        type_block();
        break;
      }

      case LustreParser::T__36:
      case LustreParser::T__37: {
        enterOuterAlt(_localctx, 3);
        setState(244);
        user_op_provide();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Model_declContext ------------------------------------------------------------------

LustreParser::Model_declContext::Model_declContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LustreParser::Model_declContext::ID() {
  return getToken(LustreParser::ID, 0);
}

LustreParser::UsesContext* LustreParser::Model_declContext::uses() {
  return getRuleContext<LustreParser::UsesContext>(0);
}

LustreParser::User_op_provideContext* LustreParser::Model_declContext::user_op_provide() {
  return getRuleContext<LustreParser::User_op_provideContext>(0);
}

LustreParser::DeclsContext* LustreParser::Model_declContext::decls() {
  return getRuleContext<LustreParser::DeclsContext>(0);
}


size_t LustreParser::Model_declContext::getRuleIndex() const {
  return LustreParser::RuleModel_decl;
}

void LustreParser::Model_declContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModel_decl(this);
}

void LustreParser::Model_declContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModel_decl(this);
}


std::any LustreParser::Model_declContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitModel_decl(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Model_declContext* LustreParser::model_decl() {
  Model_declContext *_localctx = _tracker.createInstance<Model_declContext>(_ctx, getState());
  enterRule(_localctx, 18, LustreParser::RuleModel_decl);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(247);
    match(LustreParser::T__10);
    setState(248);
    match(LustreParser::ID);
    setState(249);
    uses();
    setState(250);
    match(LustreParser::T__11);
    setState(251);
    user_op_provide();
    setState(252);
    match(LustreParser::T__3);
    setState(253);
    decls();
    setState(254);
    match(LustreParser::T__4);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- User_op_provideContext ------------------------------------------------------------------

LustreParser::User_op_provideContext::User_op_provideContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LustreParser::Op_kindContext* LustreParser::User_op_provideContext::op_kind() {
  return getRuleContext<LustreParser::Op_kindContext>(0);
}

tree::TerminalNode* LustreParser::User_op_provideContext::ID() {
  return getToken(LustreParser::ID, 0);
}

std::vector<LustreParser::ParamsContext *> LustreParser::User_op_provideContext::params() {
  return getRuleContexts<LustreParser::ParamsContext>();
}

LustreParser::ParamsContext* LustreParser::User_op_provideContext::params(size_t i) {
  return getRuleContext<LustreParser::ParamsContext>(i);
}


size_t LustreParser::User_op_provideContext::getRuleIndex() const {
  return LustreParser::RuleUser_op_provide;
}

void LustreParser::User_op_provideContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUser_op_provide(this);
}

void LustreParser::User_op_provideContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUser_op_provide(this);
}


std::any LustreParser::User_op_provideContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitUser_op_provide(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::User_op_provideContext* LustreParser::user_op_provide() {
  User_op_provideContext *_localctx = _tracker.createInstance<User_op_provideContext>(_ctx, getState());
  enterRule(_localctx, 20, LustreParser::RuleUser_op_provide);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(256);
    op_kind();
    setState(257);
    match(LustreParser::ID);
    setState(258);
    params();
    setState(259);
    match(LustreParser::T__12);
    setState(260);
    params();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DeclsContext ------------------------------------------------------------------

LustreParser::DeclsContext::DeclsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::DeclsContext::getRuleIndex() const {
  return LustreParser::RuleDecls;
}

void LustreParser::DeclsContext::copyFrom(DeclsContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Decls_contract_nodeContext ------------------------------------------------------------------

LustreParser::External_contractContext* LustreParser::Decls_contract_nodeContext::external_contract() {
  return getRuleContext<LustreParser::External_contractContext>(0);
}

LustreParser::Decls_contract_nodeContext::Decls_contract_nodeContext(DeclsContext *ctx) { copyFrom(ctx); }

void LustreParser::Decls_contract_nodeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDecls_contract_node(this);
}
void LustreParser::Decls_contract_nodeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDecls_contract_node(this);
}

std::any LustreParser::Decls_contract_nodeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitDecls_contract_node(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Decls_typeContext ------------------------------------------------------------------

LustreParser::Type_blockContext* LustreParser::Decls_typeContext::type_block() {
  return getRuleContext<LustreParser::Type_blockContext>(0);
}

LustreParser::Decls_typeContext::Decls_typeContext(DeclsContext *ctx) { copyFrom(ctx); }

void LustreParser::Decls_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDecls_type(this);
}
void LustreParser::Decls_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDecls_type(this);
}

std::any LustreParser::Decls_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitDecls_type(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Decls_user_opContext ------------------------------------------------------------------

LustreParser::User_op_declContext* LustreParser::Decls_user_opContext::user_op_decl() {
  return getRuleContext<LustreParser::User_op_declContext>(0);
}

LustreParser::Decls_user_opContext::Decls_user_opContext(DeclsContext *ctx) { copyFrom(ctx); }

void LustreParser::Decls_user_opContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDecls_user_op(this);
}
void LustreParser::Decls_user_opContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDecls_user_op(this);
}

std::any LustreParser::Decls_user_opContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitDecls_user_op(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Decls_import_opContext ------------------------------------------------------------------

LustreParser::Import_op_declContext* LustreParser::Decls_import_opContext::import_op_decl() {
  return getRuleContext<LustreParser::Import_op_declContext>(0);
}

LustreParser::Decls_import_opContext::Decls_import_opContext(DeclsContext *ctx) { copyFrom(ctx); }

void LustreParser::Decls_import_opContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDecls_import_op(this);
}
void LustreParser::Decls_import_opContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDecls_import_op(this);
}

std::any LustreParser::Decls_import_opContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitDecls_import_op(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Decls_constContext ------------------------------------------------------------------

LustreParser::Const_blockContext* LustreParser::Decls_constContext::const_block() {
  return getRuleContext<LustreParser::Const_blockContext>(0);
}

LustreParser::Decls_constContext::Decls_constContext(DeclsContext *ctx) { copyFrom(ctx); }

void LustreParser::Decls_constContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDecls_const(this);
}
void LustreParser::Decls_constContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDecls_const(this);
}

std::any LustreParser::Decls_constContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitDecls_const(this);
  else
    return visitor->visitChildren(this);
}
LustreParser::DeclsContext* LustreParser::decls() {
  DeclsContext *_localctx = _tracker.createInstance<DeclsContext>(_ctx, getState());
  enterRule(_localctx, 22, LustreParser::RuleDecls);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(267);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 8, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<LustreParser::Decls_typeContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(262);
      type_block();
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<LustreParser::Decls_constContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(263);
      const_block();
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<LustreParser::Decls_import_opContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(264);
      import_op_decl();
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<LustreParser::Decls_user_opContext>(_localctx);
      enterOuterAlt(_localctx, 4);
      setState(265);
      user_op_decl();
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<LustreParser::Decls_contract_nodeContext>(_localctx);
      enterOuterAlt(_localctx, 5);
      setState(266);
      external_contract();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Type_blockContext ------------------------------------------------------------------

LustreParser::Type_blockContext::Type_blockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<LustreParser::Type_declContext *> LustreParser::Type_blockContext::type_decl() {
  return getRuleContexts<LustreParser::Type_declContext>();
}

LustreParser::Type_declContext* LustreParser::Type_blockContext::type_decl(size_t i) {
  return getRuleContext<LustreParser::Type_declContext>(i);
}


size_t LustreParser::Type_blockContext::getRuleIndex() const {
  return LustreParser::RuleType_block;
}

void LustreParser::Type_blockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType_block(this);
}

void LustreParser::Type_blockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType_block(this);
}


std::any LustreParser::Type_blockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitType_block(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Type_blockContext* LustreParser::type_block() {
  Type_blockContext *_localctx = _tracker.createInstance<Type_blockContext>(_ctx, getState());
  enterRule(_localctx, 24, LustreParser::RuleType_block);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(269);
    match(LustreParser::T__13);
    setState(275);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == LustreParser::ID) {
      setState(270);
      type_decl();
      setState(271);
      match(LustreParser::T__1);
      setState(277);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Type_declContext ------------------------------------------------------------------

LustreParser::Type_declContext::Type_declContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LustreParser::Type_declContext::ID() {
  return getToken(LustreParser::ID, 0);
}

LustreParser::Type_defContext* LustreParser::Type_declContext::type_def() {
  return getRuleContext<LustreParser::Type_defContext>(0);
}


size_t LustreParser::Type_declContext::getRuleIndex() const {
  return LustreParser::RuleType_decl;
}

void LustreParser::Type_declContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType_decl(this);
}

void LustreParser::Type_declContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType_decl(this);
}


std::any LustreParser::Type_declContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitType_decl(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Type_declContext* LustreParser::type_decl() {
  Type_declContext *_localctx = _tracker.createInstance<Type_declContext>(_ctx, getState());
  enterRule(_localctx, 26, LustreParser::RuleType_decl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(278);
    match(LustreParser::ID);
    setState(281);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == LustreParser::T__7) {
      setState(279);
      match(LustreParser::T__7);
      setState(280);
      type_def();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Type_defContext ------------------------------------------------------------------

LustreParser::Type_defContext::Type_defContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::Type_defContext::getRuleIndex() const {
  return LustreParser::RuleType_def;
}

void LustreParser::Type_defContext::copyFrom(Type_defContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Type_def_typeContext ------------------------------------------------------------------

LustreParser::TypeContext* LustreParser::Type_def_typeContext::type() {
  return getRuleContext<LustreParser::TypeContext>(0);
}

LustreParser::Type_def_typeContext::Type_def_typeContext(Type_defContext *ctx) { copyFrom(ctx); }

void LustreParser::Type_def_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType_def_type(this);
}
void LustreParser::Type_def_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType_def_type(this);
}

std::any LustreParser::Type_def_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitType_def_type(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Type_def_enumContext ------------------------------------------------------------------

std::vector<tree::TerminalNode *> LustreParser::Type_def_enumContext::ID() {
  return getTokens(LustreParser::ID);
}

tree::TerminalNode* LustreParser::Type_def_enumContext::ID(size_t i) {
  return getToken(LustreParser::ID, i);
}

LustreParser::Type_def_enumContext::Type_def_enumContext(Type_defContext *ctx) { copyFrom(ctx); }

void LustreParser::Type_def_enumContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType_def_enum(this);
}
void LustreParser::Type_def_enumContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType_def_enum(this);
}

std::any LustreParser::Type_def_enumContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitType_def_enum(this);
  else
    return visitor->visitChildren(this);
}
LustreParser::Type_defContext* LustreParser::type_def() {
  Type_defContext *_localctx = _tracker.createInstance<Type_defContext>(_ctx, getState());
  enterRule(_localctx, 28, LustreParser::RuleType_def);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(295);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LustreParser::T__15:
      case LustreParser::T__17:
      case LustreParser::T__18:
      case LustreParser::T__19:
      case LustreParser::T__20:
      case LustreParser::T__21:
      case LustreParser::T__22:
      case LustreParser::T__23:
      case LustreParser::T__24:
      case LustreParser::T__25:
      case LustreParser::ID: {
        _localctx = _tracker.createInstance<LustreParser::Type_def_typeContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(283);
        type(0);
        break;
      }

      case LustreParser::T__14: {
        _localctx = _tracker.createInstance<LustreParser::Type_def_enumContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(284);
        match(LustreParser::T__14);
        setState(285);
        match(LustreParser::T__15);
        setState(286);
        match(LustreParser::ID);
        setState(291);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == LustreParser::T__6) {
          setState(287);
          match(LustreParser::T__6);
          setState(288);
          match(LustreParser::ID);
          setState(293);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(294);
        match(LustreParser::T__16);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeContext ------------------------------------------------------------------

LustreParser::TypeContext::TypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::TypeContext::getRuleIndex() const {
  return LustreParser::RuleType;
}

void LustreParser::TypeContext::copyFrom(TypeContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Type_realContext ------------------------------------------------------------------

LustreParser::Type_realContext::Type_realContext(TypeContext *ctx) { copyFrom(ctx); }

void LustreParser::Type_realContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType_real(this);
}
void LustreParser::Type_realContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType_real(this);
}

std::any LustreParser::Type_realContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitType_real(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Type_floatContext ------------------------------------------------------------------

LustreParser::Type_floatContext::Type_floatContext(TypeContext *ctx) { copyFrom(ctx); }

void LustreParser::Type_floatContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType_float(this);
}
void LustreParser::Type_floatContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType_float(this);
}

std::any LustreParser::Type_floatContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitType_float(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Type_boolContext ------------------------------------------------------------------

LustreParser::Type_boolContext::Type_boolContext(TypeContext *ctx) { copyFrom(ctx); }

void LustreParser::Type_boolContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType_bool(this);
}
void LustreParser::Type_boolContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType_bool(this);
}

std::any LustreParser::Type_boolContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitType_bool(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Type_arrayContext ------------------------------------------------------------------

LustreParser::TypeContext* LustreParser::Type_arrayContext::type() {
  return getRuleContext<LustreParser::TypeContext>(0);
}

LustreParser::Const_exprContext* LustreParser::Type_arrayContext::const_expr() {
  return getRuleContext<LustreParser::Const_exprContext>(0);
}

LustreParser::Type_arrayContext::Type_arrayContext(TypeContext *ctx) { copyFrom(ctx); }

void LustreParser::Type_arrayContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType_array(this);
}
void LustreParser::Type_arrayContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType_array(this);
}

std::any LustreParser::Type_arrayContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitType_array(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Type_charContext ------------------------------------------------------------------

LustreParser::Type_charContext::Type_charContext(TypeContext *ctx) { copyFrom(ctx); }

void LustreParser::Type_charContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType_char(this);
}
void LustreParser::Type_charContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType_char(this);
}

std::any LustreParser::Type_charContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitType_char(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Type_idContext ------------------------------------------------------------------

tree::TerminalNode* LustreParser::Type_idContext::ID() {
  return getToken(LustreParser::ID, 0);
}

LustreParser::Type_idContext::Type_idContext(TypeContext *ctx) { copyFrom(ctx); }

void LustreParser::Type_idContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType_id(this);
}
void LustreParser::Type_idContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType_id(this);
}

std::any LustreParser::Type_idContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitType_id(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Type_ushortContext ------------------------------------------------------------------

LustreParser::Type_ushortContext::Type_ushortContext(TypeContext *ctx) { copyFrom(ctx); }

void LustreParser::Type_ushortContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType_ushort(this);
}
void LustreParser::Type_ushortContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType_ushort(this);
}

std::any LustreParser::Type_ushortContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitType_ushort(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Type_uintContext ------------------------------------------------------------------

LustreParser::Type_uintContext::Type_uintContext(TypeContext *ctx) { copyFrom(ctx); }

void LustreParser::Type_uintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType_uint(this);
}
void LustreParser::Type_uintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType_uint(this);
}

std::any LustreParser::Type_uintContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitType_uint(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Type_shortContext ------------------------------------------------------------------

LustreParser::Type_shortContext::Type_shortContext(TypeContext *ctx) { copyFrom(ctx); }

void LustreParser::Type_shortContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType_short(this);
}
void LustreParser::Type_shortContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType_short(this);
}

std::any LustreParser::Type_shortContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitType_short(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Type_structContext ------------------------------------------------------------------

std::vector<LustreParser::Field_declContext *> LustreParser::Type_structContext::field_decl() {
  return getRuleContexts<LustreParser::Field_declContext>();
}

LustreParser::Field_declContext* LustreParser::Type_structContext::field_decl(size_t i) {
  return getRuleContext<LustreParser::Field_declContext>(i);
}

LustreParser::Type_structContext::Type_structContext(TypeContext *ctx) { copyFrom(ctx); }

void LustreParser::Type_structContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType_struct(this);
}
void LustreParser::Type_structContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType_struct(this);
}

std::any LustreParser::Type_structContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitType_struct(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Type_intContext ------------------------------------------------------------------

LustreParser::Type_intContext::Type_intContext(TypeContext *ctx) { copyFrom(ctx); }

void LustreParser::Type_intContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType_int(this);
}
void LustreParser::Type_intContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType_int(this);
}

std::any LustreParser::Type_intContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitType_int(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::TypeContext* LustreParser::type() {
   return type(0);
}

LustreParser::TypeContext* LustreParser::type(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  LustreParser::TypeContext *_localctx = _tracker.createInstance<TypeContext>(_ctx, parentState);
  LustreParser::TypeContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 30;
  enterRecursionRule(_localctx, 30, LustreParser::RuleType, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(321);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LustreParser::T__17: {
        _localctx = _tracker.createInstance<Type_intContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;

        setState(298);
        match(LustreParser::T__17);
        break;
      }

      case LustreParser::T__18: {
        _localctx = _tracker.createInstance<Type_boolContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        setState(299);
        match(LustreParser::T__18);
        break;
      }

      case LustreParser::T__19: {
        _localctx = _tracker.createInstance<Type_charContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        setState(300);
        match(LustreParser::T__19);
        break;
      }

      case LustreParser::T__20: {
        _localctx = _tracker.createInstance<Type_shortContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        setState(301);
        match(LustreParser::T__20);
        break;
      }

      case LustreParser::T__21: {
        _localctx = _tracker.createInstance<Type_ushortContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        setState(302);
        match(LustreParser::T__21);
        break;
      }

      case LustreParser::T__22: {
        _localctx = _tracker.createInstance<Type_uintContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        setState(303);
        match(LustreParser::T__22);
        break;
      }

      case LustreParser::T__23: {
        _localctx = _tracker.createInstance<Type_floatContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        setState(304);
        match(LustreParser::T__23);
        break;
      }

      case LustreParser::T__24: {
        _localctx = _tracker.createInstance<Type_realContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        setState(305);
        match(LustreParser::T__24);
        break;
      }

      case LustreParser::ID: {
        _localctx = _tracker.createInstance<Type_idContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        setState(306);
        match(LustreParser::ID);
        break;
      }

      case LustreParser::T__15:
      case LustreParser::T__25: {
        _localctx = _tracker.createInstance<Type_structContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        setState(308);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == LustreParser::T__25) {
          setState(307);
          match(LustreParser::T__25);
        }
        setState(310);
        match(LustreParser::T__15);
        setState(311);
        field_decl();
        setState(316);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == LustreParser::T__1

        || _la == LustreParser::T__6) {
          setState(312);
          _la = _input->LA(1);
          if (!(_la == LustreParser::T__1

          || _la == LustreParser::T__6)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(313);
          field_decl();
          setState(318);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(319);
        match(LustreParser::T__16);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    _ctx->stop = _input->LT(-1);
    setState(328);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 16, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        auto newContext = _tracker.createInstance<Type_arrayContext>(_tracker.createInstance<TypeContext>(parentContext, parentState));
        _localctx = newContext;
        pushNewRecursionContext(newContext, startState, RuleType);
        setState(323);

        if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
        setState(324);
        match(LustreParser::T__26);
        setState(325);
        const_expr(0); 
      }
      setState(330);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 16, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Field_declContext ------------------------------------------------------------------

LustreParser::Field_declContext::Field_declContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LustreParser::Field_declContext::ID() {
  return getToken(LustreParser::ID, 0);
}

LustreParser::TypeContext* LustreParser::Field_declContext::type() {
  return getRuleContext<LustreParser::TypeContext>(0);
}


size_t LustreParser::Field_declContext::getRuleIndex() const {
  return LustreParser::RuleField_decl;
}

void LustreParser::Field_declContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterField_decl(this);
}

void LustreParser::Field_declContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitField_decl(this);
}


std::any LustreParser::Field_declContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitField_decl(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Field_declContext* LustreParser::field_decl() {
  Field_declContext *_localctx = _tracker.createInstance<Field_declContext>(_ctx, getState());
  enterRule(_localctx, 32, LustreParser::RuleField_decl);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(331);
    match(LustreParser::ID);
    setState(332);
    match(LustreParser::T__27);
    setState(333);
    type(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Const_blockContext ------------------------------------------------------------------

LustreParser::Const_blockContext::Const_blockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<LustreParser::Const_declContext *> LustreParser::Const_blockContext::const_decl() {
  return getRuleContexts<LustreParser::Const_declContext>();
}

LustreParser::Const_declContext* LustreParser::Const_blockContext::const_decl(size_t i) {
  return getRuleContext<LustreParser::Const_declContext>(i);
}


size_t LustreParser::Const_blockContext::getRuleIndex() const {
  return LustreParser::RuleConst_block;
}

void LustreParser::Const_blockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConst_block(this);
}

void LustreParser::Const_blockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConst_block(this);
}


std::any LustreParser::Const_blockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitConst_block(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Const_blockContext* LustreParser::const_block() {
  Const_blockContext *_localctx = _tracker.createInstance<Const_blockContext>(_ctx, getState());
  enterRule(_localctx, 34, LustreParser::RuleConst_block);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(335);
    match(LustreParser::T__28);
    setState(341);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == LustreParser::ID) {
      setState(336);
      const_decl();
      setState(337);
      match(LustreParser::T__1);
      setState(343);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Const_declContext ------------------------------------------------------------------

LustreParser::Const_declContext::Const_declContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LustreParser::Const_declContext::ID() {
  return getToken(LustreParser::ID, 0);
}

LustreParser::TypeContext* LustreParser::Const_declContext::type() {
  return getRuleContext<LustreParser::TypeContext>(0);
}

LustreParser::Const_exprContext* LustreParser::Const_declContext::const_expr() {
  return getRuleContext<LustreParser::Const_exprContext>(0);
}


size_t LustreParser::Const_declContext::getRuleIndex() const {
  return LustreParser::RuleConst_decl;
}

void LustreParser::Const_declContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConst_decl(this);
}

void LustreParser::Const_declContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConst_decl(this);
}


std::any LustreParser::Const_declContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitConst_decl(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Const_declContext* LustreParser::const_decl() {
  Const_declContext *_localctx = _tracker.createInstance<Const_declContext>(_ctx, getState());
  enterRule(_localctx, 36, LustreParser::RuleConst_decl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(344);
    match(LustreParser::ID);
    setState(347);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == LustreParser::T__27) {
      setState(345);
      match(LustreParser::T__27);
      setState(346);
      type(0);
    }
    setState(351);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == LustreParser::T__7) {
      setState(349);
      match(LustreParser::T__7);
      setState(350);
      const_expr(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Const_exprContext ------------------------------------------------------------------

LustreParser::Const_exprContext::Const_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::Const_exprContext::getRuleIndex() const {
  return LustreParser::RuleConst_expr;
}

void LustreParser::Const_exprContext::copyFrom(Const_exprContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Const_idContext ------------------------------------------------------------------

tree::TerminalNode* LustreParser::Const_idContext::ID() {
  return getToken(LustreParser::ID, 0);
}

LustreParser::Const_idContext::Const_idContext(Const_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Const_idContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConst_id(this);
}
void LustreParser::Const_idContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConst_id(this);
}

std::any LustreParser::Const_idContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitConst_id(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Const_parenContext ------------------------------------------------------------------

LustreParser::Const_exprContext* LustreParser::Const_parenContext::const_expr() {
  return getRuleContext<LustreParser::Const_exprContext>(0);
}

LustreParser::Const_parenContext::Const_parenContext(Const_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Const_parenContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConst_paren(this);
}
void LustreParser::Const_parenContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConst_paren(this);
}

std::any LustreParser::Const_parenContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitConst_paren(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Const_bin_relationContext ------------------------------------------------------------------

std::vector<LustreParser::Const_exprContext *> LustreParser::Const_bin_relationContext::const_expr() {
  return getRuleContexts<LustreParser::Const_exprContext>();
}

LustreParser::Const_exprContext* LustreParser::Const_bin_relationContext::const_expr(size_t i) {
  return getRuleContext<LustreParser::Const_exprContext>(i);
}

LustreParser::Bin_relation_opContext* LustreParser::Const_bin_relationContext::bin_relation_op() {
  return getRuleContext<LustreParser::Bin_relation_opContext>(0);
}

LustreParser::Const_bin_relationContext::Const_bin_relationContext(Const_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Const_bin_relationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConst_bin_relation(this);
}
void LustreParser::Const_bin_relationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConst_bin_relation(this);
}

std::any LustreParser::Const_bin_relationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitConst_bin_relation(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Const_atomContext ------------------------------------------------------------------

LustreParser::AtomContext* LustreParser::Const_atomContext::atom() {
  return getRuleContext<LustreParser::AtomContext>(0);
}

LustreParser::Const_atomContext::Const_atomContext(Const_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Const_atomContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConst_atom(this);
}
void LustreParser::Const_atomContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConst_atom(this);
}

std::any LustreParser::Const_atomContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitConst_atom(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Const_unary_arithContext ------------------------------------------------------------------

LustreParser::Unary_arith_opContext* LustreParser::Const_unary_arithContext::unary_arith_op() {
  return getRuleContext<LustreParser::Unary_arith_opContext>(0);
}

LustreParser::Const_exprContext* LustreParser::Const_unary_arithContext::const_expr() {
  return getRuleContext<LustreParser::Const_exprContext>(0);
}

LustreParser::Const_unary_arithContext::Const_unary_arithContext(Const_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Const_unary_arithContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConst_unary_arith(this);
}
void LustreParser::Const_unary_arithContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConst_unary_arith(this);
}

std::any LustreParser::Const_unary_arithContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitConst_unary_arith(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Const_structContext ------------------------------------------------------------------

std::vector<LustreParser::Const_label_exprContext *> LustreParser::Const_structContext::const_label_expr() {
  return getRuleContexts<LustreParser::Const_label_exprContext>();
}

LustreParser::Const_label_exprContext* LustreParser::Const_structContext::const_label_expr(size_t i) {
  return getRuleContext<LustreParser::Const_label_exprContext>(i);
}

LustreParser::Const_structContext::Const_structContext(Const_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Const_structContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConst_struct(this);
}
void LustreParser::Const_structContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConst_struct(this);
}

std::any LustreParser::Const_structContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitConst_struct(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Const_bin_arithContext ------------------------------------------------------------------

std::vector<LustreParser::Const_exprContext *> LustreParser::Const_bin_arithContext::const_expr() {
  return getRuleContexts<LustreParser::Const_exprContext>();
}

LustreParser::Const_exprContext* LustreParser::Const_bin_arithContext::const_expr(size_t i) {
  return getRuleContext<LustreParser::Const_exprContext>(i);
}

LustreParser::Bin_arith_opContext* LustreParser::Const_bin_arithContext::bin_arith_op() {
  return getRuleContext<LustreParser::Bin_arith_opContext>(0);
}

LustreParser::Const_bin_arithContext::Const_bin_arithContext(Const_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Const_bin_arithContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConst_bin_arith(this);
}
void LustreParser::Const_bin_arithContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConst_bin_arith(this);
}

std::any LustreParser::Const_bin_arithContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitConst_bin_arith(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Const_bin_boolContext ------------------------------------------------------------------

std::vector<LustreParser::Const_exprContext *> LustreParser::Const_bin_boolContext::const_expr() {
  return getRuleContexts<LustreParser::Const_exprContext>();
}

LustreParser::Const_exprContext* LustreParser::Const_bin_boolContext::const_expr(size_t i) {
  return getRuleContext<LustreParser::Const_exprContext>(i);
}

LustreParser::Bin_bool_opContext* LustreParser::Const_bin_boolContext::bin_bool_op() {
  return getRuleContext<LustreParser::Bin_bool_opContext>(0);
}

LustreParser::Const_bin_boolContext::Const_bin_boolContext(Const_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Const_bin_boolContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConst_bin_bool(this);
}
void LustreParser::Const_bin_boolContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConst_bin_bool(this);
}

std::any LustreParser::Const_bin_boolContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitConst_bin_bool(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Const_arrayContext ------------------------------------------------------------------

LustreParser::Const_listContext* LustreParser::Const_arrayContext::const_list() {
  return getRuleContext<LustreParser::Const_listContext>(0);
}

LustreParser::Const_arrayContext::Const_arrayContext(Const_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Const_arrayContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConst_array(this);
}
void LustreParser::Const_arrayContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConst_array(this);
}

std::any LustreParser::Const_arrayContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitConst_array(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Const_exprContext* LustreParser::const_expr() {
   return const_expr(0);
}

LustreParser::Const_exprContext* LustreParser::const_expr(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  LustreParser::Const_exprContext *_localctx = _tracker.createInstance<Const_exprContext>(_ctx, parentState);
  LustreParser::Const_exprContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 38;
  enterRecursionRule(_localctx, 38, LustreParser::RuleConst_expr, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(378);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LustreParser::ID: {
        _localctx = _tracker.createInstance<Const_idContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;

        setState(354);
        match(LustreParser::ID);
        break;
      }

      case LustreParser::BOOL:
      case LustreParser::INTEGER:
      case LustreParser::UINT:
      case LustreParser::REAL:
      case LustreParser::CHAR:
      case LustreParser::FLOAT:
      case LustreParser::USHORT:
      case LustreParser::SHORT: {
        _localctx = _tracker.createInstance<Const_atomContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        setState(355);
        atom();
        break;
      }

      case LustreParser::T__34:
      case LustreParser::T__78:
      case LustreParser::T__115: {
        _localctx = _tracker.createInstance<Const_unary_arithContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        setState(356);
        unary_arith_op();
        setState(357);
        const_expr(7);
        break;
      }

      case LustreParser::T__29: {
        _localctx = _tracker.createInstance<Const_parenContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        setState(359);
        match(LustreParser::T__29);
        setState(360);
        const_expr(0);
        setState(361);
        match(LustreParser::T__30);
        break;
      }

      case LustreParser::T__31: {
        _localctx = _tracker.createInstance<Const_arrayContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        setState(363);
        match(LustreParser::T__31);
        setState(364);
        const_list();
        setState(365);
        match(LustreParser::T__32);
        break;
      }

      case LustreParser::T__15: {
        _localctx = _tracker.createInstance<Const_structContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        setState(367);
        match(LustreParser::T__15);
        setState(368);
        const_label_expr();
        setState(373);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == LustreParser::T__6) {
          setState(369);
          match(LustreParser::T__6);
          setState(370);
          const_label_expr();
          setState(375);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(376);
        match(LustreParser::T__16);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    _ctx->stop = _input->LT(-1);
    setState(394);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 23, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(392);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 22, _ctx)) {
        case 1: {
          auto newContext = _tracker.createInstance<Const_bin_arithContext>(_tracker.createInstance<Const_exprContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleConst_expr);
          setState(380);

          if (!(precpred(_ctx, 5))) throw FailedPredicateException(this, "precpred(_ctx, 5)");
          setState(381);
          bin_arith_op();
          setState(382);
          const_expr(6);
          break;
        }

        case 2: {
          auto newContext = _tracker.createInstance<Const_bin_boolContext>(_tracker.createInstance<Const_exprContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleConst_expr);
          setState(384);

          if (!(precpred(_ctx, 4))) throw FailedPredicateException(this, "precpred(_ctx, 4)");
          setState(385);
          bin_bool_op();
          setState(386);
          const_expr(5);
          break;
        }

        case 3: {
          auto newContext = _tracker.createInstance<Const_bin_relationContext>(_tracker.createInstance<Const_exprContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleConst_expr);
          setState(388);

          if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
          setState(389);
          bin_relation_op();
          setState(390);
          const_expr(4);
          break;
        }

        default:
          break;
        } 
      }
      setState(396);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 23, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Const_listContext ------------------------------------------------------------------

LustreParser::Const_listContext::Const_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<LustreParser::Const_exprContext *> LustreParser::Const_listContext::const_expr() {
  return getRuleContexts<LustreParser::Const_exprContext>();
}

LustreParser::Const_exprContext* LustreParser::Const_listContext::const_expr(size_t i) {
  return getRuleContext<LustreParser::Const_exprContext>(i);
}


size_t LustreParser::Const_listContext::getRuleIndex() const {
  return LustreParser::RuleConst_list;
}

void LustreParser::Const_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConst_list(this);
}

void LustreParser::Const_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConst_list(this);
}


std::any LustreParser::Const_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitConst_list(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Const_listContext* LustreParser::const_list() {
  Const_listContext *_localctx = _tracker.createInstance<Const_listContext>(_ctx, getState());
  enterRule(_localctx, 40, LustreParser::RuleConst_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(405);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 39728513024) != 0) || ((((_la - 79) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 79)) & 9205357775784247297) != 0)) {
      setState(397);
      const_expr(0);
      setState(402);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == LustreParser::T__6) {
        setState(398);
        match(LustreParser::T__6);
        setState(399);
        const_expr(0);
        setState(404);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Const_label_exprContext ------------------------------------------------------------------

LustreParser::Const_label_exprContext::Const_label_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LustreParser::Const_label_exprContext::ID() {
  return getToken(LustreParser::ID, 0);
}

LustreParser::Const_exprContext* LustreParser::Const_label_exprContext::const_expr() {
  return getRuleContext<LustreParser::Const_exprContext>(0);
}


size_t LustreParser::Const_label_exprContext::getRuleIndex() const {
  return LustreParser::RuleConst_label_expr;
}

void LustreParser::Const_label_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConst_label_expr(this);
}

void LustreParser::Const_label_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConst_label_expr(this);
}


std::any LustreParser::Const_label_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitConst_label_expr(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Const_label_exprContext* LustreParser::const_label_expr() {
  Const_label_exprContext *_localctx = _tracker.createInstance<Const_label_exprContext>(_ctx, getState());
  enterRule(_localctx, 42, LustreParser::RuleConst_label_expr);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(407);
    match(LustreParser::ID);
    setState(408);
    match(LustreParser::T__27);
    setState(409);
    const_expr(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Var_declsContext ------------------------------------------------------------------

LustreParser::Var_declsContext::Var_declsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> LustreParser::Var_declsContext::ID() {
  return getTokens(LustreParser::ID);
}

tree::TerminalNode* LustreParser::Var_declsContext::ID(size_t i) {
  return getToken(LustreParser::ID, i);
}

LustreParser::TypeContext* LustreParser::Var_declsContext::type() {
  return getRuleContext<LustreParser::TypeContext>(0);
}

LustreParser::When_declContext* LustreParser::Var_declsContext::when_decl() {
  return getRuleContext<LustreParser::When_declContext>(0);
}

LustreParser::Last_declContext* LustreParser::Var_declsContext::last_decl() {
  return getRuleContext<LustreParser::Last_declContext>(0);
}


size_t LustreParser::Var_declsContext::getRuleIndex() const {
  return LustreParser::RuleVar_decls;
}

void LustreParser::Var_declsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVar_decls(this);
}

void LustreParser::Var_declsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVar_decls(this);
}


std::any LustreParser::Var_declsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitVar_decls(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Var_declsContext* LustreParser::var_decls() {
  Var_declsContext *_localctx = _tracker.createInstance<Var_declsContext>(_ctx, getState());
  enterRule(_localctx, 44, LustreParser::RuleVar_decls);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(411);
    match(LustreParser::ID);
    setState(416);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == LustreParser::T__6) {
      setState(412);
      match(LustreParser::T__6);
      setState(413);
      match(LustreParser::ID);
      setState(418);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(419);
    match(LustreParser::T__27);
    setState(420);
    type(0);
    setState(422);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == LustreParser::T__33) {
      setState(421);
      when_decl();
    }
    setState(425);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == LustreParser::T__35) {
      setState(424);
      last_decl();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- When_declContext ------------------------------------------------------------------

LustreParser::When_declContext::When_declContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LustreParser::Clock_exprContext* LustreParser::When_declContext::clock_expr() {
  return getRuleContext<LustreParser::Clock_exprContext>(0);
}


size_t LustreParser::When_declContext::getRuleIndex() const {
  return LustreParser::RuleWhen_decl;
}

void LustreParser::When_declContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWhen_decl(this);
}

void LustreParser::When_declContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWhen_decl(this);
}


std::any LustreParser::When_declContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitWhen_decl(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::When_declContext* LustreParser::when_decl() {
  When_declContext *_localctx = _tracker.createInstance<When_declContext>(_ctx, getState());
  enterRule(_localctx, 46, LustreParser::RuleWhen_decl);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(427);
    match(LustreParser::T__33);
    setState(428);
    clock_expr();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Clock_exprContext ------------------------------------------------------------------

LustreParser::Clock_exprContext::Clock_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::Clock_exprContext::getRuleIndex() const {
  return LustreParser::RuleClock_expr;
}

void LustreParser::Clock_exprContext::copyFrom(Clock_exprContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Clock_idContext ------------------------------------------------------------------

tree::TerminalNode* LustreParser::Clock_idContext::ID() {
  return getToken(LustreParser::ID, 0);
}

LustreParser::Clock_idContext::Clock_idContext(Clock_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Clock_idContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClock_id(this);
}
void LustreParser::Clock_idContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClock_id(this);
}

std::any LustreParser::Clock_idContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitClock_id(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Clock_notContext ------------------------------------------------------------------

tree::TerminalNode* LustreParser::Clock_notContext::ID() {
  return getToken(LustreParser::ID, 0);
}

LustreParser::Clock_notContext::Clock_notContext(Clock_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Clock_notContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClock_not(this);
}
void LustreParser::Clock_notContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClock_not(this);
}

std::any LustreParser::Clock_notContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitClock_not(this);
  else
    return visitor->visitChildren(this);
}
LustreParser::Clock_exprContext* LustreParser::clock_expr() {
  Clock_exprContext *_localctx = _tracker.createInstance<Clock_exprContext>(_ctx, getState());
  enterRule(_localctx, 48, LustreParser::RuleClock_expr);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(439);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LustreParser::ID: {
        _localctx = _tracker.createInstance<LustreParser::Clock_idContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(430);
        match(LustreParser::ID);
        break;
      }

      case LustreParser::T__34: {
        _localctx = _tracker.createInstance<LustreParser::Clock_notContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(431);
        match(LustreParser::T__34);
        setState(433);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == LustreParser::T__29) {
          setState(432);
          match(LustreParser::T__29);
        }
        setState(435);
        match(LustreParser::ID);
        setState(437);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 30, _ctx)) {
        case 1: {
          setState(436);
          match(LustreParser::T__30);
          break;
        }

        default:
          break;
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Last_declContext ------------------------------------------------------------------

LustreParser::Last_declContext::Last_declContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LustreParser::Const_exprContext* LustreParser::Last_declContext::const_expr() {
  return getRuleContext<LustreParser::Const_exprContext>(0);
}


size_t LustreParser::Last_declContext::getRuleIndex() const {
  return LustreParser::RuleLast_decl;
}

void LustreParser::Last_declContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLast_decl(this);
}

void LustreParser::Last_declContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLast_decl(this);
}


std::any LustreParser::Last_declContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitLast_decl(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Last_declContext* LustreParser::last_decl() {
  Last_declContext *_localctx = _tracker.createInstance<Last_declContext>(_ctx, getState());
  enterRule(_localctx, 50, LustreParser::RuleLast_decl);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(441);
    match(LustreParser::T__35);
    setState(442);
    match(LustreParser::T__7);
    setState(443);
    const_expr(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- User_op_declContext ------------------------------------------------------------------

LustreParser::User_op_declContext::User_op_declContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LustreParser::Op_kindContext* LustreParser::User_op_declContext::op_kind() {
  return getRuleContext<LustreParser::Op_kindContext>(0);
}

tree::TerminalNode* LustreParser::User_op_declContext::ID() {
  return getToken(LustreParser::ID, 0);
}

std::vector<LustreParser::ParamsContext *> LustreParser::User_op_declContext::params() {
  return getRuleContexts<LustreParser::ParamsContext>();
}

LustreParser::ParamsContext* LustreParser::User_op_declContext::params(size_t i) {
  return getRuleContext<LustreParser::ParamsContext>(i);
}

LustreParser::Op_bodyContext* LustreParser::User_op_declContext::op_body() {
  return getRuleContext<LustreParser::Op_bodyContext>(0);
}


size_t LustreParser::User_op_declContext::getRuleIndex() const {
  return LustreParser::RuleUser_op_decl;
}

void LustreParser::User_op_declContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUser_op_decl(this);
}

void LustreParser::User_op_declContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUser_op_decl(this);
}


std::any LustreParser::User_op_declContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitUser_op_decl(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::User_op_declContext* LustreParser::user_op_decl() {
  User_op_declContext *_localctx = _tracker.createInstance<User_op_declContext>(_ctx, getState());
  enterRule(_localctx, 52, LustreParser::RuleUser_op_decl);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(445);
    op_kind();
    setState(446);
    match(LustreParser::ID);
    setState(447);
    params();
    setState(448);
    match(LustreParser::T__12);
    setState(449);
    params();
    setState(451);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 32, _ctx)) {
    case 1: {
      setState(450);
      match(LustreParser::T__1);
      break;
    }

    default:
      break;
    }
    setState(453);
    op_body();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_kindContext ------------------------------------------------------------------

LustreParser::Op_kindContext::Op_kindContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::Op_kindContext::getRuleIndex() const {
  return LustreParser::RuleOp_kind;
}

void LustreParser::Op_kindContext::copyFrom(Op_kindContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Op_kind_nodeContext ------------------------------------------------------------------

LustreParser::Op_kind_nodeContext::Op_kind_nodeContext(Op_kindContext *ctx) { copyFrom(ctx); }

void LustreParser::Op_kind_nodeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_kind_node(this);
}
void LustreParser::Op_kind_nodeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_kind_node(this);
}

std::any LustreParser::Op_kind_nodeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitOp_kind_node(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Op_kind_funtionContext ------------------------------------------------------------------

LustreParser::Op_kind_funtionContext::Op_kind_funtionContext(Op_kindContext *ctx) { copyFrom(ctx); }

void LustreParser::Op_kind_funtionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_kind_funtion(this);
}
void LustreParser::Op_kind_funtionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_kind_funtion(this);
}

std::any LustreParser::Op_kind_funtionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitOp_kind_funtion(this);
  else
    return visitor->visitChildren(this);
}
LustreParser::Op_kindContext* LustreParser::op_kind() {
  Op_kindContext *_localctx = _tracker.createInstance<Op_kindContext>(_ctx, getState());
  enterRule(_localctx, 54, LustreParser::RuleOp_kind);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(457);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LustreParser::T__36: {
        _localctx = _tracker.createInstance<LustreParser::Op_kind_funtionContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(455);
        match(LustreParser::T__36);
        break;
      }

      case LustreParser::T__37: {
        _localctx = _tracker.createInstance<LustreParser::Op_kind_nodeContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(456);
        match(LustreParser::T__37);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ParamsContext ------------------------------------------------------------------

LustreParser::ParamsContext::ParamsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<LustreParser::Var_declsContext *> LustreParser::ParamsContext::var_decls() {
  return getRuleContexts<LustreParser::Var_declsContext>();
}

LustreParser::Var_declsContext* LustreParser::ParamsContext::var_decls(size_t i) {
  return getRuleContext<LustreParser::Var_declsContext>(i);
}


size_t LustreParser::ParamsContext::getRuleIndex() const {
  return LustreParser::RuleParams;
}

void LustreParser::ParamsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParams(this);
}

void LustreParser::ParamsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParams(this);
}


std::any LustreParser::ParamsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitParams(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::ParamsContext* LustreParser::params() {
  ParamsContext *_localctx = _tracker.createInstance<ParamsContext>(_ctx, getState());
  enterRule(_localctx, 56, LustreParser::RuleParams);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(459);
    match(LustreParser::T__29);
    setState(468);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == LustreParser::ID) {
      setState(460);
      var_decls();
      setState(465);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 34, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(461);
          match(LustreParser::T__1);
          setState(462);
          var_decls(); 
        }
        setState(467);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 34, _ctx);
      }
    }
    setState(471);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == LustreParser::T__1) {
      setState(470);
      match(LustreParser::T__1);
    }
    setState(473);
    match(LustreParser::T__30);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_bodyContext ------------------------------------------------------------------

LustreParser::Op_bodyContext::Op_bodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::Op_bodyContext::getRuleIndex() const {
  return LustreParser::RuleOp_body;
}

void LustreParser::Op_bodyContext::copyFrom(Op_bodyContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Op_body_nullContext ------------------------------------------------------------------

LustreParser::Op_body_nullContext::Op_body_nullContext(Op_bodyContext *ctx) { copyFrom(ctx); }

void LustreParser::Op_body_nullContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_body_null(this);
}
void LustreParser::Op_body_nullContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_body_null(this);
}

std::any LustreParser::Op_body_nullContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitOp_body_null(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Op_body_ctxContext ------------------------------------------------------------------

LustreParser::ContractContext* LustreParser::Op_body_ctxContext::contract() {
  return getRuleContext<LustreParser::ContractContext>(0);
}

LustreParser::Local_blockContext* LustreParser::Op_body_ctxContext::local_block() {
  return getRuleContext<LustreParser::Local_blockContext>(0);
}

std::vector<LustreParser::Let_blockContext *> LustreParser::Op_body_ctxContext::let_block() {
  return getRuleContexts<LustreParser::Let_blockContext>();
}

LustreParser::Let_blockContext* LustreParser::Op_body_ctxContext::let_block(size_t i) {
  return getRuleContext<LustreParser::Let_blockContext>(i);
}

LustreParser::Op_body_ctxContext::Op_body_ctxContext(Op_bodyContext *ctx) { copyFrom(ctx); }

void LustreParser::Op_body_ctxContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_body_ctx(this);
}
void LustreParser::Op_body_ctxContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_body_ctx(this);
}

std::any LustreParser::Op_body_ctxContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitOp_body_ctx(this);
  else
    return visitor->visitChildren(this);
}
LustreParser::Op_bodyContext* LustreParser::op_body() {
  Op_bodyContext *_localctx = _tracker.createInstance<Op_bodyContext>(_ctx, getState());
  enterRule(_localctx, 58, LustreParser::RuleOp_body);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(493);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LustreParser::T__1: {
        _localctx = _tracker.createInstance<LustreParser::Op_body_nullContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(475);
        match(LustreParser::T__1);
        break;
      }

      case LustreParser::T__38:
      case LustreParser::T__40:
      case LustreParser::T__42:
      case LustreParser::T__44: {
        _localctx = _tracker.createInstance<LustreParser::Op_body_ctxContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(477);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == LustreParser::T__40

        || _la == LustreParser::T__42) {
          setState(476);
          contract();
        }
        setState(480);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == LustreParser::T__44) {
          setState(479);
          local_block();
        }
        setState(482);
        match(LustreParser::T__38);
        setState(486);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 2612087784948629504) != 0) || ((((_la - 141) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 141)) & 225) != 0)) {
          setState(483);
          let_block();
          setState(488);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(489);
        match(LustreParser::T__39);
        setState(491);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == LustreParser::T__1) {
          setState(490);
          match(LustreParser::T__1);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ContractContext ------------------------------------------------------------------

LustreParser::ContractContext::ContractContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<LustreParser::Kind2_contract_itemContext *> LustreParser::ContractContext::kind2_contract_item() {
  return getRuleContexts<LustreParser::Kind2_contract_itemContext>();
}

LustreParser::Kind2_contract_itemContext* LustreParser::ContractContext::kind2_contract_item(size_t i) {
  return getRuleContext<LustreParser::Kind2_contract_itemContext>(i);
}


size_t LustreParser::ContractContext::getRuleIndex() const {
  return LustreParser::RuleContract;
}

void LustreParser::ContractContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterContract(this);
}

void LustreParser::ContractContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitContract(this);
}


std::any LustreParser::ContractContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitContract(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::ContractContext* LustreParser::contract() {
  ContractContext *_localctx = _tracker.createInstance<ContractContext>(_ctx, getState());
  enterRule(_localctx, 60, LustreParser::RuleContract);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(511);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LustreParser::T__40: {
        enterOuterAlt(_localctx, 1);
        setState(495);
        match(LustreParser::T__40);
        setState(499);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 16079258044596224) != 0) || _la == LustreParser::ID) {
          setState(496);
          kind2_contract_item();
          setState(501);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(502);
        match(LustreParser::T__41);
        break;
      }

      case LustreParser::T__42: {
        enterOuterAlt(_localctx, 2);
        setState(503);
        match(LustreParser::T__42);
        setState(507);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 16079258044596224) != 0) || _la == LustreParser::ID) {
          setState(504);
          kind2_contract_item();
          setState(509);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(510);
        match(LustreParser::T__43);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Local_blockContext ------------------------------------------------------------------

LustreParser::Local_blockContext::Local_blockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<LustreParser::Var_declsContext *> LustreParser::Local_blockContext::var_decls() {
  return getRuleContexts<LustreParser::Var_declsContext>();
}

LustreParser::Var_declsContext* LustreParser::Local_blockContext::var_decls(size_t i) {
  return getRuleContext<LustreParser::Var_declsContext>(i);
}


size_t LustreParser::Local_blockContext::getRuleIndex() const {
  return LustreParser::RuleLocal_block;
}

void LustreParser::Local_blockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLocal_block(this);
}

void LustreParser::Local_blockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLocal_block(this);
}


std::any LustreParser::Local_blockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitLocal_block(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Local_blockContext* LustreParser::local_block() {
  Local_blockContext *_localctx = _tracker.createInstance<Local_blockContext>(_ctx, getState());
  enterRule(_localctx, 62, LustreParser::RuleLocal_block);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(513);
    match(LustreParser::T__44);
    setState(519);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == LustreParser::ID) {
      setState(514);
      var_decls();
      setState(515);
      match(LustreParser::T__1);
      setState(521);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Let_blockContext ------------------------------------------------------------------

LustreParser::Let_blockContext::Let_blockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::Let_blockContext::getRuleIndex() const {
  return LustreParser::RuleLet_block;
}

void LustreParser::Let_blockContext::copyFrom(Let_blockContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Let_block_k2_propertyContext ------------------------------------------------------------------

LustreParser::Kind2_propertyContext* LustreParser::Let_block_k2_propertyContext::kind2_property() {
  return getRuleContext<LustreParser::Kind2_propertyContext>(0);
}

LustreParser::Let_block_k2_propertyContext::Let_block_k2_propertyContext(Let_blockContext *ctx) { copyFrom(ctx); }

void LustreParser::Let_block_k2_propertyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLet_block_k2_property(this);
}
void LustreParser::Let_block_k2_propertyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLet_block_k2_property(this);
}

std::any LustreParser::Let_block_k2_propertyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitLet_block_k2_property(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Let_block_k2_frame_blockContext ------------------------------------------------------------------

LustreParser::Kind2_frame_blockContext* LustreParser::Let_block_k2_frame_blockContext::kind2_frame_block() {
  return getRuleContext<LustreParser::Kind2_frame_blockContext>(0);
}

LustreParser::Let_block_k2_frame_blockContext::Let_block_k2_frame_blockContext(Let_blockContext *ctx) { copyFrom(ctx); }

void LustreParser::Let_block_k2_frame_blockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLet_block_k2_frame_block(this);
}
void LustreParser::Let_block_k2_frame_blockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLet_block_k2_frame_block(this);
}

std::any LustreParser::Let_block_k2_frame_blockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitLet_block_k2_frame_block(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Let_block_k2_if_blockContext ------------------------------------------------------------------

LustreParser::Kind2_if_blockContext* LustreParser::Let_block_k2_if_blockContext::kind2_if_block() {
  return getRuleContext<LustreParser::Kind2_if_blockContext>(0);
}

LustreParser::Let_block_k2_if_blockContext::Let_block_k2_if_blockContext(Let_blockContext *ctx) { copyFrom(ctx); }

void LustreParser::Let_block_k2_if_blockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLet_block_k2_if_block(this);
}
void LustreParser::Let_block_k2_if_blockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLet_block_k2_if_block(this);
}

std::any LustreParser::Let_block_k2_if_blockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitLet_block_k2_if_block(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Let_block_equationContext ------------------------------------------------------------------

LustreParser::EquationContext* LustreParser::Let_block_equationContext::equation() {
  return getRuleContext<LustreParser::EquationContext>(0);
}

LustreParser::Let_block_equationContext::Let_block_equationContext(Let_blockContext *ctx) { copyFrom(ctx); }

void LustreParser::Let_block_equationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLet_block_equation(this);
}
void LustreParser::Let_block_equationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLet_block_equation(this);
}

std::any LustreParser::Let_block_equationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitLet_block_equation(this);
  else
    return visitor->visitChildren(this);
}
LustreParser::Let_blockContext* LustreParser::let_block() {
  Let_blockContext *_localctx = _tracker.createInstance<Let_blockContext>(_ctx, getState());
  enterRule(_localctx, 64, LustreParser::RuleLet_block);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(530);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LustreParser::T__29:
      case LustreParser::T__60:
      case LustreParser::ID: {
        _localctx = _tracker.createInstance<LustreParser::Let_block_equationContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(522);
        equation();
        setState(523);
        match(LustreParser::T__1);
        break;
      }

      case LustreParser::MAIN:
      case LustreParser::PROPERTY:
      case LustreParser::CHECK: {
        _localctx = _tracker.createInstance<LustreParser::Let_block_k2_propertyContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(525);
        kind2_property();
        break;
      }

      case LustreParser::T__53: {
        _localctx = _tracker.createInstance<LustreParser::Let_block_k2_if_blockContext>(_localctx);
        enterOuterAlt(_localctx, 3);
        setState(526);
        kind2_if_block();
        setState(527);
        match(LustreParser::T__45);
        break;
      }

      case LustreParser::T__57: {
        _localctx = _tracker.createInstance<LustreParser::Let_block_k2_frame_blockContext>(_localctx);
        enterOuterAlt(_localctx, 4);
        setState(529);
        kind2_frame_block();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- External_contractContext ------------------------------------------------------------------

LustreParser::External_contractContext::External_contractContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LustreParser::External_contractContext::ID() {
  return getToken(LustreParser::ID, 0);
}

std::vector<LustreParser::ParamsContext *> LustreParser::External_contractContext::params() {
  return getRuleContexts<LustreParser::ParamsContext>();
}

LustreParser::ParamsContext* LustreParser::External_contractContext::params(size_t i) {
  return getRuleContext<LustreParser::ParamsContext>(i);
}

LustreParser::Contract_bodyContext* LustreParser::External_contractContext::contract_body() {
  return getRuleContext<LustreParser::Contract_bodyContext>(0);
}


size_t LustreParser::External_contractContext::getRuleIndex() const {
  return LustreParser::RuleExternal_contract;
}

void LustreParser::External_contractContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExternal_contract(this);
}

void LustreParser::External_contractContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExternal_contract(this);
}


std::any LustreParser::External_contractContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitExternal_contract(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::External_contractContext* LustreParser::external_contract() {
  External_contractContext *_localctx = _tracker.createInstance<External_contractContext>(_ctx, getState());
  enterRule(_localctx, 66, LustreParser::RuleExternal_contract);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(532);
    match(LustreParser::T__46);
    setState(533);
    match(LustreParser::ID);
    setState(534);
    params();
    setState(535);
    match(LustreParser::T__12);
    setState(536);
    params();
    setState(538);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == LustreParser::T__1) {
      setState(537);
      match(LustreParser::T__1);
    }
    setState(540);
    contract_body();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Contract_bodyContext ------------------------------------------------------------------

LustreParser::Contract_bodyContext::Contract_bodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<LustreParser::Kind2_contract_itemContext *> LustreParser::Contract_bodyContext::kind2_contract_item() {
  return getRuleContexts<LustreParser::Kind2_contract_itemContext>();
}

LustreParser::Kind2_contract_itemContext* LustreParser::Contract_bodyContext::kind2_contract_item(size_t i) {
  return getRuleContext<LustreParser::Kind2_contract_itemContext>(i);
}


size_t LustreParser::Contract_bodyContext::getRuleIndex() const {
  return LustreParser::RuleContract_body;
}

void LustreParser::Contract_bodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterContract_body(this);
}

void LustreParser::Contract_bodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitContract_body(this);
}


std::any LustreParser::Contract_bodyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitContract_body(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Contract_bodyContext* LustreParser::contract_body() {
  Contract_bodyContext *_localctx = _tracker.createInstance<Contract_bodyContext>(_ctx, getState());
  enterRule(_localctx, 68, LustreParser::RuleContract_body);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(542);
    match(LustreParser::T__38);
    setState(544); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(543);
      kind2_contract_item();
      setState(546); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 16079258044596224) != 0) || _la == LustreParser::ID);
    setState(548);
    match(LustreParser::T__39);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Kind2_contract_itemContext ------------------------------------------------------------------

LustreParser::Kind2_contract_itemContext::Kind2_contract_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::Kind2_contract_itemContext::getRuleIndex() const {
  return LustreParser::RuleKind2_contract_item;
}

void LustreParser::Kind2_contract_itemContext::copyFrom(Kind2_contract_itemContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Decls_guaranteeContext ------------------------------------------------------------------

LustreParser::Guarantee_itemContext* LustreParser::Decls_guaranteeContext::guarantee_item() {
  return getRuleContext<LustreParser::Guarantee_itemContext>(0);
}

LustreParser::Decls_guaranteeContext::Decls_guaranteeContext(Kind2_contract_itemContext *ctx) { copyFrom(ctx); }

void LustreParser::Decls_guaranteeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDecls_guarantee(this);
}
void LustreParser::Decls_guaranteeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDecls_guarantee(this);
}

std::any LustreParser::Decls_guaranteeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitDecls_guarantee(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Decls_importsContext ------------------------------------------------------------------

LustreParser::Import_itemContext* LustreParser::Decls_importsContext::import_item() {
  return getRuleContext<LustreParser::Import_itemContext>(0);
}

LustreParser::Decls_importsContext::Decls_importsContext(Kind2_contract_itemContext *ctx) { copyFrom(ctx); }

void LustreParser::Decls_importsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDecls_imports(this);
}
void LustreParser::Decls_importsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDecls_imports(this);
}

std::any LustreParser::Decls_importsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitDecls_imports(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Decls_ghost_varContext ------------------------------------------------------------------

LustreParser::Kind2_var_itemContext* LustreParser::Decls_ghost_varContext::kind2_var_item() {
  return getRuleContext<LustreParser::Kind2_var_itemContext>(0);
}

LustreParser::Decls_ghost_varContext::Decls_ghost_varContext(Kind2_contract_itemContext *ctx) { copyFrom(ctx); }

void LustreParser::Decls_ghost_varContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDecls_ghost_var(this);
}
void LustreParser::Decls_ghost_varContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDecls_ghost_var(this);
}

std::any LustreParser::Decls_ghost_varContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitDecls_ghost_var(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Decls_modeContext ------------------------------------------------------------------

LustreParser::Mode_declContext* LustreParser::Decls_modeContext::mode_decl() {
  return getRuleContext<LustreParser::Mode_declContext>(0);
}

LustreParser::Decls_modeContext::Decls_modeContext(Kind2_contract_itemContext *ctx) { copyFrom(ctx); }

void LustreParser::Decls_modeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDecls_mode(this);
}
void LustreParser::Decls_modeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDecls_mode(this);
}

std::any LustreParser::Decls_modeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitDecls_mode(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Decls_const_ghost_varContext ------------------------------------------------------------------

LustreParser::Kind2_const_itemContext* LustreParser::Decls_const_ghost_varContext::kind2_const_item() {
  return getRuleContext<LustreParser::Kind2_const_itemContext>(0);
}

LustreParser::Decls_const_ghost_varContext::Decls_const_ghost_varContext(Kind2_contract_itemContext *ctx) { copyFrom(ctx); }

void LustreParser::Decls_const_ghost_varContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDecls_const_ghost_var(this);
}
void LustreParser::Decls_const_ghost_varContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDecls_const_ghost_var(this);
}

std::any LustreParser::Decls_const_ghost_varContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitDecls_const_ghost_var(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Decls_assumeContext ------------------------------------------------------------------

LustreParser::Assume_itemContext* LustreParser::Decls_assumeContext::assume_item() {
  return getRuleContext<LustreParser::Assume_itemContext>(0);
}

LustreParser::Decls_assumeContext::Decls_assumeContext(Kind2_contract_itemContext *ctx) { copyFrom(ctx); }

void LustreParser::Decls_assumeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDecls_assume(this);
}
void LustreParser::Decls_assumeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDecls_assume(this);
}

std::any LustreParser::Decls_assumeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitDecls_assume(this);
  else
    return visitor->visitChildren(this);
}
LustreParser::Kind2_contract_itemContext* LustreParser::kind2_contract_item() {
  Kind2_contract_itemContext *_localctx = _tracker.createInstance<Kind2_contract_itemContext>(_ctx, getState());
  enterRule(_localctx, 70, LustreParser::RuleKind2_contract_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(556);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LustreParser::T__47: {
        _localctx = _tracker.createInstance<LustreParser::Decls_modeContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(550);
        mode_decl();
        break;
      }

      case LustreParser::ID: {
        _localctx = _tracker.createInstance<LustreParser::Decls_const_ghost_varContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(551);
        kind2_const_item();
        break;
      }

      case LustreParser::T__44: {
        _localctx = _tracker.createInstance<LustreParser::Decls_ghost_varContext>(_localctx);
        enterOuterAlt(_localctx, 3);
        setState(552);
        kind2_var_item();
        break;
      }

      case LustreParser::T__50: {
        _localctx = _tracker.createInstance<LustreParser::Decls_assumeContext>(_localctx);
        enterOuterAlt(_localctx, 4);
        setState(553);
        assume_item();
        break;
      }

      case LustreParser::T__51: {
        _localctx = _tracker.createInstance<LustreParser::Decls_guaranteeContext>(_localctx);
        enterOuterAlt(_localctx, 5);
        setState(554);
        guarantee_item();
        break;
      }

      case LustreParser::T__52: {
        _localctx = _tracker.createInstance<LustreParser::Decls_importsContext>(_localctx);
        enterOuterAlt(_localctx, 6);
        setState(555);
        import_item();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Mode_declContext ------------------------------------------------------------------

LustreParser::Mode_declContext::Mode_declContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LustreParser::Mode_declContext::ID() {
  return getToken(LustreParser::ID, 0);
}

LustreParser::Mode_bodyContext* LustreParser::Mode_declContext::mode_body() {
  return getRuleContext<LustreParser::Mode_bodyContext>(0);
}


size_t LustreParser::Mode_declContext::getRuleIndex() const {
  return LustreParser::RuleMode_decl;
}

void LustreParser::Mode_declContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMode_decl(this);
}

void LustreParser::Mode_declContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMode_decl(this);
}


std::any LustreParser::Mode_declContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitMode_decl(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Mode_declContext* LustreParser::mode_decl() {
  Mode_declContext *_localctx = _tracker.createInstance<Mode_declContext>(_ctx, getState());
  enterRule(_localctx, 72, LustreParser::RuleMode_decl);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(558);
    match(LustreParser::T__47);
    setState(559);
    match(LustreParser::ID);
    setState(560);
    match(LustreParser::T__29);
    setState(561);
    mode_body();
    setState(562);
    match(LustreParser::T__30);
    setState(563);
    match(LustreParser::T__1);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Mode_bodyContext ------------------------------------------------------------------

LustreParser::Mode_bodyContext::Mode_bodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<LustreParser::RequirementContext *> LustreParser::Mode_bodyContext::requirement() {
  return getRuleContexts<LustreParser::RequirementContext>();
}

LustreParser::RequirementContext* LustreParser::Mode_bodyContext::requirement(size_t i) {
  return getRuleContext<LustreParser::RequirementContext>(i);
}

std::vector<LustreParser::AssuranceContext *> LustreParser::Mode_bodyContext::assurance() {
  return getRuleContexts<LustreParser::AssuranceContext>();
}

LustreParser::AssuranceContext* LustreParser::Mode_bodyContext::assurance(size_t i) {
  return getRuleContext<LustreParser::AssuranceContext>(i);
}


size_t LustreParser::Mode_bodyContext::getRuleIndex() const {
  return LustreParser::RuleMode_body;
}

void LustreParser::Mode_bodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMode_body(this);
}

void LustreParser::Mode_bodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMode_body(this);
}


std::any LustreParser::Mode_bodyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitMode_body(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Mode_bodyContext* LustreParser::mode_body() {
  Mode_bodyContext *_localctx = _tracker.createInstance<Mode_bodyContext>(_ctx, getState());
  enterRule(_localctx, 74, LustreParser::RuleMode_body);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(567); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(567);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case LustreParser::T__48: {
          setState(565);
          requirement();
          break;
        }

        case LustreParser::T__49: {
          setState(566);
          assurance();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(569); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == LustreParser::T__48

    || _la == LustreParser::T__49);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RequirementContext ------------------------------------------------------------------

LustreParser::RequirementContext::RequirementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::RequirementContext::getRuleIndex() const {
  return LustreParser::RuleRequirement;
}

void LustreParser::RequirementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRequirement(this);
}

void LustreParser::RequirementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRequirement(this);
}


std::any LustreParser::RequirementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitRequirement(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::RequirementContext* LustreParser::requirement() {
  RequirementContext *_localctx = _tracker.createInstance<RequirementContext>(_ctx, getState());
  enterRule(_localctx, 76, LustreParser::RuleRequirement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(571);
    match(LustreParser::T__48);
    setState(575);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 52, _ctx);
    while (alt != 1 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1 + 1) {
        setState(572);
        matchWildcard(); 
      }
      setState(577);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 52, _ctx);
    }
    setState(578);
    match(LustreParser::T__1);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssuranceContext ------------------------------------------------------------------

LustreParser::AssuranceContext::AssuranceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::AssuranceContext::getRuleIndex() const {
  return LustreParser::RuleAssurance;
}

void LustreParser::AssuranceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssurance(this);
}

void LustreParser::AssuranceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssurance(this);
}


std::any LustreParser::AssuranceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitAssurance(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::AssuranceContext* LustreParser::assurance() {
  AssuranceContext *_localctx = _tracker.createInstance<AssuranceContext>(_ctx, getState());
  enterRule(_localctx, 78, LustreParser::RuleAssurance);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(580);
    match(LustreParser::T__49);
    setState(584);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 53, _ctx);
    while (alt != 1 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1 + 1) {
        setState(581);
        matchWildcard(); 
      }
      setState(586);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 53, _ctx);
    }
    setState(587);
    match(LustreParser::T__1);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Kind2_const_itemContext ------------------------------------------------------------------

LustreParser::Kind2_const_itemContext::Kind2_const_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LustreParser::Kind2_const_itemContext::ID() {
  return getToken(LustreParser::ID, 0);
}

LustreParser::TypeContext* LustreParser::Kind2_const_itemContext::type() {
  return getRuleContext<LustreParser::TypeContext>(0);
}


size_t LustreParser::Kind2_const_itemContext::getRuleIndex() const {
  return LustreParser::RuleKind2_const_item;
}

void LustreParser::Kind2_const_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKind2_const_item(this);
}

void LustreParser::Kind2_const_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKind2_const_item(this);
}


std::any LustreParser::Kind2_const_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitKind2_const_item(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Kind2_const_itemContext* LustreParser::kind2_const_item() {
  Kind2_const_itemContext *_localctx = _tracker.createInstance<Kind2_const_itemContext>(_ctx, getState());
  enterRule(_localctx, 80, LustreParser::RuleKind2_const_item);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(589);
    match(LustreParser::ID);
    setState(592);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == LustreParser::T__27) {
      setState(590);
      match(LustreParser::T__27);
      setState(591);
      type(0);
    }
    setState(594);
    match(LustreParser::T__7);
    setState(598);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 55, _ctx);
    while (alt != 1 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1 + 1) {
        setState(595);
        matchWildcard(); 
      }
      setState(600);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 55, _ctx);
    }
    setState(601);
    match(LustreParser::T__1);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Kind2_var_itemContext ------------------------------------------------------------------

LustreParser::Kind2_var_itemContext::Kind2_var_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LustreParser::Kind2_var_itemContext::ID() {
  return getToken(LustreParser::ID, 0);
}

LustreParser::TypeContext* LustreParser::Kind2_var_itemContext::type() {
  return getRuleContext<LustreParser::TypeContext>(0);
}


size_t LustreParser::Kind2_var_itemContext::getRuleIndex() const {
  return LustreParser::RuleKind2_var_item;
}

void LustreParser::Kind2_var_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKind2_var_item(this);
}

void LustreParser::Kind2_var_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKind2_var_item(this);
}


std::any LustreParser::Kind2_var_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitKind2_var_item(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Kind2_var_itemContext* LustreParser::kind2_var_item() {
  Kind2_var_itemContext *_localctx = _tracker.createInstance<Kind2_var_itemContext>(_ctx, getState());
  enterRule(_localctx, 82, LustreParser::RuleKind2_var_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(603);
    match(LustreParser::T__44);
    setState(604);
    match(LustreParser::ID);
    setState(605);
    match(LustreParser::T__27);
    setState(606);
    type(0);
    setState(607);
    match(LustreParser::T__7);
    setState(611);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 56, _ctx);
    while (alt != 1 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1 + 1) {
        setState(608);
        matchWildcard(); 
      }
      setState(613);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 56, _ctx);
    }
    setState(614);
    match(LustreParser::T__1);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Assume_itemContext ------------------------------------------------------------------

LustreParser::Assume_itemContext::Assume_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::Assume_itemContext::getRuleIndex() const {
  return LustreParser::RuleAssume_item;
}

void LustreParser::Assume_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssume_item(this);
}

void LustreParser::Assume_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssume_item(this);
}


std::any LustreParser::Assume_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitAssume_item(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Assume_itemContext* LustreParser::assume_item() {
  Assume_itemContext *_localctx = _tracker.createInstance<Assume_itemContext>(_ctx, getState());
  enterRule(_localctx, 84, LustreParser::RuleAssume_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(616);
    match(LustreParser::T__50);
    setState(620);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 57, _ctx);
    while (alt != 1 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1 + 1) {
        setState(617);
        matchWildcard(); 
      }
      setState(622);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 57, _ctx);
    }
    setState(623);
    match(LustreParser::T__1);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Guarantee_itemContext ------------------------------------------------------------------

LustreParser::Guarantee_itemContext::Guarantee_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::Guarantee_itemContext::getRuleIndex() const {
  return LustreParser::RuleGuarantee_item;
}

void LustreParser::Guarantee_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGuarantee_item(this);
}

void LustreParser::Guarantee_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGuarantee_item(this);
}


std::any LustreParser::Guarantee_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitGuarantee_item(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Guarantee_itemContext* LustreParser::guarantee_item() {
  Guarantee_itemContext *_localctx = _tracker.createInstance<Guarantee_itemContext>(_ctx, getState());
  enterRule(_localctx, 86, LustreParser::RuleGuarantee_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(625);
    match(LustreParser::T__51);
    setState(629);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 58, _ctx);
    while (alt != 1 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1 + 1) {
        setState(626);
        matchWildcard(); 
      }
      setState(631);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 58, _ctx);
    }
    setState(632);
    match(LustreParser::T__1);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Import_itemContext ------------------------------------------------------------------

LustreParser::Import_itemContext::Import_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> LustreParser::Import_itemContext::ID() {
  return getTokens(LustreParser::ID);
}

tree::TerminalNode* LustreParser::Import_itemContext::ID(size_t i) {
  return getToken(LustreParser::ID, i);
}

std::vector<LustreParser::ExprContext *> LustreParser::Import_itemContext::expr() {
  return getRuleContexts<LustreParser::ExprContext>();
}

LustreParser::ExprContext* LustreParser::Import_itemContext::expr(size_t i) {
  return getRuleContext<LustreParser::ExprContext>(i);
}


size_t LustreParser::Import_itemContext::getRuleIndex() const {
  return LustreParser::RuleImport_item;
}

void LustreParser::Import_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImport_item(this);
}

void LustreParser::Import_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImport_item(this);
}


std::any LustreParser::Import_itemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitImport_item(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Import_itemContext* LustreParser::import_item() {
  Import_itemContext *_localctx = _tracker.createInstance<Import_itemContext>(_ctx, getState());
  enterRule(_localctx, 88, LustreParser::RuleImport_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(634);
    match(LustreParser::T__52);
    setState(635);
    match(LustreParser::ID);
    setState(636);
    match(LustreParser::T__29);
    setState(642);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 59, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(637);
        expr();
        setState(638);
        match(LustreParser::T__6); 
      }
      setState(644);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 59, _ctx);
    }
    setState(645);
    expr();
    setState(646);
    match(LustreParser::T__30);
    setState(647);
    match(LustreParser::T__12);
    setState(648);
    match(LustreParser::T__29);
    setState(653);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 60, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(649);
        match(LustreParser::ID);
        setState(650);
        match(LustreParser::T__6); 
      }
      setState(655);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 60, _ctx);
    }
    setState(656);
    match(LustreParser::ID);
    setState(657);
    match(LustreParser::T__30);
    setState(658);
    match(LustreParser::T__1);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Kind2_if_blockContext ------------------------------------------------------------------

LustreParser::Kind2_if_blockContext::Kind2_if_blockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<LustreParser::Simple_exprContext *> LustreParser::Kind2_if_blockContext::simple_expr() {
  return getRuleContexts<LustreParser::Simple_exprContext>();
}

LustreParser::Simple_exprContext* LustreParser::Kind2_if_blockContext::simple_expr(size_t i) {
  return getRuleContext<LustreParser::Simple_exprContext>(i);
}

std::vector<LustreParser::Kind2_if_bodyContext *> LustreParser::Kind2_if_blockContext::kind2_if_body() {
  return getRuleContexts<LustreParser::Kind2_if_bodyContext>();
}

LustreParser::Kind2_if_bodyContext* LustreParser::Kind2_if_blockContext::kind2_if_body(size_t i) {
  return getRuleContext<LustreParser::Kind2_if_bodyContext>(i);
}


size_t LustreParser::Kind2_if_blockContext::getRuleIndex() const {
  return LustreParser::RuleKind2_if_block;
}

void LustreParser::Kind2_if_blockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKind2_if_block(this);
}

void LustreParser::Kind2_if_blockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKind2_if_block(this);
}


std::any LustreParser::Kind2_if_blockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitKind2_if_block(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Kind2_if_blockContext* LustreParser::kind2_if_block() {
  Kind2_if_blockContext *_localctx = _tracker.createInstance<Kind2_if_blockContext>(_ctx, getState());
  enterRule(_localctx, 90, LustreParser::RuleKind2_if_block);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(660);
    match(LustreParser::T__53);
    setState(661);
    simple_expr(0);
    setState(662);
    match(LustreParser::T__54);
    setState(666); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(663);
      simple_expr(0);
      setState(664);
      match(LustreParser::T__1);
      setState(668); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 35567501568) != 0) || ((((_la - 79) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 79)) & 9205494115226091521) != 0));
    setState(673);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == LustreParser::T__55

    || _la == LustreParser::T__56) {
      setState(670);
      kind2_if_body();
      setState(675);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Kind2_if_bodyContext ------------------------------------------------------------------

LustreParser::Kind2_if_bodyContext::Kind2_if_bodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<LustreParser::Simple_exprContext *> LustreParser::Kind2_if_bodyContext::simple_expr() {
  return getRuleContexts<LustreParser::Simple_exprContext>();
}

LustreParser::Simple_exprContext* LustreParser::Kind2_if_bodyContext::simple_expr(size_t i) {
  return getRuleContext<LustreParser::Simple_exprContext>(i);
}


size_t LustreParser::Kind2_if_bodyContext::getRuleIndex() const {
  return LustreParser::RuleKind2_if_body;
}

void LustreParser::Kind2_if_bodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKind2_if_body(this);
}

void LustreParser::Kind2_if_bodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKind2_if_body(this);
}


std::any LustreParser::Kind2_if_bodyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitKind2_if_body(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Kind2_if_bodyContext* LustreParser::kind2_if_body() {
  Kind2_if_bodyContext *_localctx = _tracker.createInstance<Kind2_if_bodyContext>(_ctx, getState());
  enterRule(_localctx, 92, LustreParser::RuleKind2_if_body);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(694);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LustreParser::T__55: {
        enterOuterAlt(_localctx, 1);
        setState(676);
        match(LustreParser::T__55);
        setState(677);
        simple_expr(0);
        setState(678);
        match(LustreParser::T__54);
        setState(682); 
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(679);
          simple_expr(0);
          setState(680);
          match(LustreParser::T__1);
          setState(684); 
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 35567501568) != 0) || ((((_la - 79) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 79)) & 9205494115226091521) != 0));
        break;
      }

      case LustreParser::T__56: {
        enterOuterAlt(_localctx, 2);
        setState(686);
        match(LustreParser::T__56);
        setState(690); 
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(687);
          simple_expr(0);
          setState(688);
          match(LustreParser::T__1);
          setState(692); 
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 35567501568) != 0) || ((((_la - 79) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 79)) & 9205494115226091521) != 0));
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Kind2_propertyContext ------------------------------------------------------------------

LustreParser::Kind2_propertyContext::Kind2_propertyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::Kind2_propertyContext::getRuleIndex() const {
  return LustreParser::RuleKind2_property;
}

void LustreParser::Kind2_propertyContext::copyFrom(Kind2_propertyContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Kind2_statement_mainContext ------------------------------------------------------------------

tree::TerminalNode* LustreParser::Kind2_statement_mainContext::MAIN() {
  return getToken(LustreParser::MAIN, 0);
}

LustreParser::Kind2_statement_mainContext::Kind2_statement_mainContext(Kind2_propertyContext *ctx) { copyFrom(ctx); }

void LustreParser::Kind2_statement_mainContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKind2_statement_main(this);
}
void LustreParser::Kind2_statement_mainContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKind2_statement_main(this);
}

std::any LustreParser::Kind2_statement_mainContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitKind2_statement_main(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Kind2_statement_propertyContext ------------------------------------------------------------------

tree::TerminalNode* LustreParser::Kind2_statement_propertyContext::PROPERTY() {
  return getToken(LustreParser::PROPERTY, 0);
}

LustreParser::Kind2_statement_propertyContext::Kind2_statement_propertyContext(Kind2_propertyContext *ctx) { copyFrom(ctx); }

void LustreParser::Kind2_statement_propertyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKind2_statement_property(this);
}
void LustreParser::Kind2_statement_propertyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKind2_statement_property(this);
}

std::any LustreParser::Kind2_statement_propertyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitKind2_statement_property(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Kind2_statement_checkContext ------------------------------------------------------------------

tree::TerminalNode* LustreParser::Kind2_statement_checkContext::CHECK() {
  return getToken(LustreParser::CHECK, 0);
}

LustreParser::Kind2_statement_checkContext::Kind2_statement_checkContext(Kind2_propertyContext *ctx) { copyFrom(ctx); }

void LustreParser::Kind2_statement_checkContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKind2_statement_check(this);
}
void LustreParser::Kind2_statement_checkContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKind2_statement_check(this);
}

std::any LustreParser::Kind2_statement_checkContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitKind2_statement_check(this);
  else
    return visitor->visitChildren(this);
}
LustreParser::Kind2_propertyContext* LustreParser::kind2_property() {
  Kind2_propertyContext *_localctx = _tracker.createInstance<Kind2_propertyContext>(_ctx, getState());
  enterRule(_localctx, 94, LustreParser::RuleKind2_property);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(699);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LustreParser::MAIN: {
        _localctx = _tracker.createInstance<LustreParser::Kind2_statement_mainContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(696);
        match(LustreParser::MAIN);
        break;
      }

      case LustreParser::PROPERTY: {
        _localctx = _tracker.createInstance<LustreParser::Kind2_statement_propertyContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(697);
        match(LustreParser::PROPERTY);
        break;
      }

      case LustreParser::CHECK: {
        _localctx = _tracker.createInstance<LustreParser::Kind2_statement_checkContext>(_localctx);
        enterOuterAlt(_localctx, 3);
        setState(698);
        match(LustreParser::CHECK);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Kind2_frame_blockContext ------------------------------------------------------------------

LustreParser::Kind2_frame_blockContext::Kind2_frame_blockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LustreParser::Frame_initContext* LustreParser::Kind2_frame_blockContext::frame_init() {
  return getRuleContext<LustreParser::Frame_initContext>(0);
}

LustreParser::Frame_bodyContext* LustreParser::Kind2_frame_blockContext::frame_body() {
  return getRuleContext<LustreParser::Frame_bodyContext>(0);
}


size_t LustreParser::Kind2_frame_blockContext::getRuleIndex() const {
  return LustreParser::RuleKind2_frame_block;
}

void LustreParser::Kind2_frame_blockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKind2_frame_block(this);
}

void LustreParser::Kind2_frame_blockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKind2_frame_block(this);
}


std::any LustreParser::Kind2_frame_blockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitKind2_frame_block(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Kind2_frame_blockContext* LustreParser::kind2_frame_block() {
  Kind2_frame_blockContext *_localctx = _tracker.createInstance<Kind2_frame_blockContext>(_ctx, getState());
  enterRule(_localctx, 96, LustreParser::RuleKind2_frame_block);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(701);
    frame_init();
    setState(702);
    frame_body();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Frame_initContext ------------------------------------------------------------------

LustreParser::Frame_initContext::Frame_initContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> LustreParser::Frame_initContext::ID() {
  return getTokens(LustreParser::ID);
}

tree::TerminalNode* LustreParser::Frame_initContext::ID(size_t i) {
  return getToken(LustreParser::ID, i);
}

std::vector<LustreParser::Simple_exprContext *> LustreParser::Frame_initContext::simple_expr() {
  return getRuleContexts<LustreParser::Simple_exprContext>();
}

LustreParser::Simple_exprContext* LustreParser::Frame_initContext::simple_expr(size_t i) {
  return getRuleContext<LustreParser::Simple_exprContext>(i);
}


size_t LustreParser::Frame_initContext::getRuleIndex() const {
  return LustreParser::RuleFrame_init;
}

void LustreParser::Frame_initContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFrame_init(this);
}

void LustreParser::Frame_initContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFrame_init(this);
}


std::any LustreParser::Frame_initContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitFrame_init(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Frame_initContext* LustreParser::frame_init() {
  Frame_initContext *_localctx = _tracker.createInstance<Frame_initContext>(_ctx, getState());
  enterRule(_localctx, 98, LustreParser::RuleFrame_init);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(704);
    match(LustreParser::T__57);
    setState(705);
    match(LustreParser::T__29);
    setState(706);
    match(LustreParser::ID);
    setState(711);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == LustreParser::T__6) {
      setState(707);
      match(LustreParser::T__6);
      setState(708);
      match(LustreParser::ID);
      setState(713);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(714);
    match(LustreParser::T__30);
    setState(720);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 35567501568) != 0) || ((((_la - 79) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 79)) & 9205494115226091521) != 0)) {
      setState(715);
      simple_expr(0);
      setState(716);
      match(LustreParser::T__1);
      setState(722);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Frame_bodyContext ------------------------------------------------------------------

LustreParser::Frame_bodyContext::Frame_bodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<LustreParser::EquationContext *> LustreParser::Frame_bodyContext::equation() {
  return getRuleContexts<LustreParser::EquationContext>();
}

LustreParser::EquationContext* LustreParser::Frame_bodyContext::equation(size_t i) {
  return getRuleContext<LustreParser::EquationContext>(i);
}


size_t LustreParser::Frame_bodyContext::getRuleIndex() const {
  return LustreParser::RuleFrame_body;
}

void LustreParser::Frame_bodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFrame_body(this);
}

void LustreParser::Frame_bodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFrame_body(this);
}


std::any LustreParser::Frame_bodyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitFrame_body(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Frame_bodyContext* LustreParser::frame_body() {
  Frame_bodyContext *_localctx = _tracker.createInstance<Frame_bodyContext>(_ctx, getState());
  enterRule(_localctx, 100, LustreParser::RuleFrame_body);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(723);
    match(LustreParser::T__38);
    setState(729);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == LustreParser::T__29

    || _la == LustreParser::T__60 || _la == LustreParser::ID) {
      setState(724);
      equation();
      setState(725);
      match(LustreParser::T__1);
      setState(731);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(732);
    match(LustreParser::T__39);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Import_op_declContext ------------------------------------------------------------------

LustreParser::Import_op_declContext::Import_op_declContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LustreParser::Import_op_declContext::ID() {
  return getToken(LustreParser::ID, 0);
}

std::vector<LustreParser::ParamsContext *> LustreParser::Import_op_declContext::params() {
  return getRuleContexts<LustreParser::ParamsContext>();
}

LustreParser::ParamsContext* LustreParser::Import_op_declContext::params(size_t i) {
  return getRuleContext<LustreParser::ParamsContext>(i);
}


size_t LustreParser::Import_op_declContext::getRuleIndex() const {
  return LustreParser::RuleImport_op_decl;
}

void LustreParser::Import_op_declContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImport_op_decl(this);
}

void LustreParser::Import_op_declContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImport_op_decl(this);
}


std::any LustreParser::Import_op_declContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitImport_op_decl(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Import_op_declContext* LustreParser::import_op_decl() {
  Import_op_declContext *_localctx = _tracker.createInstance<Import_op_declContext>(_ctx, getState());
  enterRule(_localctx, 102, LustreParser::RuleImport_op_decl);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(734);
    match(LustreParser::T__36);
    setState(735);
    match(LustreParser::T__58);
    setState(736);
    match(LustreParser::ID);
    setState(737);
    params();
    setState(738);
    match(LustreParser::T__12);
    setState(739);
    params();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EquationContext ------------------------------------------------------------------

LustreParser::EquationContext::EquationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::EquationContext::getRuleIndex() const {
  return LustreParser::RuleEquation;
}

void LustreParser::EquationContext::copyFrom(EquationContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Equation_state_machineContext ------------------------------------------------------------------

LustreParser::State_machineContext* LustreParser::Equation_state_machineContext::state_machine() {
  return getRuleContext<LustreParser::State_machineContext>(0);
}

LustreParser::ReturnContext* LustreParser::Equation_state_machineContext::return_() {
  return getRuleContext<LustreParser::ReturnContext>(0);
}

LustreParser::Equation_state_machineContext::Equation_state_machineContext(EquationContext *ctx) { copyFrom(ctx); }

void LustreParser::Equation_state_machineContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEquation_state_machine(this);
}
void LustreParser::Equation_state_machineContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEquation_state_machine(this);
}

std::any LustreParser::Equation_state_machineContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitEquation_state_machine(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Equation_exprContext ------------------------------------------------------------------

LustreParser::LhsContext* LustreParser::Equation_exprContext::lhs() {
  return getRuleContext<LustreParser::LhsContext>(0);
}

LustreParser::ExprContext* LustreParser::Equation_exprContext::expr() {
  return getRuleContext<LustreParser::ExprContext>(0);
}

LustreParser::Equation_exprContext::Equation_exprContext(EquationContext *ctx) { copyFrom(ctx); }

void LustreParser::Equation_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEquation_expr(this);
}
void LustreParser::Equation_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEquation_expr(this);
}

std::any LustreParser::Equation_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitEquation_expr(this);
  else
    return visitor->visitChildren(this);
}
LustreParser::EquationContext* LustreParser::equation() {
  EquationContext *_localctx = _tracker.createInstance<EquationContext>(_ctx, getState());
  enterRule(_localctx, 104, LustreParser::RuleEquation);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(748);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LustreParser::T__29:
      case LustreParser::ID: {
        _localctx = _tracker.createInstance<LustreParser::Equation_exprContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(741);
        lhs();
        setState(742);
        match(LustreParser::T__7);
        setState(743);
        expr();
        break;
      }

      case LustreParser::T__60: {
        _localctx = _tracker.createInstance<LustreParser::Equation_state_machineContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(745);
        state_machine();
        setState(746);
        return_();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LhsContext ------------------------------------------------------------------

LustreParser::LhsContext::LhsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::LhsContext::getRuleIndex() const {
  return LustreParser::RuleLhs;
}

void LustreParser::LhsContext::copyFrom(LhsContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Lhs_pairContext ------------------------------------------------------------------

LustreParser::Lhs_pairContext::Lhs_pairContext(LhsContext *ctx) { copyFrom(ctx); }

void LustreParser::Lhs_pairContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLhs_pair(this);
}
void LustreParser::Lhs_pairContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLhs_pair(this);
}

std::any LustreParser::Lhs_pairContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitLhs_pair(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Lhs_id_listContext ------------------------------------------------------------------

std::vector<tree::TerminalNode *> LustreParser::Lhs_id_listContext::ID() {
  return getTokens(LustreParser::ID);
}

tree::TerminalNode* LustreParser::Lhs_id_listContext::ID(size_t i) {
  return getToken(LustreParser::ID, i);
}

LustreParser::Lhs_id_listContext::Lhs_id_listContext(LhsContext *ctx) { copyFrom(ctx); }

void LustreParser::Lhs_id_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLhs_id_list(this);
}
void LustreParser::Lhs_id_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLhs_id_list(this);
}

std::any LustreParser::Lhs_id_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitLhs_id_list(this);
  else
    return visitor->visitChildren(this);
}
LustreParser::LhsContext* LustreParser::lhs() {
  LhsContext *_localctx = _tracker.createInstance<LhsContext>(_ctx, getState());
  enterRule(_localctx, 106, LustreParser::RuleLhs);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(766);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 74, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<LustreParser::Lhs_pairContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(750);
      match(LustreParser::T__29);
      setState(751);
      match(LustreParser::T__30);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<LustreParser::Lhs_id_listContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(753);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == LustreParser::T__29) {
        setState(752);
        match(LustreParser::T__29);
      }
      setState(755);
      match(LustreParser::ID);
      setState(760);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == LustreParser::T__6) {
        setState(756);
        match(LustreParser::T__6);
        setState(757);
        match(LustreParser::ID);
        setState(762);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(764);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == LustreParser::T__30) {
        setState(763);
        match(LustreParser::T__30);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReturnContext ------------------------------------------------------------------

LustreParser::ReturnContext::ReturnContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LustreParser::Returns_varContext* LustreParser::ReturnContext::returns_var() {
  return getRuleContext<LustreParser::Returns_varContext>(0);
}


size_t LustreParser::ReturnContext::getRuleIndex() const {
  return LustreParser::RuleReturn;
}

void LustreParser::ReturnContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReturn(this);
}

void LustreParser::ReturnContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReturn(this);
}


std::any LustreParser::ReturnContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitReturn(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::ReturnContext* LustreParser::return_() {
  ReturnContext *_localctx = _tracker.createInstance<ReturnContext>(_ctx, getState());
  enterRule(_localctx, 108, LustreParser::RuleReturn);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(768);
    match(LustreParser::T__12);
    setState(769);
    returns_var();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Returns_varContext ------------------------------------------------------------------

LustreParser::Returns_varContext::Returns_varContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> LustreParser::Returns_varContext::ID() {
  return getTokens(LustreParser::ID);
}

tree::TerminalNode* LustreParser::Returns_varContext::ID(size_t i) {
  return getToken(LustreParser::ID, i);
}


size_t LustreParser::Returns_varContext::getRuleIndex() const {
  return LustreParser::RuleReturns_var;
}

void LustreParser::Returns_varContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReturns_var(this);
}

void LustreParser::Returns_varContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReturns_var(this);
}


std::any LustreParser::Returns_varContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitReturns_var(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Returns_varContext* LustreParser::returns_var() {
  Returns_varContext *_localctx = _tracker.createInstance<Returns_varContext>(_ctx, getState());
  enterRule(_localctx, 110, LustreParser::RuleReturns_var);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(775);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 75, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(771);
        match(LustreParser::ID);
        setState(772);
        match(LustreParser::T__6); 
      }
      setState(777);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 75, _ctx);
    }
    setState(779);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == LustreParser::T__59 || _la == LustreParser::ID) {
      setState(778);
      _la = _input->LA(1);
      if (!(_la == LustreParser::T__59 || _la == LustreParser::ID)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- State_machineContext ------------------------------------------------------------------

LustreParser::State_machineContext::State_machineContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LustreParser::State_machineContext::ID() {
  return getToken(LustreParser::ID, 0);
}

std::vector<LustreParser::State_declContext *> LustreParser::State_machineContext::state_decl() {
  return getRuleContexts<LustreParser::State_declContext>();
}

LustreParser::State_declContext* LustreParser::State_machineContext::state_decl(size_t i) {
  return getRuleContext<LustreParser::State_declContext>(i);
}


size_t LustreParser::State_machineContext::getRuleIndex() const {
  return LustreParser::RuleState_machine;
}

void LustreParser::State_machineContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterState_machine(this);
}

void LustreParser::State_machineContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitState_machine(this);
}


std::any LustreParser::State_machineContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitState_machine(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::State_machineContext* LustreParser::state_machine() {
  State_machineContext *_localctx = _tracker.createInstance<State_machineContext>(_ctx, getState());
  enterRule(_localctx, 112, LustreParser::RuleState_machine);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(781);
    match(LustreParser::T__60);
    setState(783);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == LustreParser::ID) {
      setState(782);
      match(LustreParser::ID);
    }
    setState(786); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(785);
      state_decl();
      setState(788); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == LustreParser::T__61 || _la == LustreParser::INITIAL

    || _la == LustreParser::FINAL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- State_declContext ------------------------------------------------------------------

LustreParser::State_declContext::State_declContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LustreParser::State_declContext::ID() {
  return getToken(LustreParser::ID, 0);
}

LustreParser::Data_defContext* LustreParser::State_declContext::data_def() {
  return getRuleContext<LustreParser::Data_defContext>(0);
}

tree::TerminalNode* LustreParser::State_declContext::INITIAL() {
  return getToken(LustreParser::INITIAL, 0);
}

tree::TerminalNode* LustreParser::State_declContext::FINAL() {
  return getToken(LustreParser::FINAL, 0);
}

LustreParser::Unless_tranContext* LustreParser::State_declContext::unless_tran() {
  return getRuleContext<LustreParser::Unless_tranContext>(0);
}

LustreParser::Until_tranContext* LustreParser::State_declContext::until_tran() {
  return getRuleContext<LustreParser::Until_tranContext>(0);
}


size_t LustreParser::State_declContext::getRuleIndex() const {
  return LustreParser::RuleState_decl;
}

void LustreParser::State_declContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterState_decl(this);
}

void LustreParser::State_declContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitState_decl(this);
}


std::any LustreParser::State_declContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitState_decl(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::State_declContext* LustreParser::state_decl() {
  State_declContext *_localctx = _tracker.createInstance<State_declContext>(_ctx, getState());
  enterRule(_localctx, 114, LustreParser::RuleState_decl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(791);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == LustreParser::INITIAL) {
      setState(790);
      match(LustreParser::INITIAL);
    }
    setState(794);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == LustreParser::FINAL) {
      setState(793);
      match(LustreParser::FINAL);
    }
    setState(796);
    match(LustreParser::T__61);
    setState(797);
    match(LustreParser::ID);
    setState(799);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == LustreParser::UNLESS) {
      setState(798);
      unless_tran();
    }
    setState(801);
    data_def();
    setState(803);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == LustreParser::UNTIL) {
      setState(802);
      until_tran();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Data_defContext ------------------------------------------------------------------

LustreParser::Data_defContext::Data_defContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::Data_defContext::getRuleIndex() const {
  return LustreParser::RuleData_def;
}

void LustreParser::Data_defContext::copyFrom(Data_defContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- State_machine_data_def_local_blockContext ------------------------------------------------------------------

LustreParser::Local_blockContext* LustreParser::State_machine_data_def_local_blockContext::local_block() {
  return getRuleContext<LustreParser::Local_blockContext>(0);
}

std::vector<LustreParser::EquationContext *> LustreParser::State_machine_data_def_local_blockContext::equation() {
  return getRuleContexts<LustreParser::EquationContext>();
}

LustreParser::EquationContext* LustreParser::State_machine_data_def_local_blockContext::equation(size_t i) {
  return getRuleContext<LustreParser::EquationContext>(i);
}

LustreParser::State_machine_data_def_local_blockContext::State_machine_data_def_local_blockContext(Data_defContext *ctx) { copyFrom(ctx); }

void LustreParser::State_machine_data_def_local_blockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterState_machine_data_def_local_block(this);
}
void LustreParser::State_machine_data_def_local_blockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitState_machine_data_def_local_block(this);
}

std::any LustreParser::State_machine_data_def_local_blockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitState_machine_data_def_local_block(this);
  else
    return visitor->visitChildren(this);
}
//----------------- State_machine_data_def_equationContext ------------------------------------------------------------------

LustreParser::EquationContext* LustreParser::State_machine_data_def_equationContext::equation() {
  return getRuleContext<LustreParser::EquationContext>(0);
}

LustreParser::State_machine_data_def_equationContext::State_machine_data_def_equationContext(Data_defContext *ctx) { copyFrom(ctx); }

void LustreParser::State_machine_data_def_equationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterState_machine_data_def_equation(this);
}
void LustreParser::State_machine_data_def_equationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitState_machine_data_def_equation(this);
}

std::any LustreParser::State_machine_data_def_equationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitState_machine_data_def_equation(this);
  else
    return visitor->visitChildren(this);
}
LustreParser::Data_defContext* LustreParser::data_def() {
  Data_defContext *_localctx = _tracker.createInstance<Data_defContext>(_ctx, getState());
  enterRule(_localctx, 116, LustreParser::RuleData_def);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(821);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LustreParser::T__29:
      case LustreParser::T__60:
      case LustreParser::ID: {
        _localctx = _tracker.createInstance<LustreParser::State_machine_data_def_equationContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(805);
        equation();
        break;
      }

      case LustreParser::T__12:
      case LustreParser::T__38:
      case LustreParser::T__44:
      case LustreParser::T__61:
      case LustreParser::INITIAL:
      case LustreParser::FINAL:
      case LustreParser::UNTIL: {
        _localctx = _tracker.createInstance<LustreParser::State_machine_data_def_local_blockContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(807);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == LustreParser::T__44) {
          setState(806);
          local_block();
        }
        setState(819);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == LustreParser::T__38) {
          setState(809);
          match(LustreParser::T__38);
          setState(815);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == LustreParser::T__29

          || _la == LustreParser::T__60 || _la == LustreParser::ID) {
            setState(810);
            equation();
            setState(811);
            match(LustreParser::T__1);
            setState(817);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          setState(818);
          match(LustreParser::T__39);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Unless_tranContext ------------------------------------------------------------------

LustreParser::Unless_tranContext::Unless_tranContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LustreParser::Unless_tranContext::UNLESS() {
  return getToken(LustreParser::UNLESS, 0);
}

std::vector<LustreParser::TransitionContext *> LustreParser::Unless_tranContext::transition() {
  return getRuleContexts<LustreParser::TransitionContext>();
}

LustreParser::TransitionContext* LustreParser::Unless_tranContext::transition(size_t i) {
  return getRuleContext<LustreParser::TransitionContext>(i);
}


size_t LustreParser::Unless_tranContext::getRuleIndex() const {
  return LustreParser::RuleUnless_tran;
}

void LustreParser::Unless_tranContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnless_tran(this);
}

void LustreParser::Unless_tranContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnless_tran(this);
}


std::any LustreParser::Unless_tranContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitUnless_tran(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Unless_tranContext* LustreParser::unless_tran() {
  Unless_tranContext *_localctx = _tracker.createInstance<Unless_tranContext>(_ctx, getState());
  enterRule(_localctx, 118, LustreParser::RuleUnless_tran);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(823);
    match(LustreParser::UNLESS);
    setState(827); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(824);
      transition();
      setState(825);
      match(LustreParser::T__1);
      setState(829); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == LustreParser::T__53);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Until_tranContext ------------------------------------------------------------------

LustreParser::Until_tranContext::Until_tranContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LustreParser::Until_tranContext::UNTIL() {
  return getToken(LustreParser::UNTIL, 0);
}

std::vector<LustreParser::TransitionContext *> LustreParser::Until_tranContext::transition() {
  return getRuleContexts<LustreParser::TransitionContext>();
}

LustreParser::TransitionContext* LustreParser::Until_tranContext::transition(size_t i) {
  return getRuleContext<LustreParser::TransitionContext>(i);
}


size_t LustreParser::Until_tranContext::getRuleIndex() const {
  return LustreParser::RuleUntil_tran;
}

void LustreParser::Until_tranContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUntil_tran(this);
}

void LustreParser::Until_tranContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUntil_tran(this);
}


std::any LustreParser::Until_tranContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitUntil_tran(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Until_tranContext* LustreParser::until_tran() {
  Until_tranContext *_localctx = _tracker.createInstance<Until_tranContext>(_ctx, getState());
  enterRule(_localctx, 120, LustreParser::RuleUntil_tran);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(831);
    match(LustreParser::UNTIL);
    setState(837);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == LustreParser::T__53) {
      setState(832);
      transition();
      setState(833);
      match(LustreParser::T__1);
      setState(839);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TransitionContext ------------------------------------------------------------------

LustreParser::TransitionContext::TransitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::TransitionContext::getRuleIndex() const {
  return LustreParser::RuleTransition;
}

void LustreParser::TransitionContext::copyFrom(TransitionContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- State_machine_transition_restartContext ------------------------------------------------------------------

LustreParser::ExprContext* LustreParser::State_machine_transition_restartContext::expr() {
  return getRuleContext<LustreParser::ExprContext>(0);
}

tree::TerminalNode* LustreParser::State_machine_transition_restartContext::ID() {
  return getToken(LustreParser::ID, 0);
}

LustreParser::State_machine_transition_restartContext::State_machine_transition_restartContext(TransitionContext *ctx) { copyFrom(ctx); }

void LustreParser::State_machine_transition_restartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterState_machine_transition_restart(this);
}
void LustreParser::State_machine_transition_restartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitState_machine_transition_restart(this);
}

std::any LustreParser::State_machine_transition_restartContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitState_machine_transition_restart(this);
  else
    return visitor->visitChildren(this);
}
//----------------- State_machine_transition_resumeContext ------------------------------------------------------------------

LustreParser::ExprContext* LustreParser::State_machine_transition_resumeContext::expr() {
  return getRuleContext<LustreParser::ExprContext>(0);
}

tree::TerminalNode* LustreParser::State_machine_transition_resumeContext::ID() {
  return getToken(LustreParser::ID, 0);
}

LustreParser::State_machine_transition_resumeContext::State_machine_transition_resumeContext(TransitionContext *ctx) { copyFrom(ctx); }

void LustreParser::State_machine_transition_resumeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterState_machine_transition_resume(this);
}
void LustreParser::State_machine_transition_resumeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitState_machine_transition_resume(this);
}

std::any LustreParser::State_machine_transition_resumeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitState_machine_transition_resume(this);
  else
    return visitor->visitChildren(this);
}
LustreParser::TransitionContext* LustreParser::transition() {
  TransitionContext *_localctx = _tracker.createInstance<TransitionContext>(_ctx, getState());
  enterRule(_localctx, 122, LustreParser::RuleTransition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(850);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 89, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<LustreParser::State_machine_transition_resumeContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(840);
      match(LustreParser::T__53);
      setState(841);
      expr();
      setState(842);
      match(LustreParser::T__62);
      setState(843);
      match(LustreParser::ID);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<LustreParser::State_machine_transition_restartContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(845);
      match(LustreParser::T__53);
      setState(846);
      expr();
      setState(847);
      match(LustreParser::T__63);
      setState(848);
      match(LustreParser::ID);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExprContext ------------------------------------------------------------------

LustreParser::ExprContext::ExprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::ExprContext::getRuleIndex() const {
  return LustreParser::RuleExpr;
}

void LustreParser::ExprContext::copyFrom(ExprContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Expr_apply_exprContext ------------------------------------------------------------------

LustreParser::Apply_exprContext* LustreParser::Expr_apply_exprContext::apply_expr() {
  return getRuleContext<LustreParser::Apply_exprContext>(0);
}

LustreParser::Expr_apply_exprContext::Expr_apply_exprContext(ExprContext *ctx) { copyFrom(ctx); }

void LustreParser::Expr_apply_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpr_apply_expr(this);
}
void LustreParser::Expr_apply_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpr_apply_expr(this);
}

std::any LustreParser::Expr_apply_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitExpr_apply_expr(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Expr_simple_exprContext ------------------------------------------------------------------

LustreParser::Simple_exprContext* LustreParser::Expr_simple_exprContext::simple_expr() {
  return getRuleContext<LustreParser::Simple_exprContext>(0);
}

LustreParser::Expr_simple_exprContext::Expr_simple_exprContext(ExprContext *ctx) { copyFrom(ctx); }

void LustreParser::Expr_simple_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpr_simple_expr(this);
}
void LustreParser::Expr_simple_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpr_simple_expr(this);
}

std::any LustreParser::Expr_simple_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitExpr_simple_expr(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Expr_kind2_exprContext ------------------------------------------------------------------

LustreParser::Kind2_exprContext* LustreParser::Expr_kind2_exprContext::kind2_expr() {
  return getRuleContext<LustreParser::Kind2_exprContext>(0);
}

LustreParser::Expr_kind2_exprContext::Expr_kind2_exprContext(ExprContext *ctx) { copyFrom(ctx); }

void LustreParser::Expr_kind2_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpr_kind2_expr(this);
}
void LustreParser::Expr_kind2_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpr_kind2_expr(this);
}

std::any LustreParser::Expr_kind2_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitExpr_kind2_expr(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Expr_mixed_constructorContext ------------------------------------------------------------------

LustreParser::Mixed_constructorContext* LustreParser::Expr_mixed_constructorContext::mixed_constructor() {
  return getRuleContext<LustreParser::Mixed_constructorContext>(0);
}

LustreParser::Expr_mixed_constructorContext::Expr_mixed_constructorContext(ExprContext *ctx) { copyFrom(ctx); }

void LustreParser::Expr_mixed_constructorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpr_mixed_constructor(this);
}
void LustreParser::Expr_mixed_constructorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpr_mixed_constructor(this);
}

std::any LustreParser::Expr_mixed_constructorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitExpr_mixed_constructor(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Expr_tempo_exprContext ------------------------------------------------------------------

LustreParser::Tempo_exprContext* LustreParser::Expr_tempo_exprContext::tempo_expr() {
  return getRuleContext<LustreParser::Tempo_exprContext>(0);
}

LustreParser::Expr_tempo_exprContext::Expr_tempo_exprContext(ExprContext *ctx) { copyFrom(ctx); }

void LustreParser::Expr_tempo_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpr_tempo_expr(this);
}
void LustreParser::Expr_tempo_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpr_tempo_expr(this);
}

std::any LustreParser::Expr_tempo_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitExpr_tempo_expr(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Expr_struct_exprContext ------------------------------------------------------------------

LustreParser::Struct_exprContext* LustreParser::Expr_struct_exprContext::struct_expr() {
  return getRuleContext<LustreParser::Struct_exprContext>(0);
}

LustreParser::Expr_struct_exprContext::Expr_struct_exprContext(ExprContext *ctx) { copyFrom(ctx); }

void LustreParser::Expr_struct_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpr_struct_expr(this);
}
void LustreParser::Expr_struct_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpr_struct_expr(this);
}

std::any LustreParser::Expr_struct_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitExpr_struct_expr(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Expr_bool_exprContext ------------------------------------------------------------------

LustreParser::Bool_exprContext* LustreParser::Expr_bool_exprContext::bool_expr() {
  return getRuleContext<LustreParser::Bool_exprContext>(0);
}

LustreParser::Expr_bool_exprContext::Expr_bool_exprContext(ExprContext *ctx) { copyFrom(ctx); }

void LustreParser::Expr_bool_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpr_bool_expr(this);
}
void LustreParser::Expr_bool_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpr_bool_expr(this);
}

std::any LustreParser::Expr_bool_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitExpr_bool_expr(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Expr_last_declContext ------------------------------------------------------------------

tree::TerminalNode* LustreParser::Expr_last_declContext::ID() {
  return getToken(LustreParser::ID, 0);
}

LustreParser::Expr_last_declContext::Expr_last_declContext(ExprContext *ctx) { copyFrom(ctx); }

void LustreParser::Expr_last_declContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpr_last_decl(this);
}
void LustreParser::Expr_last_declContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpr_last_decl(this);
}

std::any LustreParser::Expr_last_declContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitExpr_last_decl(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Expr_parenContext ------------------------------------------------------------------

LustreParser::ExprContext* LustreParser::Expr_parenContext::expr() {
  return getRuleContext<LustreParser::ExprContext>(0);
}

LustreParser::Expr_parenContext::Expr_parenContext(ExprContext *ctx) { copyFrom(ctx); }

void LustreParser::Expr_parenContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpr_paren(this);
}
void LustreParser::Expr_parenContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpr_paren(this);
}

std::any LustreParser::Expr_parenContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitExpr_paren(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Expr_array_exprContext ------------------------------------------------------------------

LustreParser::Array_exprContext* LustreParser::Expr_array_exprContext::array_expr() {
  return getRuleContext<LustreParser::Array_exprContext>(0);
}

LustreParser::Expr_array_exprContext::Expr_array_exprContext(ExprContext *ctx) { copyFrom(ctx); }

void LustreParser::Expr_array_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpr_array_expr(this);
}
void LustreParser::Expr_array_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpr_array_expr(this);
}

std::any LustreParser::Expr_array_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitExpr_array_expr(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Expr_switch_exprContext ------------------------------------------------------------------

LustreParser::Switch_exprContext* LustreParser::Expr_switch_exprContext::switch_expr() {
  return getRuleContext<LustreParser::Switch_exprContext>(0);
}

LustreParser::Expr_switch_exprContext::Expr_switch_exprContext(ExprContext *ctx) { copyFrom(ctx); }

void LustreParser::Expr_switch_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpr_switch_expr(this);
}
void LustreParser::Expr_switch_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpr_switch_expr(this);
}

std::any LustreParser::Expr_switch_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitExpr_switch_expr(this);
  else
    return visitor->visitChildren(this);
}
LustreParser::ExprContext* LustreParser::expr() {
  ExprContext *_localctx = _tracker.createInstance<ExprContext>(_ctx, getState());
  enterRule(_localctx, 124, LustreParser::RuleExpr);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(868);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 90, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<LustreParser::Expr_simple_exprContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(852);
      simple_expr(0);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<LustreParser::Expr_last_declContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(853);
      match(LustreParser::T__35);
      setState(854);
      match(LustreParser::T__64);
      setState(855);
      match(LustreParser::ID);
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<LustreParser::Expr_tempo_exprContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(856);
      tempo_expr();
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<LustreParser::Expr_bool_exprContext>(_localctx);
      enterOuterAlt(_localctx, 4);
      setState(857);
      bool_expr();
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<LustreParser::Expr_array_exprContext>(_localctx);
      enterOuterAlt(_localctx, 5);
      setState(858);
      array_expr();
      break;
    }

    case 6: {
      _localctx = _tracker.createInstance<LustreParser::Expr_struct_exprContext>(_localctx);
      enterOuterAlt(_localctx, 6);
      setState(859);
      struct_expr();
      break;
    }

    case 7: {
      _localctx = _tracker.createInstance<LustreParser::Expr_mixed_constructorContext>(_localctx);
      enterOuterAlt(_localctx, 7);
      setState(860);
      mixed_constructor();
      break;
    }

    case 8: {
      _localctx = _tracker.createInstance<LustreParser::Expr_switch_exprContext>(_localctx);
      enterOuterAlt(_localctx, 8);
      setState(861);
      switch_expr();
      break;
    }

    case 9: {
      _localctx = _tracker.createInstance<LustreParser::Expr_parenContext>(_localctx);
      enterOuterAlt(_localctx, 9);
      setState(862);
      match(LustreParser::T__29);
      setState(863);
      expr();
      setState(864);
      match(LustreParser::T__30);
      break;
    }

    case 10: {
      _localctx = _tracker.createInstance<LustreParser::Expr_apply_exprContext>(_localctx);
      enterOuterAlt(_localctx, 10);
      setState(866);
      apply_expr();
      break;
    }

    case 11: {
      _localctx = _tracker.createInstance<LustreParser::Expr_kind2_exprContext>(_localctx);
      enterOuterAlt(_localctx, 11);
      setState(867);
      kind2_expr();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ListContext ------------------------------------------------------------------

LustreParser::ListContext::ListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<LustreParser::Simple_exprContext *> LustreParser::ListContext::simple_expr() {
  return getRuleContexts<LustreParser::Simple_exprContext>();
}

LustreParser::Simple_exprContext* LustreParser::ListContext::simple_expr(size_t i) {
  return getRuleContext<LustreParser::Simple_exprContext>(i);
}


size_t LustreParser::ListContext::getRuleIndex() const {
  return LustreParser::RuleList;
}

void LustreParser::ListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterList(this);
}

void LustreParser::ListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitList(this);
}


std::any LustreParser::ListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitList(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::ListContext* LustreParser::list() {
  ListContext *_localctx = _tracker.createInstance<ListContext>(_ctx, getState());
  enterRule(_localctx, 126, LustreParser::RuleList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(878);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 35567501568) != 0) || ((((_la - 79) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 79)) & 9205494115226091521) != 0)) {
      setState(870);
      simple_expr(0);
      setState(875);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 91, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(871);
          match(LustreParser::T__6);
          setState(872);
          simple_expr(0); 
        }
        setState(877);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 91, _ctx);
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Kind2_exprContext ------------------------------------------------------------------

LustreParser::Kind2_exprContext::Kind2_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LustreParser::Activate_exprContext* LustreParser::Kind2_exprContext::activate_expr() {
  return getRuleContext<LustreParser::Activate_exprContext>(0);
}

LustreParser::Restart_exprContext* LustreParser::Kind2_exprContext::restart_expr() {
  return getRuleContext<LustreParser::Restart_exprContext>(0);
}


size_t LustreParser::Kind2_exprContext::getRuleIndex() const {
  return LustreParser::RuleKind2_expr;
}

void LustreParser::Kind2_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKind2_expr(this);
}

void LustreParser::Kind2_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKind2_expr(this);
}


std::any LustreParser::Kind2_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitKind2_expr(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Kind2_exprContext* LustreParser::kind2_expr() {
  Kind2_exprContext *_localctx = _tracker.createInstance<Kind2_exprContext>(_ctx, getState());
  enterRule(_localctx, 128, LustreParser::RuleKind2_expr);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(882);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 93, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(880);
      activate_expr();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(881);
      restart_expr();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Activate_exprContext ------------------------------------------------------------------

LustreParser::Activate_exprContext::Activate_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LustreParser::ActivateContext* LustreParser::Activate_exprContext::activate() {
  return getRuleContext<LustreParser::ActivateContext>(0);
}

LustreParser::Kind2_paramContext* LustreParser::Activate_exprContext::kind2_param() {
  return getRuleContext<LustreParser::Kind2_paramContext>(0);
}

LustreParser::RestartContext* LustreParser::Activate_exprContext::restart() {
  return getRuleContext<LustreParser::RestartContext>(0);
}

tree::TerminalNode* LustreParser::Activate_exprContext::ID() {
  return getToken(LustreParser::ID, 0);
}


size_t LustreParser::Activate_exprContext::getRuleIndex() const {
  return LustreParser::RuleActivate_expr;
}

void LustreParser::Activate_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterActivate_expr(this);
}

void LustreParser::Activate_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitActivate_expr(this);
}


std::any LustreParser::Activate_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitActivate_expr(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Activate_exprContext* LustreParser::activate_expr() {
  Activate_exprContext *_localctx = _tracker.createInstance<Activate_exprContext>(_ctx, getState());
  enterRule(_localctx, 130, LustreParser::RuleActivate_expr);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(899);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 94, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(884);
      match(LustreParser::T__29);
      setState(885);
      activate();
      setState(886);
      match(LustreParser::T__30);
      setState(887);
      kind2_param();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(889);
      match(LustreParser::T__29);
      setState(890);
      match(LustreParser::T__65);
      setState(891);
      match(LustreParser::T__29);
      setState(892);
      restart();
      setState(893);
      match(LustreParser::T__30);
      setState(894);
      match(LustreParser::T__66);
      setState(895);
      match(LustreParser::ID);
      setState(896);
      match(LustreParser::T__30);
      setState(897);
      kind2_param();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Restart_exprContext ------------------------------------------------------------------

LustreParser::Restart_exprContext::Restart_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LustreParser::RestartContext* LustreParser::Restart_exprContext::restart() {
  return getRuleContext<LustreParser::RestartContext>(0);
}

LustreParser::Kind2_paramContext* LustreParser::Restart_exprContext::kind2_param() {
  return getRuleContext<LustreParser::Kind2_paramContext>(0);
}

LustreParser::ActivateContext* LustreParser::Restart_exprContext::activate() {
  return getRuleContext<LustreParser::ActivateContext>(0);
}

tree::TerminalNode* LustreParser::Restart_exprContext::ID() {
  return getToken(LustreParser::ID, 0);
}


size_t LustreParser::Restart_exprContext::getRuleIndex() const {
  return LustreParser::RuleRestart_expr;
}

void LustreParser::Restart_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRestart_expr(this);
}

void LustreParser::Restart_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRestart_expr(this);
}


std::any LustreParser::Restart_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitRestart_expr(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Restart_exprContext* LustreParser::restart_expr() {
  Restart_exprContext *_localctx = _tracker.createInstance<Restart_exprContext>(_ctx, getState());
  enterRule(_localctx, 132, LustreParser::RuleRestart_expr);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(914);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 95, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(901);
      match(LustreParser::T__29);
      setState(902);
      restart();
      setState(903);
      match(LustreParser::T__30);
      setState(904);
      kind2_param();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(906);
      match(LustreParser::T__29);
      setState(907);
      activate();
      setState(908);
      match(LustreParser::T__63);
      setState(909);
      match(LustreParser::T__66);
      setState(910);
      match(LustreParser::ID);
      setState(911);
      match(LustreParser::T__30);
      setState(912);
      kind2_param();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Kind2_paramContext ------------------------------------------------------------------

LustreParser::Kind2_paramContext::Kind2_paramContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> LustreParser::Kind2_paramContext::ID() {
  return getTokens(LustreParser::ID);
}

tree::TerminalNode* LustreParser::Kind2_paramContext::ID(size_t i) {
  return getToken(LustreParser::ID, i);
}

std::vector<LustreParser::AtomContext *> LustreParser::Kind2_paramContext::atom() {
  return getRuleContexts<LustreParser::AtomContext>();
}

LustreParser::AtomContext* LustreParser::Kind2_paramContext::atom(size_t i) {
  return getRuleContext<LustreParser::AtomContext>(i);
}


size_t LustreParser::Kind2_paramContext::getRuleIndex() const {
  return LustreParser::RuleKind2_param;
}

void LustreParser::Kind2_paramContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKind2_param(this);
}

void LustreParser::Kind2_paramContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKind2_param(this);
}


std::any LustreParser::Kind2_paramContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitKind2_param(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Kind2_paramContext* LustreParser::kind2_param() {
  Kind2_paramContext *_localctx = _tracker.createInstance<Kind2_paramContext>(_ctx, getState());
  enterRule(_localctx, 134, LustreParser::RuleKind2_param);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(916);
    match(LustreParser::T__29);
    setState(919);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LustreParser::ID: {
        setState(917);
        match(LustreParser::ID);
        break;
      }

      case LustreParser::BOOL:
      case LustreParser::INTEGER:
      case LustreParser::UINT:
      case LustreParser::REAL:
      case LustreParser::CHAR:
      case LustreParser::FLOAT:
      case LustreParser::USHORT:
      case LustreParser::SHORT: {
        setState(918);
        atom();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(928);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == LustreParser::T__6) {
      setState(921);
      match(LustreParser::T__6);
      setState(924);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case LustreParser::ID: {
          setState(922);
          match(LustreParser::ID);
          break;
        }

        case LustreParser::BOOL:
        case LustreParser::INTEGER:
        case LustreParser::UINT:
        case LustreParser::REAL:
        case LustreParser::CHAR:
        case LustreParser::FLOAT:
        case LustreParser::USHORT:
        case LustreParser::SHORT: {
          setState(923);
          atom();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(930);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(931);
    match(LustreParser::T__30);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ActivateContext ------------------------------------------------------------------

LustreParser::ActivateContext::ActivateContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> LustreParser::ActivateContext::ID() {
  return getTokens(LustreParser::ID);
}

tree::TerminalNode* LustreParser::ActivateContext::ID(size_t i) {
  return getToken(LustreParser::ID, i);
}


size_t LustreParser::ActivateContext::getRuleIndex() const {
  return LustreParser::RuleActivate;
}

void LustreParser::ActivateContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterActivate(this);
}

void LustreParser::ActivateContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitActivate(this);
}


std::any LustreParser::ActivateContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitActivate(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::ActivateContext* LustreParser::activate() {
  ActivateContext *_localctx = _tracker.createInstance<ActivateContext>(_ctx, getState());
  enterRule(_localctx, 136, LustreParser::RuleActivate);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(933);
    match(LustreParser::T__65);
    setState(934);
    match(LustreParser::ID);
    setState(935);
    match(LustreParser::T__66);
    setState(936);
    match(LustreParser::ID);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RestartContext ------------------------------------------------------------------

LustreParser::RestartContext::RestartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> LustreParser::RestartContext::ID() {
  return getTokens(LustreParser::ID);
}

tree::TerminalNode* LustreParser::RestartContext::ID(size_t i) {
  return getToken(LustreParser::ID, i);
}


size_t LustreParser::RestartContext::getRuleIndex() const {
  return LustreParser::RuleRestart;
}

void LustreParser::RestartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRestart(this);
}

void LustreParser::RestartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRestart(this);
}


std::any LustreParser::RestartContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitRestart(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::RestartContext* LustreParser::restart() {
  RestartContext *_localctx = _tracker.createInstance<RestartContext>(_ctx, getState());
  enterRule(_localctx, 138, LustreParser::RuleRestart);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(938);
    match(LustreParser::T__63);
    setState(939);
    match(LustreParser::ID);
    setState(940);
    match(LustreParser::T__66);
    setState(941);
    match(LustreParser::ID);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tempo_exprContext ------------------------------------------------------------------

LustreParser::Tempo_exprContext::Tempo_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::Tempo_exprContext::getRuleIndex() const {
  return LustreParser::RuleTempo_expr;
}

void LustreParser::Tempo_exprContext::copyFrom(Tempo_exprContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Tempo_expr_arrow_tempoContext ------------------------------------------------------------------

LustreParser::Simple_exprContext* LustreParser::Tempo_expr_arrow_tempoContext::simple_expr() {
  return getRuleContext<LustreParser::Simple_exprContext>(0);
}

LustreParser::Tempo_exprContext* LustreParser::Tempo_expr_arrow_tempoContext::tempo_expr() {
  return getRuleContext<LustreParser::Tempo_exprContext>(0);
}

LustreParser::Tempo_expr_arrow_tempoContext::Tempo_expr_arrow_tempoContext(Tempo_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Tempo_expr_arrow_tempoContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTempo_expr_arrow_tempo(this);
}
void LustreParser::Tempo_expr_arrow_tempoContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTempo_expr_arrow_tempo(this);
}

std::any LustreParser::Tempo_expr_arrow_tempoContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitTempo_expr_arrow_tempo(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Tempo_expr_mergeContext ------------------------------------------------------------------

tree::TerminalNode* LustreParser::Tempo_expr_mergeContext::ID() {
  return getToken(LustreParser::ID, 0);
}

std::vector<LustreParser::Simple_exprContext *> LustreParser::Tempo_expr_mergeContext::simple_expr() {
  return getRuleContexts<LustreParser::Simple_exprContext>();
}

LustreParser::Simple_exprContext* LustreParser::Tempo_expr_mergeContext::simple_expr(size_t i) {
  return getRuleContext<LustreParser::Simple_exprContext>(i);
}

LustreParser::Tempo_expr_mergeContext::Tempo_expr_mergeContext(Tempo_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Tempo_expr_mergeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTempo_expr_merge(this);
}
void LustreParser::Tempo_expr_mergeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTempo_expr_merge(this);
}

std::any LustreParser::Tempo_expr_mergeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitTempo_expr_merge(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Tempo_expr_arrowContext ------------------------------------------------------------------

std::vector<LustreParser::Simple_exprContext *> LustreParser::Tempo_expr_arrowContext::simple_expr() {
  return getRuleContexts<LustreParser::Simple_exprContext>();
}

LustreParser::Simple_exprContext* LustreParser::Tempo_expr_arrowContext::simple_expr(size_t i) {
  return getRuleContext<LustreParser::Simple_exprContext>(i);
}

LustreParser::Tempo_expr_arrowContext::Tempo_expr_arrowContext(Tempo_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Tempo_expr_arrowContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTempo_expr_arrow(this);
}
void LustreParser::Tempo_expr_arrowContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTempo_expr_arrow(this);
}

std::any LustreParser::Tempo_expr_arrowContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitTempo_expr_arrow(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Tempo_expr_fbyContext ------------------------------------------------------------------

std::vector<LustreParser::Simple_exprContext *> LustreParser::Tempo_expr_fbyContext::simple_expr() {
  return getRuleContexts<LustreParser::Simple_exprContext>();
}

LustreParser::Simple_exprContext* LustreParser::Tempo_expr_fbyContext::simple_expr(size_t i) {
  return getRuleContext<LustreParser::Simple_exprContext>(i);
}

LustreParser::Const_exprContext* LustreParser::Tempo_expr_fbyContext::const_expr() {
  return getRuleContext<LustreParser::Const_exprContext>(0);
}

LustreParser::Tempo_expr_fbyContext::Tempo_expr_fbyContext(Tempo_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Tempo_expr_fbyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTempo_expr_fby(this);
}
void LustreParser::Tempo_expr_fbyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTempo_expr_fby(this);
}

std::any LustreParser::Tempo_expr_fbyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitTempo_expr_fby(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Tempo_expr_preContext ------------------------------------------------------------------

LustreParser::Simple_exprContext* LustreParser::Tempo_expr_preContext::simple_expr() {
  return getRuleContext<LustreParser::Simple_exprContext>(0);
}

LustreParser::Tempo_expr_preContext::Tempo_expr_preContext(Tempo_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Tempo_expr_preContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTempo_expr_pre(this);
}
void LustreParser::Tempo_expr_preContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTempo_expr_pre(this);
}

std::any LustreParser::Tempo_expr_preContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitTempo_expr_pre(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Tempo_expr_whenContext ------------------------------------------------------------------

LustreParser::Simple_exprContext* LustreParser::Tempo_expr_whenContext::simple_expr() {
  return getRuleContext<LustreParser::Simple_exprContext>(0);
}

LustreParser::Clock_exprContext* LustreParser::Tempo_expr_whenContext::clock_expr() {
  return getRuleContext<LustreParser::Clock_exprContext>(0);
}

LustreParser::Tempo_expr_whenContext::Tempo_expr_whenContext(Tempo_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Tempo_expr_whenContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTempo_expr_when(this);
}
void LustreParser::Tempo_expr_whenContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTempo_expr_when(this);
}

std::any LustreParser::Tempo_expr_whenContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitTempo_expr_when(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Tempo_expr_fby_noconstContext ------------------------------------------------------------------

std::vector<LustreParser::Simple_exprContext *> LustreParser::Tempo_expr_fby_noconstContext::simple_expr() {
  return getRuleContexts<LustreParser::Simple_exprContext>();
}

LustreParser::Simple_exprContext* LustreParser::Tempo_expr_fby_noconstContext::simple_expr(size_t i) {
  return getRuleContext<LustreParser::Simple_exprContext>(i);
}

LustreParser::Tempo_expr_fby_noconstContext::Tempo_expr_fby_noconstContext(Tempo_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Tempo_expr_fby_noconstContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTempo_expr_fby_noconst(this);
}
void LustreParser::Tempo_expr_fby_noconstContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTempo_expr_fby_noconst(this);
}

std::any LustreParser::Tempo_expr_fby_noconstContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitTempo_expr_fby_noconst(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Tempo_kind2_mergeContext ------------------------------------------------------------------

std::vector<LustreParser::Merge_exprContext *> LustreParser::Tempo_kind2_mergeContext::merge_expr() {
  return getRuleContexts<LustreParser::Merge_exprContext>();
}

LustreParser::Merge_exprContext* LustreParser::Tempo_kind2_mergeContext::merge_expr(size_t i) {
  return getRuleContext<LustreParser::Merge_exprContext>(i);
}

LustreParser::Tempo_kind2_mergeContext::Tempo_kind2_mergeContext(Tempo_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Tempo_kind2_mergeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTempo_kind2_merge(this);
}
void LustreParser::Tempo_kind2_mergeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTempo_kind2_merge(this);
}

std::any LustreParser::Tempo_kind2_mergeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitTempo_kind2_merge(this);
  else
    return visitor->visitChildren(this);
}
LustreParser::Tempo_exprContext* LustreParser::tempo_expr() {
  Tempo_exprContext *_localctx = _tracker.createInstance<Tempo_exprContext>(_ctx, getState());
  enterRule(_localctx, 140, LustreParser::RuleTempo_expr);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1001);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 102, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<LustreParser::Tempo_expr_preContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(943);
      match(LustreParser::T__67);
      setState(944);
      simple_expr(0);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<LustreParser::Tempo_expr_arrow_tempoContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(945);
      simple_expr(0);
      setState(946);
      match(LustreParser::T__68);
      setState(947);
      tempo_expr();
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<LustreParser::Tempo_expr_arrowContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(949);
      simple_expr(0);
      setState(950);
      match(LustreParser::T__68);
      setState(951);
      simple_expr(0);
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<LustreParser::Tempo_expr_fbyContext>(_localctx);
      enterOuterAlt(_localctx, 4);
      setState(953);
      match(LustreParser::T__69);
      setState(954);
      match(LustreParser::T__29);
      setState(955);
      simple_expr(0);
      setState(960);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == LustreParser::T__6) {
        setState(956);
        match(LustreParser::T__6);
        setState(957);
        simple_expr(0);
        setState(962);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(963);
      match(LustreParser::T__1);
      setState(964);
      const_expr(0);
      setState(965);
      match(LustreParser::T__1);
      setState(966);
      simple_expr(0);
      setState(971);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == LustreParser::T__6) {
        setState(967);
        match(LustreParser::T__6);
        setState(968);
        simple_expr(0);
        setState(973);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(974);
      match(LustreParser::T__30);
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<LustreParser::Tempo_expr_fby_noconstContext>(_localctx);
      enterOuterAlt(_localctx, 5);
      setState(976);
      simple_expr(0);
      setState(977);
      match(LustreParser::T__69);
      setState(978);
      simple_expr(0);
      break;
    }

    case 6: {
      _localctx = _tracker.createInstance<LustreParser::Tempo_expr_whenContext>(_localctx);
      enterOuterAlt(_localctx, 6);
      setState(980);
      simple_expr(0);
      setState(981);
      match(LustreParser::T__33);
      setState(982);
      clock_expr();
      break;
    }

    case 7: {
      _localctx = _tracker.createInstance<LustreParser::Tempo_expr_mergeContext>(_localctx);
      enterOuterAlt(_localctx, 7);
      setState(984);
      match(LustreParser::T__70);
      setState(985);
      match(LustreParser::ID);

      setState(986);
      simple_expr(0);

      setState(987);
      simple_expr(0);
      break;
    }

    case 8: {
      _localctx = _tracker.createInstance<LustreParser::Tempo_kind2_mergeContext>(_localctx);
      enterOuterAlt(_localctx, 8);
      setState(989);
      match(LustreParser::T__70);
      setState(990);
      match(LustreParser::T__29);
      setState(991);
      merge_expr();
      setState(996);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == LustreParser::T__1) {
        setState(992);
        match(LustreParser::T__1);
        setState(993);
        merge_expr();
        setState(998);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(999);
      match(LustreParser::T__30);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bool_exprContext ------------------------------------------------------------------

LustreParser::Bool_exprContext::Bool_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LustreParser::ListContext* LustreParser::Bool_exprContext::list() {
  return getRuleContext<LustreParser::ListContext>(0);
}


size_t LustreParser::Bool_exprContext::getRuleIndex() const {
  return LustreParser::RuleBool_expr;
}

void LustreParser::Bool_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBool_expr(this);
}

void LustreParser::Bool_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBool_expr(this);
}


std::any LustreParser::Bool_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitBool_expr(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Bool_exprContext* LustreParser::bool_expr() {
  Bool_exprContext *_localctx = _tracker.createInstance<Bool_exprContext>(_ctx, getState());
  enterRule(_localctx, 142, LustreParser::RuleBool_expr);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1003);
    match(LustreParser::T__71);
    setState(1005);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 103, _ctx)) {
    case 1: {
      setState(1004);
      match(LustreParser::T__29);
      break;
    }

    default:
      break;
    }
    setState(1007);
    list();
    setState(1009);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 104, _ctx)) {
    case 1: {
      setState(1008);
      match(LustreParser::T__30);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Array_exprContext ------------------------------------------------------------------

LustreParser::Array_exprContext::Array_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::Array_exprContext::getRuleIndex() const {
  return LustreParser::RuleArray_expr;
}

void LustreParser::Array_exprContext::copyFrom(Array_exprContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Array_expr_splitContext ------------------------------------------------------------------

LustreParser::Simple_exprContext* LustreParser::Array_expr_splitContext::simple_expr() {
  return getRuleContext<LustreParser::Simple_exprContext>(0);
}

std::vector<tree::TerminalNode *> LustreParser::Array_expr_splitContext::INTEGER() {
  return getTokens(LustreParser::INTEGER);
}

tree::TerminalNode* LustreParser::Array_expr_splitContext::INTEGER(size_t i) {
  return getToken(LustreParser::INTEGER, i);
}

LustreParser::Array_expr_splitContext::Array_expr_splitContext(Array_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Array_expr_splitContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArray_expr_split(this);
}
void LustreParser::Array_expr_splitContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArray_expr_split(this);
}

std::any LustreParser::Array_expr_splitContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitArray_expr_split(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Array_expr_andContext ------------------------------------------------------------------

LustreParser::Simple_exprContext* LustreParser::Array_expr_andContext::simple_expr() {
  return getRuleContext<LustreParser::Simple_exprContext>(0);
}

LustreParser::Const_exprContext* LustreParser::Array_expr_andContext::const_expr() {
  return getRuleContext<LustreParser::Const_exprContext>(0);
}

LustreParser::Array_expr_andContext::Array_expr_andContext(Array_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Array_expr_andContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArray_expr_and(this);
}
void LustreParser::Array_expr_andContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArray_expr_and(this);
}

std::any LustreParser::Array_expr_andContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitArray_expr_and(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Array_expr_listContext ------------------------------------------------------------------

std::vector<LustreParser::ListContext *> LustreParser::Array_expr_listContext::list() {
  return getRuleContexts<LustreParser::ListContext>();
}

LustreParser::ListContext* LustreParser::Array_expr_listContext::list(size_t i) {
  return getRuleContext<LustreParser::ListContext>(i);
}

LustreParser::Array_expr_listContext::Array_expr_listContext(Array_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Array_expr_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArray_expr_list(this);
}
void LustreParser::Array_expr_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArray_expr_list(this);
}

std::any LustreParser::Array_expr_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitArray_expr_list(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Array_expr_dynamicContext ------------------------------------------------------------------

std::vector<LustreParser::Simple_exprContext *> LustreParser::Array_expr_dynamicContext::simple_expr() {
  return getRuleContexts<LustreParser::Simple_exprContext>();
}

LustreParser::Simple_exprContext* LustreParser::Array_expr_dynamicContext::simple_expr(size_t i) {
  return getRuleContext<LustreParser::Simple_exprContext>(i);
}

std::vector<LustreParser::IndexContext *> LustreParser::Array_expr_dynamicContext::index() {
  return getRuleContexts<LustreParser::IndexContext>();
}

LustreParser::IndexContext* LustreParser::Array_expr_dynamicContext::index(size_t i) {
  return getRuleContext<LustreParser::IndexContext>(i);
}

LustreParser::Array_expr_dynamicContext::Array_expr_dynamicContext(Array_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Array_expr_dynamicContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArray_expr_dynamic(this);
}
void LustreParser::Array_expr_dynamicContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArray_expr_dynamic(this);
}

std::any LustreParser::Array_expr_dynamicContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitArray_expr_dynamic(this);
  else
    return visitor->visitChildren(this);
}
LustreParser::Array_exprContext* LustreParser::array_expr() {
  Array_exprContext *_localctx = _tracker.createInstance<Array_exprContext>(_ctx, getState());
  enterRule(_localctx, 144, LustreParser::RuleArray_expr);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(1047);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 107, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<LustreParser::Array_expr_splitContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(1011);
      simple_expr(0);
      setState(1012);
      match(LustreParser::T__31);
      setState(1013);
      match(LustreParser::INTEGER);
      setState(1014);
      match(LustreParser::T__59);
      setState(1015);
      match(LustreParser::INTEGER);
      setState(1016);
      match(LustreParser::T__32);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<LustreParser::Array_expr_dynamicContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(1018);
      match(LustreParser::T__29);
      setState(1019);
      simple_expr(0);
      setState(1020);
      match(LustreParser::T__72);
      setState(1022); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(1021);
        index();
        setState(1024); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == LustreParser::T__31);
      setState(1026);
      match(LustreParser::T__73);
      setState(1027);
      simple_expr(0);
      setState(1028);
      match(LustreParser::T__30);
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<LustreParser::Array_expr_andContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(1030);
      simple_expr(0);
      setState(1031);
      match(LustreParser::T__26);
      setState(1032);
      const_expr(0);
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<LustreParser::Array_expr_listContext>(_localctx);
      enterOuterAlt(_localctx, 4);
      setState(1034);
      match(LustreParser::T__31);
      setState(1035);
      list();
      setState(1036);
      match(LustreParser::T__32);
      setState(1044);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 106, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1037);
          match(LustreParser::T__6);
          setState(1038);
          match(LustreParser::T__31);
          setState(1039);
          list();
          setState(1040);
          match(LustreParser::T__32); 
        }
        setState(1046);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 106, _ctx);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Struct_exprContext ------------------------------------------------------------------

LustreParser::Struct_exprContext::Struct_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<LustreParser::Label_exprContext *> LustreParser::Struct_exprContext::label_expr() {
  return getRuleContexts<LustreParser::Label_exprContext>();
}

LustreParser::Label_exprContext* LustreParser::Struct_exprContext::label_expr(size_t i) {
  return getRuleContext<LustreParser::Label_exprContext>(i);
}


size_t LustreParser::Struct_exprContext::getRuleIndex() const {
  return LustreParser::RuleStruct_expr;
}

void LustreParser::Struct_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStruct_expr(this);
}

void LustreParser::Struct_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStruct_expr(this);
}


std::any LustreParser::Struct_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitStruct_expr(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Struct_exprContext* LustreParser::struct_expr() {
  Struct_exprContext *_localctx = _tracker.createInstance<Struct_exprContext>(_ctx, getState());
  enterRule(_localctx, 146, LustreParser::RuleStruct_expr);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1049);
    match(LustreParser::T__15);
    setState(1050);
    label_expr();
    setState(1055);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == LustreParser::T__1

    || _la == LustreParser::T__6) {
      setState(1051);
      _la = _input->LA(1);
      if (!(_la == LustreParser::T__1

      || _la == LustreParser::T__6)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1052);
      label_expr();
      setState(1057);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1058);
    match(LustreParser::T__16);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Mixed_constructorContext ------------------------------------------------------------------

LustreParser::Mixed_constructorContext::Mixed_constructorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LustreParser::Mixed_constructorContext::ID() {
  return getToken(LustreParser::ID, 0);
}

LustreParser::Simple_exprContext* LustreParser::Mixed_constructorContext::simple_expr() {
  return getRuleContext<LustreParser::Simple_exprContext>(0);
}

std::vector<LustreParser::Label_or_indexContext *> LustreParser::Mixed_constructorContext::label_or_index() {
  return getRuleContexts<LustreParser::Label_or_indexContext>();
}

LustreParser::Label_or_indexContext* LustreParser::Mixed_constructorContext::label_or_index(size_t i) {
  return getRuleContext<LustreParser::Label_or_indexContext>(i);
}


size_t LustreParser::Mixed_constructorContext::getRuleIndex() const {
  return LustreParser::RuleMixed_constructor;
}

void LustreParser::Mixed_constructorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMixed_constructor(this);
}

void LustreParser::Mixed_constructorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMixed_constructor(this);
}


std::any LustreParser::Mixed_constructorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitMixed_constructor(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Mixed_constructorContext* LustreParser::mixed_constructor() {
  Mixed_constructorContext *_localctx = _tracker.createInstance<Mixed_constructorContext>(_ctx, getState());
  enterRule(_localctx, 148, LustreParser::RuleMixed_constructor);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1060);
    match(LustreParser::T__29);
    setState(1061);
    match(LustreParser::ID);
    setState(1062);
    match(LustreParser::T__74);
    setState(1064); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(1063);
      label_or_index();
      setState(1066); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == LustreParser::T__31

    || _la == LustreParser::T__72);
    setState(1068);
    match(LustreParser::T__7);
    setState(1069);
    simple_expr(0);
    setState(1070);
    match(LustreParser::T__30);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Label_exprContext ------------------------------------------------------------------

LustreParser::Label_exprContext::Label_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LustreParser::Label_exprContext::ID() {
  return getToken(LustreParser::ID, 0);
}

LustreParser::Simple_exprContext* LustreParser::Label_exprContext::simple_expr() {
  return getRuleContext<LustreParser::Simple_exprContext>(0);
}


size_t LustreParser::Label_exprContext::getRuleIndex() const {
  return LustreParser::RuleLabel_expr;
}

void LustreParser::Label_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLabel_expr(this);
}

void LustreParser::Label_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLabel_expr(this);
}


std::any LustreParser::Label_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitLabel_expr(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Label_exprContext* LustreParser::label_expr() {
  Label_exprContext *_localctx = _tracker.createInstance<Label_exprContext>(_ctx, getState());
  enterRule(_localctx, 150, LustreParser::RuleLabel_expr);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1072);
    match(LustreParser::ID);
    setState(1073);
    match(LustreParser::T__27);
    setState(1074);
    simple_expr(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexContext ------------------------------------------------------------------

LustreParser::IndexContext::IndexContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LustreParser::Simple_exprContext* LustreParser::IndexContext::simple_expr() {
  return getRuleContext<LustreParser::Simple_exprContext>(0);
}


size_t LustreParser::IndexContext::getRuleIndex() const {
  return LustreParser::RuleIndex;
}

void LustreParser::IndexContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndex(this);
}

void LustreParser::IndexContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndex(this);
}


std::any LustreParser::IndexContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitIndex(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::IndexContext* LustreParser::index() {
  IndexContext *_localctx = _tracker.createInstance<IndexContext>(_ctx, getState());
  enterRule(_localctx, 152, LustreParser::RuleIndex);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1076);
    match(LustreParser::T__31);
    setState(1077);
    simple_expr(0);
    setState(1078);
    match(LustreParser::T__32);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Label_or_indexContext ------------------------------------------------------------------

LustreParser::Label_or_indexContext::Label_or_indexContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::Label_or_indexContext::getRuleIndex() const {
  return LustreParser::RuleLabel_or_index;
}

void LustreParser::Label_or_indexContext::copyFrom(Label_or_indexContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Mix_labelContext ------------------------------------------------------------------

tree::TerminalNode* LustreParser::Mix_labelContext::ID() {
  return getToken(LustreParser::ID, 0);
}

LustreParser::Mix_labelContext::Mix_labelContext(Label_or_indexContext *ctx) { copyFrom(ctx); }

void LustreParser::Mix_labelContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMix_label(this);
}
void LustreParser::Mix_labelContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMix_label(this);
}

std::any LustreParser::Mix_labelContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitMix_label(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Mix_indexContext ------------------------------------------------------------------

LustreParser::IndexContext* LustreParser::Mix_indexContext::index() {
  return getRuleContext<LustreParser::IndexContext>(0);
}

LustreParser::Mix_indexContext::Mix_indexContext(Label_or_indexContext *ctx) { copyFrom(ctx); }

void LustreParser::Mix_indexContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMix_index(this);
}
void LustreParser::Mix_indexContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMix_index(this);
}

std::any LustreParser::Mix_indexContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitMix_index(this);
  else
    return visitor->visitChildren(this);
}
LustreParser::Label_or_indexContext* LustreParser::label_or_index() {
  Label_or_indexContext *_localctx = _tracker.createInstance<Label_or_indexContext>(_ctx, getState());
  enterRule(_localctx, 154, LustreParser::RuleLabel_or_index);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1083);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LustreParser::T__72: {
        _localctx = _tracker.createInstance<LustreParser::Mix_labelContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(1080);
        match(LustreParser::T__72);
        setState(1081);
        match(LustreParser::ID);
        break;
      }

      case LustreParser::T__31: {
        _localctx = _tracker.createInstance<LustreParser::Mix_indexContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(1082);
        index();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Switch_exprContext ------------------------------------------------------------------

LustreParser::Switch_exprContext::Switch_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::Switch_exprContext::getRuleIndex() const {
  return LustreParser::RuleSwitch_expr;
}

void LustreParser::Switch_exprContext::copyFrom(Switch_exprContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Switch_expr_ifelseContext ------------------------------------------------------------------

std::vector<LustreParser::Simple_exprContext *> LustreParser::Switch_expr_ifelseContext::simple_expr() {
  return getRuleContexts<LustreParser::Simple_exprContext>();
}

LustreParser::Simple_exprContext* LustreParser::Switch_expr_ifelseContext::simple_expr(size_t i) {
  return getRuleContext<LustreParser::Simple_exprContext>(i);
}

LustreParser::Switch_expr_ifelseContext::Switch_expr_ifelseContext(Switch_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Switch_expr_ifelseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSwitch_expr_ifelse(this);
}
void LustreParser::Switch_expr_ifelseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSwitch_expr_ifelse(this);
}

std::any LustreParser::Switch_expr_ifelseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitSwitch_expr_ifelse(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Switch_expr_caseContext ------------------------------------------------------------------

LustreParser::Simple_exprContext* LustreParser::Switch_expr_caseContext::simple_expr() {
  return getRuleContext<LustreParser::Simple_exprContext>(0);
}

std::vector<LustreParser::Case_exprContext *> LustreParser::Switch_expr_caseContext::case_expr() {
  return getRuleContexts<LustreParser::Case_exprContext>();
}

LustreParser::Case_exprContext* LustreParser::Switch_expr_caseContext::case_expr(size_t i) {
  return getRuleContext<LustreParser::Case_exprContext>(i);
}

LustreParser::Switch_expr_caseContext::Switch_expr_caseContext(Switch_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Switch_expr_caseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSwitch_expr_case(this);
}
void LustreParser::Switch_expr_caseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSwitch_expr_case(this);
}

std::any LustreParser::Switch_expr_caseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitSwitch_expr_case(this);
  else
    return visitor->visitChildren(this);
}
LustreParser::Switch_exprContext* LustreParser::switch_expr() {
  Switch_exprContext *_localctx = _tracker.createInstance<Switch_exprContext>(_ctx, getState());
  enterRule(_localctx, 156, LustreParser::RuleSwitch_expr);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1103);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LustreParser::T__53: {
        _localctx = _tracker.createInstance<LustreParser::Switch_expr_ifelseContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(1085);
        match(LustreParser::T__53);
        setState(1086);
        simple_expr(0);
        setState(1087);
        match(LustreParser::T__54);
        setState(1088);
        simple_expr(0);
        setState(1089);
        match(LustreParser::T__56);
        setState(1090);
        simple_expr(0);
        break;
      }

      case LustreParser::T__29: {
        _localctx = _tracker.createInstance<LustreParser::Switch_expr_caseContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(1092);
        match(LustreParser::T__29);
        setState(1093);
        match(LustreParser::T__75);
        setState(1094);
        simple_expr(0);
        setState(1095);
        match(LustreParser::T__76);
        setState(1097); 
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(1096);
          case_expr();
          setState(1099); 
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while (_la == LustreParser::T__77);
        setState(1101);
        match(LustreParser::T__30);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Case_exprContext ------------------------------------------------------------------

LustreParser::Case_exprContext::Case_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LustreParser::PatternContext* LustreParser::Case_exprContext::pattern() {
  return getRuleContext<LustreParser::PatternContext>(0);
}

LustreParser::Simple_exprContext* LustreParser::Case_exprContext::simple_expr() {
  return getRuleContext<LustreParser::Simple_exprContext>(0);
}


size_t LustreParser::Case_exprContext::getRuleIndex() const {
  return LustreParser::RuleCase_expr;
}

void LustreParser::Case_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCase_expr(this);
}

void LustreParser::Case_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCase_expr(this);
}


std::any LustreParser::Case_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitCase_expr(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Case_exprContext* LustreParser::case_expr() {
  Case_exprContext *_localctx = _tracker.createInstance<Case_exprContext>(_ctx, getState());
  enterRule(_localctx, 158, LustreParser::RuleCase_expr);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1105);
    match(LustreParser::T__77);
    setState(1106);
    pattern();
    setState(1107);
    match(LustreParser::T__27);
    setState(1108);
    simple_expr(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PatternContext ------------------------------------------------------------------

LustreParser::PatternContext::PatternContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LustreParser::PatternContext::ID() {
  return getToken(LustreParser::ID, 0);
}

tree::TerminalNode* LustreParser::PatternContext::CHAR() {
  return getToken(LustreParser::CHAR, 0);
}

tree::TerminalNode* LustreParser::PatternContext::INTEGER() {
  return getToken(LustreParser::INTEGER, 0);
}

tree::TerminalNode* LustreParser::PatternContext::BOOL() {
  return getToken(LustreParser::BOOL, 0);
}


size_t LustreParser::PatternContext::getRuleIndex() const {
  return LustreParser::RulePattern;
}

void LustreParser::PatternContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPattern(this);
}

void LustreParser::PatternContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPattern(this);
}


std::any LustreParser::PatternContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitPattern(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::PatternContext* LustreParser::pattern() {
  PatternContext *_localctx = _tracker.createInstance<PatternContext>(_ctx, getState());
  enterRule(_localctx, 160, LustreParser::RulePattern);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1118);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LustreParser::ID: {
        enterOuterAlt(_localctx, 1);
        setState(1110);
        match(LustreParser::ID);
        break;
      }

      case LustreParser::CHAR: {
        enterOuterAlt(_localctx, 2);
        setState(1111);
        match(LustreParser::CHAR);
        break;
      }

      case LustreParser::T__78:
      case LustreParser::INTEGER: {
        enterOuterAlt(_localctx, 3);
        setState(1113);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == LustreParser::T__78) {
          setState(1112);
          match(LustreParser::T__78);
        }
        setState(1115);
        match(LustreParser::INTEGER);
        break;
      }

      case LustreParser::BOOL: {
        enterOuterAlt(_localctx, 4);
        setState(1116);
        match(LustreParser::BOOL);
        break;
      }

      case LustreParser::T__79: {
        enterOuterAlt(_localctx, 5);
        setState(1117);
        match(LustreParser::T__79);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Apply_exprContext ------------------------------------------------------------------

LustreParser::Apply_exprContext::Apply_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::Apply_exprContext::getRuleIndex() const {
  return LustreParser::RuleApply_expr;
}

void LustreParser::Apply_exprContext::copyFrom(Apply_exprContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Apply_prefixContext ------------------------------------------------------------------

LustreParser::Prefix_operatorContext* LustreParser::Apply_prefixContext::prefix_operator() {
  return getRuleContext<LustreParser::Prefix_operatorContext>(0);
}

LustreParser::ListContext* LustreParser::Apply_prefixContext::list() {
  return getRuleContext<LustreParser::ListContext>(0);
}

LustreParser::Apply_prefixContext::Apply_prefixContext(Apply_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Apply_prefixContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterApply_prefix(this);
}
void LustreParser::Apply_prefixContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitApply_prefix(this);
}

std::any LustreParser::Apply_prefixContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitApply_prefix(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Apply_mapContext ------------------------------------------------------------------

LustreParser::Prefix_operatorContext* LustreParser::Apply_mapContext::prefix_operator() {
  return getRuleContext<LustreParser::Prefix_operatorContext>(0);
}

LustreParser::Const_exprContext* LustreParser::Apply_mapContext::const_expr() {
  return getRuleContext<LustreParser::Const_exprContext>(0);
}

LustreParser::ListContext* LustreParser::Apply_mapContext::list() {
  return getRuleContext<LustreParser::ListContext>(0);
}

LustreParser::Apply_mapContext::Apply_mapContext(Apply_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Apply_mapContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterApply_map(this);
}
void LustreParser::Apply_mapContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitApply_map(this);
}

std::any LustreParser::Apply_mapContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitApply_map(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Apply_mapwiContext ------------------------------------------------------------------

LustreParser::Prefix_operatorContext* LustreParser::Apply_mapwiContext::prefix_operator() {
  return getRuleContext<LustreParser::Prefix_operatorContext>(0);
}

LustreParser::Const_exprContext* LustreParser::Apply_mapwiContext::const_expr() {
  return getRuleContext<LustreParser::Const_exprContext>(0);
}

LustreParser::Simple_exprContext* LustreParser::Apply_mapwiContext::simple_expr() {
  return getRuleContext<LustreParser::Simple_exprContext>(0);
}

std::vector<LustreParser::ListContext *> LustreParser::Apply_mapwiContext::list() {
  return getRuleContexts<LustreParser::ListContext>();
}

LustreParser::ListContext* LustreParser::Apply_mapwiContext::list(size_t i) {
  return getRuleContext<LustreParser::ListContext>(i);
}

LustreParser::Apply_mapwiContext::Apply_mapwiContext(Apply_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Apply_mapwiContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterApply_mapwi(this);
}
void LustreParser::Apply_mapwiContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitApply_mapwi(this);
}

std::any LustreParser::Apply_mapwiContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitApply_mapwi(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Apply_mapfoldContext ------------------------------------------------------------------

LustreParser::Prefix_operatorContext* LustreParser::Apply_mapfoldContext::prefix_operator() {
  return getRuleContext<LustreParser::Prefix_operatorContext>(0);
}

LustreParser::Const_exprContext* LustreParser::Apply_mapfoldContext::const_expr() {
  return getRuleContext<LustreParser::Const_exprContext>(0);
}

LustreParser::ListContext* LustreParser::Apply_mapfoldContext::list() {
  return getRuleContext<LustreParser::ListContext>(0);
}

LustreParser::Apply_mapfoldContext::Apply_mapfoldContext(Apply_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Apply_mapfoldContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterApply_mapfold(this);
}
void LustreParser::Apply_mapfoldContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitApply_mapfold(this);
}

std::any LustreParser::Apply_mapfoldContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitApply_mapfold(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Apply_foldContext ------------------------------------------------------------------

LustreParser::Prefix_operatorContext* LustreParser::Apply_foldContext::prefix_operator() {
  return getRuleContext<LustreParser::Prefix_operatorContext>(0);
}

LustreParser::Const_exprContext* LustreParser::Apply_foldContext::const_expr() {
  return getRuleContext<LustreParser::Const_exprContext>(0);
}

LustreParser::ListContext* LustreParser::Apply_foldContext::list() {
  return getRuleContext<LustreParser::ListContext>(0);
}

LustreParser::Apply_foldContext::Apply_foldContext(Apply_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Apply_foldContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterApply_fold(this);
}
void LustreParser::Apply_foldContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitApply_fold(this);
}

std::any LustreParser::Apply_foldContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitApply_fold(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Apply_mapwContext ------------------------------------------------------------------

LustreParser::Prefix_operatorContext* LustreParser::Apply_mapwContext::prefix_operator() {
  return getRuleContext<LustreParser::Prefix_operatorContext>(0);
}

LustreParser::Const_exprContext* LustreParser::Apply_mapwContext::const_expr() {
  return getRuleContext<LustreParser::Const_exprContext>(0);
}

LustreParser::Simple_exprContext* LustreParser::Apply_mapwContext::simple_expr() {
  return getRuleContext<LustreParser::Simple_exprContext>(0);
}

std::vector<LustreParser::ListContext *> LustreParser::Apply_mapwContext::list() {
  return getRuleContexts<LustreParser::ListContext>();
}

LustreParser::ListContext* LustreParser::Apply_mapwContext::list(size_t i) {
  return getRuleContext<LustreParser::ListContext>(i);
}

LustreParser::Apply_mapwContext::Apply_mapwContext(Apply_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Apply_mapwContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterApply_mapw(this);
}
void LustreParser::Apply_mapwContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitApply_mapw(this);
}

std::any LustreParser::Apply_mapwContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitApply_mapw(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Apply_foldwContext ------------------------------------------------------------------

LustreParser::Prefix_operatorContext* LustreParser::Apply_foldwContext::prefix_operator() {
  return getRuleContext<LustreParser::Prefix_operatorContext>(0);
}

LustreParser::Const_exprContext* LustreParser::Apply_foldwContext::const_expr() {
  return getRuleContext<LustreParser::Const_exprContext>(0);
}

LustreParser::Simple_exprContext* LustreParser::Apply_foldwContext::simple_expr() {
  return getRuleContext<LustreParser::Simple_exprContext>(0);
}

LustreParser::ListContext* LustreParser::Apply_foldwContext::list() {
  return getRuleContext<LustreParser::ListContext>(0);
}

LustreParser::Apply_foldwContext::Apply_foldwContext(Apply_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Apply_foldwContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterApply_foldw(this);
}
void LustreParser::Apply_foldwContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitApply_foldw(this);
}

std::any LustreParser::Apply_foldwContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitApply_foldw(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Apply_foldwiContext ------------------------------------------------------------------

LustreParser::Prefix_operatorContext* LustreParser::Apply_foldwiContext::prefix_operator() {
  return getRuleContext<LustreParser::Prefix_operatorContext>(0);
}

LustreParser::Const_exprContext* LustreParser::Apply_foldwiContext::const_expr() {
  return getRuleContext<LustreParser::Const_exprContext>(0);
}

LustreParser::Simple_exprContext* LustreParser::Apply_foldwiContext::simple_expr() {
  return getRuleContext<LustreParser::Simple_exprContext>(0);
}

LustreParser::ListContext* LustreParser::Apply_foldwiContext::list() {
  return getRuleContext<LustreParser::ListContext>(0);
}

LustreParser::Apply_foldwiContext::Apply_foldwiContext(Apply_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Apply_foldwiContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterApply_foldwi(this);
}
void LustreParser::Apply_foldwiContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitApply_foldwi(this);
}

std::any LustreParser::Apply_foldwiContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitApply_foldwi(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Apply_mapiContext ------------------------------------------------------------------

LustreParser::Prefix_operatorContext* LustreParser::Apply_mapiContext::prefix_operator() {
  return getRuleContext<LustreParser::Prefix_operatorContext>(0);
}

LustreParser::Const_exprContext* LustreParser::Apply_mapiContext::const_expr() {
  return getRuleContext<LustreParser::Const_exprContext>(0);
}

LustreParser::ListContext* LustreParser::Apply_mapiContext::list() {
  return getRuleContext<LustreParser::ListContext>(0);
}

LustreParser::Apply_mapiContext::Apply_mapiContext(Apply_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Apply_mapiContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterApply_mapi(this);
}
void LustreParser::Apply_mapiContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitApply_mapi(this);
}

std::any LustreParser::Apply_mapiContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitApply_mapi(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Apply_foldiContext ------------------------------------------------------------------

LustreParser::Prefix_operatorContext* LustreParser::Apply_foldiContext::prefix_operator() {
  return getRuleContext<LustreParser::Prefix_operatorContext>(0);
}

LustreParser::Const_exprContext* LustreParser::Apply_foldiContext::const_expr() {
  return getRuleContext<LustreParser::Const_exprContext>(0);
}

LustreParser::ListContext* LustreParser::Apply_foldiContext::list() {
  return getRuleContext<LustreParser::ListContext>(0);
}

LustreParser::Apply_foldiContext::Apply_foldiContext(Apply_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Apply_foldiContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterApply_foldi(this);
}
void LustreParser::Apply_foldiContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitApply_foldi(this);
}

std::any LustreParser::Apply_foldiContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitApply_foldi(this);
  else
    return visitor->visitChildren(this);
}
LustreParser::Apply_exprContext* LustreParser::apply_expr() {
  Apply_exprContext *_localctx = _tracker.createInstance<Apply_exprContext>(_ctx, getState());
  enterRule(_localctx, 162, LustreParser::RuleApply_expr);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1231);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LustreParser::T__29:
      case LustreParser::T__93:
      case LustreParser::T__94:
      case LustreParser::T__95:
      case LustreParser::T__96:
      case LustreParser::T__97:
      case LustreParser::T__98:
      case LustreParser::T__99:
      case LustreParser::T__100:
      case LustreParser::T__101:
      case LustreParser::T__102:
      case LustreParser::T__103:
      case LustreParser::T__104:
      case LustreParser::T__105:
      case LustreParser::T__106:
      case LustreParser::T__107:
      case LustreParser::T__108:
      case LustreParser::T__109:
      case LustreParser::T__110:
      case LustreParser::T__111:
      case LustreParser::T__112:
      case LustreParser::T__113:
      case LustreParser::T__114:
      case LustreParser::ID: {
        _localctx = _tracker.createInstance<LustreParser::Apply_prefixContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(1120);
        prefix_operator();
        setState(1121);
        match(LustreParser::T__29);
        setState(1122);
        list();
        setState(1123);
        match(LustreParser::T__30);
        break;
      }

      case LustreParser::T__80: {
        _localctx = _tracker.createInstance<LustreParser::Apply_mapContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(1125);
        match(LustreParser::T__80);
        setState(1126);
        match(LustreParser::T__81);
        setState(1127);
        prefix_operator();
        setState(1128);
        match(LustreParser::T__1);
        setState(1129);
        const_expr(0);
        setState(1130);
        match(LustreParser::T__82);
        setState(1131);
        match(LustreParser::T__29);
        setState(1132);
        list();
        setState(1133);
        match(LustreParser::T__30);
        break;
      }

      case LustreParser::T__83: {
        _localctx = _tracker.createInstance<LustreParser::Apply_foldContext>(_localctx);
        enterOuterAlt(_localctx, 3);
        setState(1135);
        match(LustreParser::T__83);
        setState(1136);
        match(LustreParser::T__81);
        setState(1137);
        prefix_operator();
        setState(1138);
        match(LustreParser::T__1);
        setState(1139);
        const_expr(0);
        setState(1140);
        match(LustreParser::T__82);
        setState(1141);
        match(LustreParser::T__29);
        setState(1142);
        list();
        setState(1143);
        match(LustreParser::T__30);
        break;
      }

      case LustreParser::T__84: {
        _localctx = _tracker.createInstance<LustreParser::Apply_mapiContext>(_localctx);
        enterOuterAlt(_localctx, 4);
        setState(1145);
        match(LustreParser::T__84);
        setState(1146);
        match(LustreParser::T__81);
        setState(1147);
        prefix_operator();
        setState(1148);
        match(LustreParser::T__1);
        setState(1149);
        const_expr(0);
        setState(1150);
        match(LustreParser::T__82);
        setState(1151);
        match(LustreParser::T__29);
        setState(1152);
        list();
        setState(1153);
        match(LustreParser::T__30);
        break;
      }

      case LustreParser::T__85: {
        _localctx = _tracker.createInstance<LustreParser::Apply_foldiContext>(_localctx);
        enterOuterAlt(_localctx, 5);
        setState(1155);
        match(LustreParser::T__85);
        setState(1156);
        match(LustreParser::T__81);
        setState(1157);
        prefix_operator();
        setState(1158);
        match(LustreParser::T__1);
        setState(1159);
        const_expr(0);
        setState(1160);
        match(LustreParser::T__82);
        setState(1161);
        match(LustreParser::T__29);
        setState(1162);
        list();
        setState(1163);
        match(LustreParser::T__30);
        break;
      }

      case LustreParser::T__86: {
        _localctx = _tracker.createInstance<LustreParser::Apply_mapfoldContext>(_localctx);
        enterOuterAlt(_localctx, 6);
        setState(1165);
        match(LustreParser::T__86);
        setState(1166);
        match(LustreParser::T__81);
        setState(1167);
        prefix_operator();
        setState(1168);
        match(LustreParser::T__1);
        setState(1169);
        const_expr(0);
        setState(1170);
        match(LustreParser::T__82);
        setState(1171);
        match(LustreParser::T__29);
        setState(1172);
        list();
        setState(1173);
        match(LustreParser::T__30);
        break;
      }

      case LustreParser::T__87: {
        _localctx = _tracker.createInstance<LustreParser::Apply_mapwContext>(_localctx);
        enterOuterAlt(_localctx, 7);
        setState(1175);
        match(LustreParser::T__87);
        setState(1176);
        match(LustreParser::T__81);
        setState(1177);
        prefix_operator();
        setState(1178);
        match(LustreParser::T__1);
        setState(1179);
        const_expr(0);
        setState(1180);
        match(LustreParser::T__82);
        setState(1181);
        match(LustreParser::T__53);
        setState(1182);
        simple_expr(0);
        setState(1183);
        match(LustreParser::T__73);
        setState(1184);
        match(LustreParser::T__29);
        setState(1185);
        list();
        setState(1186);
        match(LustreParser::T__30);
        setState(1187);
        match(LustreParser::T__29);
        setState(1188);
        list();
        setState(1189);
        match(LustreParser::T__30);
        break;
      }

      case LustreParser::T__88: {
        _localctx = _tracker.createInstance<LustreParser::Apply_mapwiContext>(_localctx);
        enterOuterAlt(_localctx, 8);
        setState(1191);
        match(LustreParser::T__88);
        setState(1192);
        match(LustreParser::T__81);
        setState(1193);
        prefix_operator();
        setState(1194);
        match(LustreParser::T__1);
        setState(1195);
        const_expr(0);
        setState(1196);
        match(LustreParser::T__82);
        setState(1197);
        match(LustreParser::T__53);
        setState(1198);
        simple_expr(0);
        setState(1199);
        match(LustreParser::T__73);
        setState(1200);
        match(LustreParser::T__29);
        setState(1201);
        list();
        setState(1202);
        match(LustreParser::T__30);
        setState(1203);
        match(LustreParser::T__29);
        setState(1204);
        list();
        setState(1205);
        match(LustreParser::T__30);
        break;
      }

      case LustreParser::T__89: {
        _localctx = _tracker.createInstance<LustreParser::Apply_foldwContext>(_localctx);
        enterOuterAlt(_localctx, 9);
        setState(1207);
        match(LustreParser::T__89);
        setState(1208);
        match(LustreParser::T__81);
        setState(1209);
        prefix_operator();
        setState(1210);
        match(LustreParser::T__1);
        setState(1211);
        const_expr(0);
        setState(1212);
        match(LustreParser::T__82);
        setState(1213);
        match(LustreParser::T__53);
        setState(1214);
        simple_expr(0);
        setState(1215);
        match(LustreParser::T__29);
        setState(1216);
        list();
        setState(1217);
        match(LustreParser::T__30);
        break;
      }

      case LustreParser::T__90: {
        _localctx = _tracker.createInstance<LustreParser::Apply_foldwiContext>(_localctx);
        enterOuterAlt(_localctx, 10);
        setState(1219);
        match(LustreParser::T__90);
        setState(1220);
        match(LustreParser::T__81);
        setState(1221);
        prefix_operator();
        setState(1222);
        match(LustreParser::T__1);
        setState(1223);
        const_expr(0);
        setState(1224);
        match(LustreParser::T__82);
        setState(1225);
        match(LustreParser::T__53);
        setState(1226);
        simple_expr(0);
        setState(1227);
        match(LustreParser::T__29);
        setState(1228);
        list();
        setState(1229);
        match(LustreParser::T__30);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Prefix_operatorContext ------------------------------------------------------------------

LustreParser::Prefix_operatorContext::Prefix_operatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::Prefix_operatorContext::getRuleIndex() const {
  return LustreParser::RulePrefix_operator;
}

void LustreParser::Prefix_operatorContext::copyFrom(Prefix_operatorContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Perfix_flattenContext ------------------------------------------------------------------

tree::TerminalNode* LustreParser::Perfix_flattenContext::ID() {
  return getToken(LustreParser::ID, 0);
}

LustreParser::Perfix_flattenContext::Perfix_flattenContext(Prefix_operatorContext *ctx) { copyFrom(ctx); }

void LustreParser::Perfix_flattenContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPerfix_flatten(this);
}
void LustreParser::Perfix_flattenContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPerfix_flatten(this);
}

std::any LustreParser::Perfix_flattenContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitPerfix_flatten(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Prefix_unaryContext ------------------------------------------------------------------

LustreParser::Prefix_unary_operatorContext* LustreParser::Prefix_unaryContext::prefix_unary_operator() {
  return getRuleContext<LustreParser::Prefix_unary_operatorContext>(0);
}

LustreParser::Prefix_unaryContext::Prefix_unaryContext(Prefix_operatorContext *ctx) { copyFrom(ctx); }

void LustreParser::Prefix_unaryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrefix_unary(this);
}
void LustreParser::Prefix_unaryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrefix_unary(this);
}

std::any LustreParser::Prefix_unaryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitPrefix_unary(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Perfix_IDContext ------------------------------------------------------------------

tree::TerminalNode* LustreParser::Perfix_IDContext::ID() {
  return getToken(LustreParser::ID, 0);
}

LustreParser::Perfix_IDContext::Perfix_IDContext(Prefix_operatorContext *ctx) { copyFrom(ctx); }

void LustreParser::Perfix_IDContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPerfix_ID(this);
}
void LustreParser::Perfix_IDContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPerfix_ID(this);
}

std::any LustreParser::Perfix_IDContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitPerfix_ID(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Prefix_binaryContext ------------------------------------------------------------------

LustreParser::Prefix_binary_operatorContext* LustreParser::Prefix_binaryContext::prefix_binary_operator() {
  return getRuleContext<LustreParser::Prefix_binary_operatorContext>(0);
}

LustreParser::Prefix_binaryContext::Prefix_binaryContext(Prefix_operatorContext *ctx) { copyFrom(ctx); }

void LustreParser::Prefix_binaryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrefix_binary(this);
}
void LustreParser::Prefix_binaryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrefix_binary(this);
}

std::any LustreParser::Prefix_binaryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitPrefix_binary(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Perfix_makeContext ------------------------------------------------------------------

tree::TerminalNode* LustreParser::Perfix_makeContext::ID() {
  return getToken(LustreParser::ID, 0);
}

LustreParser::Perfix_makeContext::Perfix_makeContext(Prefix_operatorContext *ctx) { copyFrom(ctx); }

void LustreParser::Perfix_makeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPerfix_make(this);
}
void LustreParser::Perfix_makeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPerfix_make(this);
}

std::any LustreParser::Perfix_makeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitPerfix_make(this);
  else
    return visitor->visitChildren(this);
}
LustreParser::Prefix_operatorContext* LustreParser::prefix_operator() {
  Prefix_operatorContext *_localctx = _tracker.createInstance<Prefix_operatorContext>(_ctx, getState());
  enterRule(_localctx, 164, LustreParser::RulePrefix_operator);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1244);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 116, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<LustreParser::Perfix_IDContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(1233);
      match(LustreParser::ID);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<LustreParser::Prefix_unaryContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(1234);
      prefix_unary_operator();
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<LustreParser::Prefix_binaryContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(1235);
      prefix_binary_operator();
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<LustreParser::Perfix_makeContext>(_localctx);
      enterOuterAlt(_localctx, 4);
      setState(1236);
      match(LustreParser::T__29);
      setState(1237);
      match(LustreParser::T__91);
      setState(1238);
      match(LustreParser::ID);
      setState(1239);
      match(LustreParser::T__30);
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<LustreParser::Perfix_flattenContext>(_localctx);
      enterOuterAlt(_localctx, 5);
      setState(1240);
      match(LustreParser::T__29);
      setState(1241);
      match(LustreParser::T__92);
      setState(1242);
      match(LustreParser::ID);
      setState(1243);
      match(LustreParser::T__30);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Prefix_unary_operatorContext ------------------------------------------------------------------

LustreParser::Prefix_unary_operatorContext::Prefix_unary_operatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::Prefix_unary_operatorContext::getRuleIndex() const {
  return LustreParser::RulePrefix_unary_operator;
}

void LustreParser::Prefix_unary_operatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrefix_unary_operator(this);
}

void LustreParser::Prefix_unary_operatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrefix_unary_operator(this);
}


std::any LustreParser::Prefix_unary_operatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitPrefix_unary_operator(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Prefix_unary_operatorContext* LustreParser::prefix_unary_operator() {
  Prefix_unary_operatorContext *_localctx = _tracker.createInstance<Prefix_unary_operatorContext>(_ctx, getState());
  enterRule(_localctx, 166, LustreParser::RulePrefix_unary_operator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1246);
    _la = _input->LA(1);
    if (!(((((_la - 94) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 94)) & 127) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Prefix_binary_operatorContext ------------------------------------------------------------------

LustreParser::Prefix_binary_operatorContext::Prefix_binary_operatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::Prefix_binary_operatorContext::getRuleIndex() const {
  return LustreParser::RulePrefix_binary_operator;
}

void LustreParser::Prefix_binary_operatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrefix_binary_operator(this);
}

void LustreParser::Prefix_binary_operatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrefix_binary_operator(this);
}


std::any LustreParser::Prefix_binary_operatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitPrefix_binary_operator(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Prefix_binary_operatorContext* LustreParser::prefix_binary_operator() {
  Prefix_binary_operatorContext *_localctx = _tracker.createInstance<Prefix_binary_operatorContext>(_ctx, getState());
  enterRule(_localctx, 168, LustreParser::RulePrefix_binary_operator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1248);
    _la = _input->LA(1);
    if (!(((((_la - 101) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 101)) & 32767) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Simple_exprContext ------------------------------------------------------------------

LustreParser::Simple_exprContext::Simple_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::Simple_exprContext::getRuleIndex() const {
  return LustreParser::RuleSimple_expr;
}

void LustreParser::Simple_exprContext::copyFrom(Simple_exprContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Simple_expr_unary_arithContext ------------------------------------------------------------------

LustreParser::Unary_arith_opContext* LustreParser::Simple_expr_unary_arithContext::unary_arith_op() {
  return getRuleContext<LustreParser::Unary_arith_opContext>(0);
}

LustreParser::Simple_exprContext* LustreParser::Simple_expr_unary_arithContext::simple_expr() {
  return getRuleContext<LustreParser::Simple_exprContext>(0);
}

LustreParser::Simple_expr_unary_arithContext::Simple_expr_unary_arithContext(Simple_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Simple_expr_unary_arithContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimple_expr_unary_arith(this);
}
void LustreParser::Simple_expr_unary_arithContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimple_expr_unary_arith(this);
}

std::any LustreParser::Simple_expr_unary_arithContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitSimple_expr_unary_arith(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Simple_kind2_exprContext ------------------------------------------------------------------

LustreParser::Bin_relation_opContext* LustreParser::Simple_kind2_exprContext::bin_relation_op() {
  return getRuleContext<LustreParser::Bin_relation_opContext>(0);
}

LustreParser::Kind2_exprContext* LustreParser::Simple_kind2_exprContext::kind2_expr() {
  return getRuleContext<LustreParser::Kind2_exprContext>(0);
}

LustreParser::Simple_kind2_exprContext::Simple_kind2_exprContext(Simple_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Simple_kind2_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimple_kind2_expr(this);
}
void LustreParser::Simple_kind2_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimple_kind2_expr(this);
}

std::any LustreParser::Simple_kind2_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitSimple_kind2_expr(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Simple_expr_parenContext ------------------------------------------------------------------

std::vector<LustreParser::Simple_exprContext *> LustreParser::Simple_expr_parenContext::simple_expr() {
  return getRuleContexts<LustreParser::Simple_exprContext>();
}

LustreParser::Simple_exprContext* LustreParser::Simple_expr_parenContext::simple_expr(size_t i) {
  return getRuleContext<LustreParser::Simple_exprContext>(i);
}

LustreParser::Simple_expr_parenContext::Simple_expr_parenContext(Simple_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Simple_expr_parenContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimple_expr_paren(this);
}
void LustreParser::Simple_expr_parenContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimple_expr_paren(this);
}

std::any LustreParser::Simple_expr_parenContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitSimple_expr_paren(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Simple_expr_typeContext ------------------------------------------------------------------

LustreParser::TypeContext* LustreParser::Simple_expr_typeContext::type() {
  return getRuleContext<LustreParser::TypeContext>(0);
}

LustreParser::Simple_exprContext* LustreParser::Simple_expr_typeContext::simple_expr() {
  return getRuleContext<LustreParser::Simple_exprContext>(0);
}

LustreParser::Simple_expr_typeContext::Simple_expr_typeContext(Simple_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Simple_expr_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimple_expr_type(this);
}
void LustreParser::Simple_expr_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimple_expr_type(this);
}

std::any LustreParser::Simple_expr_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitSimple_expr_type(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Simple_expr_structContext ------------------------------------------------------------------

LustreParser::Simple_exprContext* LustreParser::Simple_expr_structContext::simple_expr() {
  return getRuleContext<LustreParser::Simple_exprContext>(0);
}

tree::TerminalNode* LustreParser::Simple_expr_structContext::ID() {
  return getToken(LustreParser::ID, 0);
}

LustreParser::Simple_expr_structContext::Simple_expr_structContext(Simple_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Simple_expr_structContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimple_expr_struct(this);
}
void LustreParser::Simple_expr_structContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimple_expr_struct(this);
}

std::any LustreParser::Simple_expr_structContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitSimple_expr_struct(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Simple_expr_bin_relationContext ------------------------------------------------------------------

std::vector<LustreParser::Simple_exprContext *> LustreParser::Simple_expr_bin_relationContext::simple_expr() {
  return getRuleContexts<LustreParser::Simple_exprContext>();
}

LustreParser::Simple_exprContext* LustreParser::Simple_expr_bin_relationContext::simple_expr(size_t i) {
  return getRuleContext<LustreParser::Simple_exprContext>(i);
}

LustreParser::Bin_relation_opContext* LustreParser::Simple_expr_bin_relationContext::bin_relation_op() {
  return getRuleContext<LustreParser::Bin_relation_opContext>(0);
}

LustreParser::Simple_expr_bin_relationContext::Simple_expr_bin_relationContext(Simple_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Simple_expr_bin_relationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimple_expr_bin_relation(this);
}
void LustreParser::Simple_expr_bin_relationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimple_expr_bin_relation(this);
}

std::any LustreParser::Simple_expr_bin_relationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitSimple_expr_bin_relation(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Simple_expr_atomContext ------------------------------------------------------------------

LustreParser::AtomContext* LustreParser::Simple_expr_atomContext::atom() {
  return getRuleContext<LustreParser::AtomContext>(0);
}

LustreParser::Simple_expr_atomContext::Simple_expr_atomContext(Simple_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Simple_expr_atomContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimple_expr_atom(this);
}
void LustreParser::Simple_expr_atomContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimple_expr_atom(this);
}

std::any LustreParser::Simple_expr_atomContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitSimple_expr_atom(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Simple_expr_bin_boolContext ------------------------------------------------------------------

std::vector<LustreParser::Simple_exprContext *> LustreParser::Simple_expr_bin_boolContext::simple_expr() {
  return getRuleContexts<LustreParser::Simple_exprContext>();
}

LustreParser::Simple_exprContext* LustreParser::Simple_expr_bin_boolContext::simple_expr(size_t i) {
  return getRuleContext<LustreParser::Simple_exprContext>(i);
}

LustreParser::Bin_bool_opContext* LustreParser::Simple_expr_bin_boolContext::bin_bool_op() {
  return getRuleContext<LustreParser::Bin_bool_opContext>(0);
}

LustreParser::Simple_expr_bin_boolContext::Simple_expr_bin_boolContext(Simple_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Simple_expr_bin_boolContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimple_expr_bin_bool(this);
}
void LustreParser::Simple_expr_bin_boolContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimple_expr_bin_bool(this);
}

std::any LustreParser::Simple_expr_bin_boolContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitSimple_expr_bin_bool(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Simple_expr_idContext ------------------------------------------------------------------

tree::TerminalNode* LustreParser::Simple_expr_idContext::ID() {
  return getToken(LustreParser::ID, 0);
}

LustreParser::Simple_expr_idContext::Simple_expr_idContext(Simple_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Simple_expr_idContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimple_expr_id(this);
}
void LustreParser::Simple_expr_idContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimple_expr_id(this);
}

std::any LustreParser::Simple_expr_idContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitSimple_expr_id(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Simple_expr_bin_arithContext ------------------------------------------------------------------

std::vector<LustreParser::Simple_exprContext *> LustreParser::Simple_expr_bin_arithContext::simple_expr() {
  return getRuleContexts<LustreParser::Simple_exprContext>();
}

LustreParser::Simple_exprContext* LustreParser::Simple_expr_bin_arithContext::simple_expr(size_t i) {
  return getRuleContext<LustreParser::Simple_exprContext>(i);
}

LustreParser::Bin_arith_opContext* LustreParser::Simple_expr_bin_arithContext::bin_arith_op() {
  return getRuleContext<LustreParser::Bin_arith_opContext>(0);
}

LustreParser::Simple_expr_bin_arithContext::Simple_expr_bin_arithContext(Simple_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Simple_expr_bin_arithContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimple_expr_bin_arith(this);
}
void LustreParser::Simple_expr_bin_arithContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimple_expr_bin_arith(this);
}

std::any LustreParser::Simple_expr_bin_arithContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitSimple_expr_bin_arith(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Simple_expr_arrayContext ------------------------------------------------------------------

LustreParser::Simple_exprContext* LustreParser::Simple_expr_arrayContext::simple_expr() {
  return getRuleContext<LustreParser::Simple_exprContext>(0);
}

LustreParser::Const_exprContext* LustreParser::Simple_expr_arrayContext::const_expr() {
  return getRuleContext<LustreParser::Const_exprContext>(0);
}

LustreParser::Simple_expr_arrayContext::Simple_expr_arrayContext(Simple_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Simple_expr_arrayContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimple_expr_array(this);
}
void LustreParser::Simple_expr_arrayContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimple_expr_array(this);
}

std::any LustreParser::Simple_expr_arrayContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitSimple_expr_array(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Simple_exprContext* LustreParser::simple_expr() {
   return simple_expr(0);
}

LustreParser::Simple_exprContext* LustreParser::simple_expr(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  LustreParser::Simple_exprContext *_localctx = _tracker.createInstance<Simple_exprContext>(_ctx, parentState);
  LustreParser::Simple_exprContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 170;
  enterRecursionRule(_localctx, 170, LustreParser::RuleSimple_expr, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1273);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 118, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<Simple_expr_idContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;

      setState(1251);
      match(LustreParser::ID);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<Simple_expr_atomContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1252);
      atom();
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<Simple_expr_parenContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1253);
      match(LustreParser::T__29);
      setState(1254);
      simple_expr(0);
      setState(1259);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == LustreParser::T__6) {
        setState(1255);
        match(LustreParser::T__6);
        setState(1256);
        simple_expr(0);
        setState(1261);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1262);
      match(LustreParser::T__30);
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<Simple_expr_unary_arithContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1264);
      unary_arith_op();
      setState(1265);
      simple_expr(6);
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<Simple_expr_typeContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1267);
      type(0);
      setState(1268);
      simple_expr(2);
      break;
    }

    case 6: {
      _localctx = _tracker.createInstance<Simple_kind2_exprContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1270);
      bin_relation_op();
      setState(1271);
      kind2_expr();
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(1297);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 120, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(1295);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 119, _ctx)) {
        case 1: {
          auto newContext = _tracker.createInstance<Simple_expr_bin_arithContext>(_tracker.createInstance<Simple_exprContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSimple_expr);
          setState(1275);

          if (!(precpred(_ctx, 5))) throw FailedPredicateException(this, "precpred(_ctx, 5)");
          setState(1276);
          bin_arith_op();
          setState(1277);
          simple_expr(6);
          break;
        }

        case 2: {
          auto newContext = _tracker.createInstance<Simple_expr_bin_boolContext>(_tracker.createInstance<Simple_exprContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSimple_expr);
          setState(1279);

          if (!(precpred(_ctx, 4))) throw FailedPredicateException(this, "precpred(_ctx, 4)");
          setState(1280);
          bin_bool_op();
          setState(1281);
          simple_expr(5);
          break;
        }

        case 3: {
          auto newContext = _tracker.createInstance<Simple_expr_bin_relationContext>(_tracker.createInstance<Simple_exprContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSimple_expr);
          setState(1283);

          if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
          setState(1284);
          bin_relation_op();
          setState(1285);
          simple_expr(4);
          break;
        }

        case 4: {
          auto newContext = _tracker.createInstance<Simple_expr_arrayContext>(_tracker.createInstance<Simple_exprContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSimple_expr);
          setState(1287);

          if (!(precpred(_ctx, 8))) throw FailedPredicateException(this, "precpred(_ctx, 8)");
          setState(1288);
          match(LustreParser::T__31);
          setState(1289);
          const_expr(0);
          setState(1290);
          match(LustreParser::T__32);
          break;
        }

        case 5: {
          auto newContext = _tracker.createInstance<Simple_expr_structContext>(_tracker.createInstance<Simple_exprContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSimple_expr);
          setState(1292);

          if (!(precpred(_ctx, 7))) throw FailedPredicateException(this, "precpred(_ctx, 7)");
          setState(1293);
          match(LustreParser::T__72);
          setState(1294);
          match(LustreParser::ID);
          break;
        }

        default:
          break;
        } 
      }
      setState(1299);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 120, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Unary_arith_opContext ------------------------------------------------------------------

LustreParser::Unary_arith_opContext::Unary_arith_opContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::Unary_arith_opContext::getRuleIndex() const {
  return LustreParser::RuleUnary_arith_op;
}

void LustreParser::Unary_arith_opContext::copyFrom(Unary_arith_opContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Unary_arith_op_notContext ------------------------------------------------------------------

LustreParser::Unary_arith_op_notContext::Unary_arith_op_notContext(Unary_arith_opContext *ctx) { copyFrom(ctx); }

void LustreParser::Unary_arith_op_notContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnary_arith_op_not(this);
}
void LustreParser::Unary_arith_op_notContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnary_arith_op_not(this);
}

std::any LustreParser::Unary_arith_op_notContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitUnary_arith_op_not(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Unary_arith_op_subContext ------------------------------------------------------------------

LustreParser::Unary_arith_op_subContext::Unary_arith_op_subContext(Unary_arith_opContext *ctx) { copyFrom(ctx); }

void LustreParser::Unary_arith_op_subContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnary_arith_op_sub(this);
}
void LustreParser::Unary_arith_op_subContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnary_arith_op_sub(this);
}

std::any LustreParser::Unary_arith_op_subContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitUnary_arith_op_sub(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Unary_arith_op_addContext ------------------------------------------------------------------

LustreParser::Unary_arith_op_addContext::Unary_arith_op_addContext(Unary_arith_opContext *ctx) { copyFrom(ctx); }

void LustreParser::Unary_arith_op_addContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnary_arith_op_add(this);
}
void LustreParser::Unary_arith_op_addContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnary_arith_op_add(this);
}

std::any LustreParser::Unary_arith_op_addContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitUnary_arith_op_add(this);
  else
    return visitor->visitChildren(this);
}
LustreParser::Unary_arith_opContext* LustreParser::unary_arith_op() {
  Unary_arith_opContext *_localctx = _tracker.createInstance<Unary_arith_opContext>(_ctx, getState());
  enterRule(_localctx, 172, LustreParser::RuleUnary_arith_op);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1303);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LustreParser::T__78: {
        _localctx = _tracker.createInstance<LustreParser::Unary_arith_op_subContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(1300);
        match(LustreParser::T__78);
        break;
      }

      case LustreParser::T__115: {
        _localctx = _tracker.createInstance<LustreParser::Unary_arith_op_addContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(1301);
        match(LustreParser::T__115);
        break;
      }

      case LustreParser::T__34: {
        _localctx = _tracker.createInstance<LustreParser::Unary_arith_op_notContext>(_localctx);
        enterOuterAlt(_localctx, 3);
        setState(1302);
        match(LustreParser::T__34);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bin_arith_opContext ------------------------------------------------------------------

LustreParser::Bin_arith_opContext::Bin_arith_opContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::Bin_arith_opContext::getRuleIndex() const {
  return LustreParser::RuleBin_arith_op;
}

void LustreParser::Bin_arith_opContext::copyFrom(Bin_arith_opContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Bin_arith_op_mulContext ------------------------------------------------------------------

LustreParser::Bin_arith_op_mulContext::Bin_arith_op_mulContext(Bin_arith_opContext *ctx) { copyFrom(ctx); }

void LustreParser::Bin_arith_op_mulContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBin_arith_op_mul(this);
}
void LustreParser::Bin_arith_op_mulContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBin_arith_op_mul(this);
}

std::any LustreParser::Bin_arith_op_mulContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitBin_arith_op_mul(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Bin_arith_op_dividedContext ------------------------------------------------------------------

LustreParser::Bin_arith_op_dividedContext::Bin_arith_op_dividedContext(Bin_arith_opContext *ctx) { copyFrom(ctx); }

void LustreParser::Bin_arith_op_dividedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBin_arith_op_divided(this);
}
void LustreParser::Bin_arith_op_dividedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBin_arith_op_divided(this);
}

std::any LustreParser::Bin_arith_op_dividedContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitBin_arith_op_divided(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Bin_arith_op_subContext ------------------------------------------------------------------

LustreParser::Bin_arith_op_subContext::Bin_arith_op_subContext(Bin_arith_opContext *ctx) { copyFrom(ctx); }

void LustreParser::Bin_arith_op_subContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBin_arith_op_sub(this);
}
void LustreParser::Bin_arith_op_subContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBin_arith_op_sub(this);
}

std::any LustreParser::Bin_arith_op_subContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitBin_arith_op_sub(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Bin_arith_op_modContext ------------------------------------------------------------------

LustreParser::Bin_arith_op_modContext::Bin_arith_op_modContext(Bin_arith_opContext *ctx) { copyFrom(ctx); }

void LustreParser::Bin_arith_op_modContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBin_arith_op_mod(this);
}
void LustreParser::Bin_arith_op_modContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBin_arith_op_mod(this);
}

std::any LustreParser::Bin_arith_op_modContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitBin_arith_op_mod(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Bin_arith_op_addContext ------------------------------------------------------------------

LustreParser::Bin_arith_op_addContext::Bin_arith_op_addContext(Bin_arith_opContext *ctx) { copyFrom(ctx); }

void LustreParser::Bin_arith_op_addContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBin_arith_op_add(this);
}
void LustreParser::Bin_arith_op_addContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBin_arith_op_add(this);
}

std::any LustreParser::Bin_arith_op_addContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitBin_arith_op_add(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Bin_arith_op_divContext ------------------------------------------------------------------

LustreParser::Bin_arith_op_divContext::Bin_arith_op_divContext(Bin_arith_opContext *ctx) { copyFrom(ctx); }

void LustreParser::Bin_arith_op_divContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBin_arith_op_div(this);
}
void LustreParser::Bin_arith_op_divContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBin_arith_op_div(this);
}

std::any LustreParser::Bin_arith_op_divContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitBin_arith_op_div(this);
  else
    return visitor->visitChildren(this);
}
LustreParser::Bin_arith_opContext* LustreParser::bin_arith_op() {
  Bin_arith_opContext *_localctx = _tracker.createInstance<Bin_arith_opContext>(_ctx, getState());
  enterRule(_localctx, 174, LustreParser::RuleBin_arith_op);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1311);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LustreParser::T__115: {
        _localctx = _tracker.createInstance<LustreParser::Bin_arith_op_addContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(1305);
        match(LustreParser::T__115);
        break;
      }

      case LustreParser::T__78: {
        _localctx = _tracker.createInstance<LustreParser::Bin_arith_op_subContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(1306);
        match(LustreParser::T__78);
        break;
      }

      case LustreParser::T__116: {
        _localctx = _tracker.createInstance<LustreParser::Bin_arith_op_mulContext>(_localctx);
        enterOuterAlt(_localctx, 3);
        setState(1307);
        match(LustreParser::T__116);
        break;
      }

      case LustreParser::T__117: {
        _localctx = _tracker.createInstance<LustreParser::Bin_arith_op_dividedContext>(_localctx);
        enterOuterAlt(_localctx, 4);
        setState(1308);
        match(LustreParser::T__117);
        break;
      }

      case LustreParser::T__118: {
        _localctx = _tracker.createInstance<LustreParser::Bin_arith_op_modContext>(_localctx);
        enterOuterAlt(_localctx, 5);
        setState(1309);
        match(LustreParser::T__118);
        break;
      }

      case LustreParser::T__119: {
        _localctx = _tracker.createInstance<LustreParser::Bin_arith_op_divContext>(_localctx);
        enterOuterAlt(_localctx, 6);
        setState(1310);
        match(LustreParser::T__119);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bin_relation_opContext ------------------------------------------------------------------

LustreParser::Bin_relation_opContext::Bin_relation_opContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::Bin_relation_opContext::getRuleIndex() const {
  return LustreParser::RuleBin_relation_op;
}

void LustreParser::Bin_relation_opContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBin_relation_op(this);
}

void LustreParser::Bin_relation_opContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBin_relation_op(this);
}


std::any LustreParser::Bin_relation_opContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitBin_relation_op(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Bin_relation_opContext* LustreParser::bin_relation_op() {
  Bin_relation_opContext *_localctx = _tracker.createInstance<Bin_relation_opContext>(_ctx, getState());
  enterRule(_localctx, 176, LustreParser::RuleBin_relation_op);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1313);
    _la = _input->LA(1);
    if (!(_la == LustreParser::T__7 || ((((_la - 121) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 121)) & 31) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bin_bool_opContext ------------------------------------------------------------------

LustreParser::Bin_bool_opContext::Bin_bool_opContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::Bin_bool_opContext::getRuleIndex() const {
  return LustreParser::RuleBin_bool_op;
}

void LustreParser::Bin_bool_opContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBin_bool_op(this);
}

void LustreParser::Bin_bool_opContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBin_bool_op(this);
}


std::any LustreParser::Bin_bool_opContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitBin_bool_op(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Bin_bool_opContext* LustreParser::bin_bool_op() {
  Bin_bool_opContext *_localctx = _tracker.createInstance<Bin_bool_opContext>(_ctx, getState());
  enterRule(_localctx, 178, LustreParser::RuleBin_bool_op);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1315);
    _la = _input->LA(1);
    if (!(((((_la - 126) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 126)) & 7) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AtomContext ------------------------------------------------------------------

LustreParser::AtomContext::AtomContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::AtomContext::getRuleIndex() const {
  return LustreParser::RuleAtom;
}

void LustreParser::AtomContext::copyFrom(AtomContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Atom_CHARContext ------------------------------------------------------------------

tree::TerminalNode* LustreParser::Atom_CHARContext::CHAR() {
  return getToken(LustreParser::CHAR, 0);
}

LustreParser::Atom_CHARContext::Atom_CHARContext(AtomContext *ctx) { copyFrom(ctx); }

void LustreParser::Atom_CHARContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAtom_CHAR(this);
}
void LustreParser::Atom_CHARContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAtom_CHAR(this);
}

std::any LustreParser::Atom_CHARContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitAtom_CHAR(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Atom_SHORTContext ------------------------------------------------------------------

tree::TerminalNode* LustreParser::Atom_SHORTContext::SHORT() {
  return getToken(LustreParser::SHORT, 0);
}

LustreParser::Atom_SHORTContext::Atom_SHORTContext(AtomContext *ctx) { copyFrom(ctx); }

void LustreParser::Atom_SHORTContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAtom_SHORT(this);
}
void LustreParser::Atom_SHORTContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAtom_SHORT(this);
}

std::any LustreParser::Atom_SHORTContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitAtom_SHORT(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Atom_UINTContext ------------------------------------------------------------------

tree::TerminalNode* LustreParser::Atom_UINTContext::UINT() {
  return getToken(LustreParser::UINT, 0);
}

LustreParser::Atom_UINTContext::Atom_UINTContext(AtomContext *ctx) { copyFrom(ctx); }

void LustreParser::Atom_UINTContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAtom_UINT(this);
}
void LustreParser::Atom_UINTContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAtom_UINT(this);
}

std::any LustreParser::Atom_UINTContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitAtom_UINT(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Atom_FLOATContext ------------------------------------------------------------------

tree::TerminalNode* LustreParser::Atom_FLOATContext::FLOAT() {
  return getToken(LustreParser::FLOAT, 0);
}

LustreParser::Atom_FLOATContext::Atom_FLOATContext(AtomContext *ctx) { copyFrom(ctx); }

void LustreParser::Atom_FLOATContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAtom_FLOAT(this);
}
void LustreParser::Atom_FLOATContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAtom_FLOAT(this);
}

std::any LustreParser::Atom_FLOATContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitAtom_FLOAT(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Atom_REALContext ------------------------------------------------------------------

tree::TerminalNode* LustreParser::Atom_REALContext::REAL() {
  return getToken(LustreParser::REAL, 0);
}

LustreParser::Atom_REALContext::Atom_REALContext(AtomContext *ctx) { copyFrom(ctx); }

void LustreParser::Atom_REALContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAtom_REAL(this);
}
void LustreParser::Atom_REALContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAtom_REAL(this);
}

std::any LustreParser::Atom_REALContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitAtom_REAL(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Atom_BOOLContext ------------------------------------------------------------------

tree::TerminalNode* LustreParser::Atom_BOOLContext::BOOL() {
  return getToken(LustreParser::BOOL, 0);
}

LustreParser::Atom_BOOLContext::Atom_BOOLContext(AtomContext *ctx) { copyFrom(ctx); }

void LustreParser::Atom_BOOLContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAtom_BOOL(this);
}
void LustreParser::Atom_BOOLContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAtom_BOOL(this);
}

std::any LustreParser::Atom_BOOLContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitAtom_BOOL(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Atom_INTEGERContext ------------------------------------------------------------------

tree::TerminalNode* LustreParser::Atom_INTEGERContext::INTEGER() {
  return getToken(LustreParser::INTEGER, 0);
}

LustreParser::Atom_INTEGERContext::Atom_INTEGERContext(AtomContext *ctx) { copyFrom(ctx); }

void LustreParser::Atom_INTEGERContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAtom_INTEGER(this);
}
void LustreParser::Atom_INTEGERContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAtom_INTEGER(this);
}

std::any LustreParser::Atom_INTEGERContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitAtom_INTEGER(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Atom_USHORTContext ------------------------------------------------------------------

tree::TerminalNode* LustreParser::Atom_USHORTContext::USHORT() {
  return getToken(LustreParser::USHORT, 0);
}

LustreParser::Atom_USHORTContext::Atom_USHORTContext(AtomContext *ctx) { copyFrom(ctx); }

void LustreParser::Atom_USHORTContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAtom_USHORT(this);
}
void LustreParser::Atom_USHORTContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAtom_USHORT(this);
}

std::any LustreParser::Atom_USHORTContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitAtom_USHORT(this);
  else
    return visitor->visitChildren(this);
}
LustreParser::AtomContext* LustreParser::atom() {
  AtomContext *_localctx = _tracker.createInstance<AtomContext>(_ctx, getState());
  enterRule(_localctx, 180, LustreParser::RuleAtom);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1325);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LustreParser::BOOL: {
        _localctx = _tracker.createInstance<LustreParser::Atom_BOOLContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(1317);
        match(LustreParser::BOOL);
        break;
      }

      case LustreParser::CHAR: {
        _localctx = _tracker.createInstance<LustreParser::Atom_CHARContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(1318);
        match(LustreParser::CHAR);
        break;
      }

      case LustreParser::INTEGER: {
        _localctx = _tracker.createInstance<LustreParser::Atom_INTEGERContext>(_localctx);
        enterOuterAlt(_localctx, 3);
        setState(1319);
        match(LustreParser::INTEGER);
        break;
      }

      case LustreParser::UINT: {
        _localctx = _tracker.createInstance<LustreParser::Atom_UINTContext>(_localctx);
        enterOuterAlt(_localctx, 4);
        setState(1320);
        match(LustreParser::UINT);
        break;
      }

      case LustreParser::FLOAT: {
        _localctx = _tracker.createInstance<LustreParser::Atom_FLOATContext>(_localctx);
        enterOuterAlt(_localctx, 5);
        setState(1321);
        match(LustreParser::FLOAT);
        break;
      }

      case LustreParser::REAL: {
        _localctx = _tracker.createInstance<LustreParser::Atom_REALContext>(_localctx);
        enterOuterAlt(_localctx, 6);
        setState(1322);
        match(LustreParser::REAL);
        break;
      }

      case LustreParser::USHORT: {
        _localctx = _tracker.createInstance<LustreParser::Atom_USHORTContext>(_localctx);
        enterOuterAlt(_localctx, 7);
        setState(1323);
        match(LustreParser::USHORT);
        break;
      }

      case LustreParser::SHORT: {
        _localctx = _tracker.createInstance<LustreParser::Atom_SHORTContext>(_localctx);
        enterOuterAlt(_localctx, 8);
        setState(1324);
        match(LustreParser::SHORT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Merge_exprContext ------------------------------------------------------------------

LustreParser::Merge_exprContext::Merge_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LustreParser::Merge_exprContext::ID() {
  return getToken(LustreParser::ID, 0);
}

LustreParser::Tempo_exprContext* LustreParser::Merge_exprContext::tempo_expr() {
  return getRuleContext<LustreParser::Tempo_exprContext>(0);
}

LustreParser::Kind2_exprContext* LustreParser::Merge_exprContext::kind2_expr() {
  return getRuleContext<LustreParser::Kind2_exprContext>(0);
}


size_t LustreParser::Merge_exprContext::getRuleIndex() const {
  return LustreParser::RuleMerge_expr;
}

void LustreParser::Merge_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMerge_expr(this);
}

void LustreParser::Merge_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMerge_expr(this);
}


std::any LustreParser::Merge_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitMerge_expr(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Merge_exprContext* LustreParser::merge_expr() {
  Merge_exprContext *_localctx = _tracker.createInstance<Merge_exprContext>(_ctx, getState());
  enterRule(_localctx, 182, LustreParser::RuleMerge_expr);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1330);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 124, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1327);
      match(LustreParser::ID);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1328);
      tempo_expr();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1329);
      kind2_expr();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

bool LustreParser::sempred(RuleContext *context, size_t ruleIndex, size_t predicateIndex) {
  switch (ruleIndex) {
    case 15: return typeSempred(antlrcpp::downCast<TypeContext *>(context), predicateIndex);
    case 19: return const_exprSempred(antlrcpp::downCast<Const_exprContext *>(context), predicateIndex);
    case 85: return simple_exprSempred(antlrcpp::downCast<Simple_exprContext *>(context), predicateIndex);

  default:
    break;
  }
  return true;
}

bool LustreParser::typeSempred(TypeContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 0: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

bool LustreParser::const_exprSempred(Const_exprContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 1: return precpred(_ctx, 5);
    case 2: return precpred(_ctx, 4);
    case 3: return precpred(_ctx, 3);

  default:
    break;
  }
  return true;
}

bool LustreParser::simple_exprSempred(Simple_exprContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 4: return precpred(_ctx, 5);
    case 5: return precpred(_ctx, 4);
    case 6: return precpred(_ctx, 3);
    case 7: return precpred(_ctx, 8);
    case 8: return precpred(_ctx, 7);

  default:
    break;
  }
  return true;
}

void LustreParser::initialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  lustreParserInitialize();
#else
  ::antlr4::internal::call_once(lustreParserOnceFlag, lustreParserInitialize);
#endif
}
