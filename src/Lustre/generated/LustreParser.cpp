
// Generated from Lustre.g4 by ANTLR 4.13.1


#include "LustreListener.h"
#include "LustreVisitor.h"

#include "LustreParser.h"


using namespace antlrcpp;

using namespace antlr4;

namespace {

struct LustreParserStaticData final {
  LustreParserStaticData(std::vector<std::string> ruleNames,
                        std::vector<std::string> literalNames,
                        std::vector<std::string> symbolicNames)
      : ruleNames(std::move(ruleNames)), literalNames(std::move(literalNames)),
        symbolicNames(std::move(symbolicNames)),
        vocabulary(this->literalNames, this->symbolicNames) {}

  LustreParserStaticData(const LustreParserStaticData&) = delete;
  LustreParserStaticData(LustreParserStaticData&&) = delete;
  LustreParserStaticData& operator=(const LustreParserStaticData&) = delete;
  LustreParserStaticData& operator=(LustreParserStaticData&&) = delete;

  std::vector<antlr4::dfa::DFA> decisionToDFA;
  antlr4::atn::PredictionContextCache sharedContextCache;
  const std::vector<std::string> ruleNames;
  const std::vector<std::string> literalNames;
  const std::vector<std::string> symbolicNames;
  const antlr4::dfa::Vocabulary vocabulary;
  antlr4::atn::SerializedATNView serializedATN;
  std::unique_ptr<antlr4::atn::ATN> atn;
};

::antlr4::internal::OnceFlag lustreParserOnceFlag;
#if ANTLR4_USE_THREAD_LOCAL_CACHE
static thread_local
#endif
LustreParserStaticData *lustreParserStaticData = nullptr;

void lustreParserInitialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  if (lustreParserStaticData != nullptr) {
    return;
  }
#else
  assert(lustreParserStaticData == nullptr);
#endif
  auto staticData = std::make_unique<LustreParserStaticData>(
    std::vector<std::string>{
      "program", "include", "pack_list", "one_park", "pack_decl", "uses", 
      "pack_eq", "provides", "provide", "model_decl", "user_op_provide", 
      "decls", "kind2_decl", "mode_decl", "requirement", "assurance", "var_decl", 
      "assume_decl", "guarantee_decl", "type_block", "type_decl", "type_def", 
      "type", "field_decl", "const_block", "const_decl", "const_expr", "const_list", 
      "const_label_expr", "var_decls", "when_decl", "clock_expr", "last_decl", 
      "user_op_decl", "op_kind", "params", "op_body", "contract_statement", 
      "merge_decl", "let_block", "local_block", "kind2_Statement", "mainStatement", 
      "propertyStatement", "checkStatement", "frame_block", "frame_init", 
      "frame_body", "import_op_decl", "equation", "lhs", "return", "returns_var", 
      "state_machine", "state_decl", "data_def", "transition", "expr", "list", 
      "kind2_expr", "activate_expr", "restart_expr", "tempo_expr", "bool_expr", 
      "array_expr", "struct_expr", "mixed_constructor", "label_expr", "index", 
      "label_or_index", "switch_expr", "case_expr", "pattern", "apply_expr", 
      "prefix_operator", "prefix_unary_operator", "prefix_binary_operator", 
      "iterator", "iterator_lv6", "simple_expr", "unary_arith_op", "bin_arith_op", 
      "bin_relation_op", "bin_bool_op", "atom"
    },
    std::vector<std::string>{
      "", "'include'", "';'", "'package'", "'body'", "'end'", "'uses'", 
      "','", "'='", "'is'", "'provides'", "'model'", "'needs'", "'returns'", 
      "'mode'", "'('", "')'", "'require'", "'ensure'", "'var'", "':'", "'assume'", 
      "'guarantee'", "'type'", "'enum'", "'{'", "'}'", "'int'", "'bool'", 
      "'char'", "'short'", "'ushort'", "'uint'", "'float'", "'real'", "'struct'", 
      "'^'", "'const'", "'['", "']'", "'when'", "'not'", "'last'", "'function'", 
      "'node'", "'let'", "'tel'", "'(*@contract'", "'*)'", "'/*@contract'", 
      "'*/'", "'merge'", "'--%MAIN'", "'--%PROPERTY'", "'check'", "'frame'", 
      "'imported'", "'..'", "'automaton'", "'initial'", "'final'", "'state'", 
      "'unless'", "'until'", "'if'", "'resume'", "'restart'", "'''", "'(activate'", 
      "'every'", "'(restart'", "'pre'", "'->'", "'fby'", "'#'", "'.'", "'default'", 
      "'with'", "'then'", "'else'", "'case'", "'of'", "'|'", "'-'", "'_'", 
      "'<<'", "'>>'", "'mapw'", "'mapwi'", "'foldw'", "'foldwi'", "'make'", 
      "'flatten'", "'+$'", "'-$'", "'not$'", "'short$'", "'int$'", "'float$'", 
      "'real$'", "'current'", "'and'", "'or'", "'xor'", "'=>'", "'<>'", 
      "'<'", "'<='", "'>'", "'>='", "'div'", "'mod'", "'+'", "'*'", "'/'", 
      "'$+$'", "'$-$'", "'$*$'", "'$/$'", "'$mod$'", "'$div$'", "'$=$'", 
      "'$<>$'", "'$<$'", "'$>$'", "'$<=$'", "'$>=$'", "'$and$'", "'$or$'", 
      "'$xor$'", "'map'", "'fold'", "'mapi'", "'foldi'", "'mapfold'", "'red'", 
      "'fill'", "'fillred'", "'boolred'"
    },
    std::vector<std::string>{
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "BOOL", "INTEGER", "UINT", "REAL", "CHAR", "FLOAT", "USHORT", 
      "SHORT", "ID", "SL_COMMENT", "ML_COMMENT", "MLX_COMMENT", "PRAGMA", 
      "STRING", "WS", "ERROR"
    }
  );
  static const int32_t serializedATNSegment[] = {
  	4,1,154,1169,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,
  	2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,
  	7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,
  	7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,
  	7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,
  	7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,
  	7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,
  	7,49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,
  	7,56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,
  	7,63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,
  	7,70,2,71,7,71,2,72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,
  	7,77,2,78,7,78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,
  	7,84,1,0,1,0,1,0,4,0,174,8,0,11,0,12,0,175,3,0,178,8,0,1,1,1,1,1,1,1,
  	1,1,2,4,2,185,8,2,11,2,12,2,186,1,3,1,3,1,3,3,3,192,8,3,1,4,1,4,1,4,1,
  	4,1,4,1,4,1,4,1,4,1,5,1,5,1,5,1,5,5,5,206,8,5,10,5,12,5,209,9,5,1,5,1,
  	5,1,6,1,6,1,6,1,6,1,6,1,7,1,7,1,7,1,7,1,7,1,7,5,7,224,8,7,10,7,12,7,227,
  	9,7,1,8,1,8,1,8,3,8,232,8,8,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,10,
  	1,10,1,10,1,10,1,10,1,10,1,11,1,11,1,11,1,11,1,11,3,11,254,8,11,1,12,
  	1,12,1,12,1,12,3,12,260,8,12,1,13,1,13,1,13,1,13,5,13,266,8,13,10,13,
  	12,13,269,9,13,1,13,5,13,272,8,13,10,13,12,13,275,9,13,1,13,1,13,1,13,
  	1,14,1,14,5,14,282,8,14,10,14,12,14,285,9,14,1,14,1,14,1,15,1,15,5,15,
  	291,8,15,10,15,12,15,294,9,15,1,15,1,15,1,16,1,16,1,16,1,16,1,16,1,16,
  	1,16,1,16,1,17,1,17,5,17,308,8,17,10,17,12,17,311,9,17,1,17,1,17,1,18,
  	1,18,5,18,317,8,18,10,18,12,18,320,9,18,1,18,1,18,1,19,1,19,1,19,1,19,
  	5,19,328,8,19,10,19,12,19,331,9,19,1,20,1,20,1,20,3,20,336,8,20,1,21,
  	1,21,1,21,1,21,1,21,1,21,5,21,344,8,21,10,21,12,21,347,9,21,1,21,3,21,
  	350,8,21,1,22,1,22,1,22,1,22,1,22,1,22,1,22,1,22,1,22,1,22,1,22,3,22,
  	363,8,22,1,22,1,22,1,22,1,22,5,22,369,8,22,10,22,12,22,372,9,22,1,22,
  	1,22,3,22,376,8,22,1,22,1,22,1,22,5,22,381,8,22,10,22,12,22,384,9,22,
  	1,23,1,23,1,23,1,23,1,24,1,24,1,24,1,24,5,24,394,8,24,10,24,12,24,397,
  	9,24,1,25,1,25,1,25,1,25,1,25,3,25,404,8,25,1,26,1,26,1,26,1,26,1,26,
  	1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,5,26,
  	424,8,26,10,26,12,26,427,9,26,1,26,1,26,3,26,431,8,26,1,26,1,26,1,26,
  	1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,1,26,5,26,445,8,26,10,26,12,26,
  	448,9,26,1,27,1,27,1,27,5,27,453,8,27,10,27,12,27,456,9,27,3,27,458,8,
  	27,1,28,1,28,1,28,1,28,1,29,1,29,1,29,5,29,467,8,29,10,29,12,29,470,9,
  	29,1,29,1,29,1,29,3,29,475,8,29,1,29,3,29,478,8,29,1,30,1,30,1,30,1,31,
  	1,31,1,31,3,31,486,8,31,1,31,1,31,3,31,490,8,31,3,31,492,8,31,1,32,1,
  	32,1,32,1,32,1,33,1,33,1,33,1,33,1,33,1,33,3,33,504,8,33,1,33,1,33,1,
  	34,1,34,3,34,510,8,34,1,35,1,35,1,35,1,35,5,35,516,8,35,10,35,12,35,519,
  	9,35,3,35,521,8,35,1,35,3,35,524,8,35,1,35,1,35,1,36,1,36,3,36,530,8,
  	36,1,36,3,36,533,8,36,1,36,3,36,536,8,36,1,36,1,36,1,36,1,36,5,36,542,
  	8,36,10,36,12,36,545,9,36,1,36,1,36,3,36,549,8,36,3,36,551,8,36,1,37,
  	1,37,5,37,555,8,37,10,37,12,37,558,9,37,1,37,1,37,1,37,5,37,563,8,37,
  	10,37,12,37,566,9,37,1,37,3,37,569,8,37,1,38,1,38,1,38,1,38,5,38,575,
  	8,38,10,38,12,38,578,9,38,1,38,1,38,1,38,1,39,1,39,1,39,3,39,586,8,39,
  	1,40,1,40,1,40,1,40,5,40,592,8,40,10,40,12,40,595,9,40,1,41,1,41,1,41,
  	3,41,600,8,41,1,42,1,42,1,42,1,43,1,43,5,43,607,8,43,10,43,12,43,610,
  	9,43,1,43,1,43,1,44,1,44,5,44,616,8,44,10,44,12,44,619,9,44,1,44,1,44,
  	1,45,1,45,5,45,625,8,45,10,45,12,45,628,9,45,1,45,1,45,1,46,1,46,1,46,
  	5,46,635,8,46,10,46,12,46,638,9,46,1,46,1,46,1,47,1,47,5,47,644,8,47,
  	10,47,12,47,647,9,47,1,47,1,47,1,48,1,48,1,48,1,48,1,48,1,48,1,48,1,49,
  	1,49,1,49,1,49,1,49,1,49,1,49,3,49,665,8,49,1,50,1,50,1,50,3,50,670,8,
  	50,1,50,1,50,1,50,5,50,675,8,50,10,50,12,50,678,9,50,1,50,3,50,681,8,
  	50,3,50,683,8,50,1,51,1,51,1,51,1,52,1,52,5,52,690,8,52,10,52,12,52,693,
  	9,52,1,52,3,52,696,8,52,1,53,1,53,3,53,700,8,53,1,53,4,53,703,8,53,11,
  	53,12,53,704,1,54,3,54,708,8,54,1,54,3,54,711,8,54,1,54,1,54,1,54,1,54,
  	1,54,1,54,4,54,719,8,54,11,54,12,54,720,3,54,723,8,54,1,54,1,54,1,54,
  	1,54,1,54,5,54,730,8,54,10,54,12,54,733,9,54,3,54,735,8,54,1,55,1,55,
  	3,55,739,8,55,1,55,1,55,1,55,1,55,5,55,745,8,55,10,55,12,55,748,9,55,
  	1,55,3,55,751,8,55,3,55,753,8,55,1,56,1,56,1,56,1,56,1,56,1,56,1,56,1,
  	56,1,56,1,56,3,56,765,8,56,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,
  	57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,3,57,783,8,57,1,58,1,58,1,58,5,
  	58,788,8,58,10,58,12,58,791,9,58,3,58,793,8,58,1,59,1,59,3,59,797,8,59,
  	1,60,1,60,1,60,1,60,1,60,1,60,1,60,1,61,1,61,1,61,1,61,1,61,1,61,1,61,
  	1,62,1,62,1,62,1,62,1,62,1,62,1,62,1,62,1,62,1,62,1,62,1,62,1,62,1,62,
  	1,62,5,62,828,8,62,10,62,12,62,831,9,62,1,62,1,62,1,62,1,62,1,62,1,62,
  	5,62,839,8,62,10,62,12,62,842,9,62,1,62,1,62,1,62,1,62,1,62,1,62,1,62,
  	1,62,1,62,1,62,1,62,1,62,1,62,1,62,1,62,3,62,859,8,62,1,63,3,63,862,8,
  	63,1,63,3,63,865,8,63,1,63,1,63,3,63,869,8,63,1,64,1,64,1,64,1,64,1,64,
  	1,64,1,64,1,64,1,64,1,64,1,64,4,64,882,8,64,11,64,12,64,883,1,64,1,64,
  	1,64,1,64,1,64,1,64,1,64,1,64,1,64,1,64,1,64,1,64,1,64,1,64,1,64,1,64,
  	5,64,902,8,64,10,64,12,64,905,9,64,3,64,907,8,64,1,65,1,65,1,65,1,65,
  	5,65,913,8,65,10,65,12,65,916,9,65,1,65,1,65,1,66,1,66,1,66,1,66,4,66,
  	924,8,66,11,66,12,66,925,1,66,1,66,1,66,1,66,1,67,1,67,1,67,1,67,1,68,
  	1,68,1,68,1,68,1,69,1,69,1,69,3,69,943,8,69,1,70,1,70,1,70,1,70,1,70,
  	1,70,1,70,1,70,1,70,1,70,1,70,1,70,4,70,957,8,70,11,70,12,70,958,1,70,
  	1,70,3,70,963,8,70,1,71,1,71,1,71,1,71,1,71,1,72,1,72,1,72,3,72,973,8,
  	72,1,72,1,72,1,72,3,72,978,8,72,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,
  	73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,
  	73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,
  	73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,
  	73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,
  	73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,
  	73,1,73,3,73,1059,8,73,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,
  	74,1,74,3,74,1072,8,74,1,75,1,75,1,76,1,76,1,77,1,77,1,77,1,77,1,77,1,
  	77,1,77,1,77,1,77,3,77,1087,8,77,1,78,1,78,1,78,1,78,3,78,1093,8,78,1,
  	79,1,79,1,79,1,79,1,79,1,79,1,79,5,79,1102,8,79,10,79,12,79,1105,9,79,
  	1,79,1,79,1,79,1,79,1,79,1,79,1,79,1,79,3,79,1115,8,79,1,79,1,79,1,79,
  	1,79,1,79,1,79,1,79,1,79,1,79,1,79,1,79,1,79,1,79,1,79,1,79,1,79,1,79,
  	1,79,1,79,1,79,5,79,1137,8,79,10,79,12,79,1140,9,79,1,80,1,80,1,80,3,
  	80,1145,8,80,1,81,1,81,1,81,1,81,1,81,1,81,3,81,1153,8,81,1,82,1,82,1,
  	83,1,83,1,84,1,84,1,84,1,84,1,84,1,84,1,84,1,84,3,84,1167,8,84,1,84,12,
  	283,292,309,318,556,564,576,608,617,626,636,645,3,44,52,158,85,0,2,4,
  	6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,
  	54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,
  	100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,
  	136,138,140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,0,
  	7,1,0,8,9,2,0,2,2,7,7,2,0,57,57,147,147,6,0,8,8,41,41,64,64,71,73,83,
  	83,93,114,1,0,115,129,2,0,8,8,105,109,1,0,101,103,1270,0,177,1,0,0,0,
  	2,179,1,0,0,0,4,184,1,0,0,0,6,191,1,0,0,0,8,193,1,0,0,0,10,201,1,0,0,
  	0,12,212,1,0,0,0,14,217,1,0,0,0,16,231,1,0,0,0,18,233,1,0,0,0,20,242,
  	1,0,0,0,22,253,1,0,0,0,24,259,1,0,0,0,26,261,1,0,0,0,28,279,1,0,0,0,30,
  	288,1,0,0,0,32,297,1,0,0,0,34,305,1,0,0,0,36,314,1,0,0,0,38,323,1,0,0,
  	0,40,332,1,0,0,0,42,349,1,0,0,0,44,375,1,0,0,0,46,385,1,0,0,0,48,389,
  	1,0,0,0,50,398,1,0,0,0,52,430,1,0,0,0,54,457,1,0,0,0,56,459,1,0,0,0,58,
  	463,1,0,0,0,60,479,1,0,0,0,62,491,1,0,0,0,64,493,1,0,0,0,66,497,1,0,0,
  	0,68,509,1,0,0,0,70,511,1,0,0,0,72,550,1,0,0,0,74,568,1,0,0,0,76,570,
  	1,0,0,0,78,585,1,0,0,0,80,587,1,0,0,0,82,599,1,0,0,0,84,601,1,0,0,0,86,
  	604,1,0,0,0,88,613,1,0,0,0,90,622,1,0,0,0,92,631,1,0,0,0,94,641,1,0,0,
  	0,96,650,1,0,0,0,98,664,1,0,0,0,100,682,1,0,0,0,102,684,1,0,0,0,104,691,
  	1,0,0,0,106,697,1,0,0,0,108,707,1,0,0,0,110,752,1,0,0,0,112,764,1,0,0,
  	0,114,782,1,0,0,0,116,792,1,0,0,0,118,796,1,0,0,0,120,798,1,0,0,0,122,
  	805,1,0,0,0,124,858,1,0,0,0,126,861,1,0,0,0,128,906,1,0,0,0,130,908,1,
  	0,0,0,132,919,1,0,0,0,134,931,1,0,0,0,136,935,1,0,0,0,138,942,1,0,0,0,
  	140,962,1,0,0,0,142,964,1,0,0,0,144,977,1,0,0,0,146,1058,1,0,0,0,148,
  	1071,1,0,0,0,150,1073,1,0,0,0,152,1075,1,0,0,0,154,1086,1,0,0,0,156,1092,
  	1,0,0,0,158,1114,1,0,0,0,160,1144,1,0,0,0,162,1152,1,0,0,0,164,1154,1,
  	0,0,0,166,1156,1,0,0,0,168,1166,1,0,0,0,170,178,3,2,1,0,171,174,3,22,
  	11,0,172,174,3,4,2,0,173,171,1,0,0,0,173,172,1,0,0,0,174,175,1,0,0,0,
  	175,173,1,0,0,0,175,176,1,0,0,0,176,178,1,0,0,0,177,170,1,0,0,0,177,173,
  	1,0,0,0,178,1,1,0,0,0,179,180,5,1,0,0,180,181,5,152,0,0,181,182,5,2,0,
  	0,182,3,1,0,0,0,183,185,3,6,3,0,184,183,1,0,0,0,185,186,1,0,0,0,186,184,
  	1,0,0,0,186,187,1,0,0,0,187,5,1,0,0,0,188,192,3,18,9,0,189,192,3,8,4,
  	0,190,192,3,12,6,0,191,188,1,0,0,0,191,189,1,0,0,0,191,190,1,0,0,0,192,
  	7,1,0,0,0,193,194,5,3,0,0,194,195,5,147,0,0,195,196,3,10,5,0,196,197,
  	3,14,7,0,197,198,5,4,0,0,198,199,3,22,11,0,199,200,5,5,0,0,200,9,1,0,
  	0,0,201,202,5,6,0,0,202,207,5,147,0,0,203,204,5,7,0,0,204,206,5,147,0,
  	0,205,203,1,0,0,0,206,209,1,0,0,0,207,205,1,0,0,0,207,208,1,0,0,0,208,
  	210,1,0,0,0,209,207,1,0,0,0,210,211,5,2,0,0,211,11,1,0,0,0,212,213,5,
  	3,0,0,213,214,5,147,0,0,214,215,7,0,0,0,215,216,5,147,0,0,216,13,1,0,
  	0,0,217,218,5,10,0,0,218,219,3,16,8,0,219,225,5,2,0,0,220,221,3,16,8,
  	0,221,222,5,2,0,0,222,224,1,0,0,0,223,220,1,0,0,0,224,227,1,0,0,0,225,
  	223,1,0,0,0,225,226,1,0,0,0,226,15,1,0,0,0,227,225,1,0,0,0,228,232,3,
  	48,24,0,229,232,3,38,19,0,230,232,3,20,10,0,231,228,1,0,0,0,231,229,1,
  	0,0,0,231,230,1,0,0,0,232,17,1,0,0,0,233,234,5,11,0,0,234,235,5,147,0,
  	0,235,236,3,10,5,0,236,237,5,12,0,0,237,238,3,20,10,0,238,239,5,4,0,0,
  	239,240,3,22,11,0,240,241,5,5,0,0,241,19,1,0,0,0,242,243,3,68,34,0,243,
  	244,5,147,0,0,244,245,3,70,35,0,245,246,5,13,0,0,246,247,3,70,35,0,247,
  	21,1,0,0,0,248,254,3,38,19,0,249,254,3,48,24,0,250,254,3,96,48,0,251,
  	254,3,66,33,0,252,254,3,24,12,0,253,248,1,0,0,0,253,249,1,0,0,0,253,250,
  	1,0,0,0,253,251,1,0,0,0,253,252,1,0,0,0,254,23,1,0,0,0,255,260,3,26,13,
  	0,256,260,3,32,16,0,257,260,3,34,17,0,258,260,3,36,18,0,259,255,1,0,0,
  	0,259,256,1,0,0,0,259,257,1,0,0,0,259,258,1,0,0,0,260,25,1,0,0,0,261,
  	262,5,14,0,0,262,263,5,147,0,0,263,267,5,15,0,0,264,266,3,28,14,0,265,
  	264,1,0,0,0,266,269,1,0,0,0,267,265,1,0,0,0,267,268,1,0,0,0,268,273,1,
  	0,0,0,269,267,1,0,0,0,270,272,3,30,15,0,271,270,1,0,0,0,272,275,1,0,0,
  	0,273,271,1,0,0,0,273,274,1,0,0,0,274,276,1,0,0,0,275,273,1,0,0,0,276,
  	277,5,16,0,0,277,278,5,2,0,0,278,27,1,0,0,0,279,283,5,17,0,0,280,282,
  	9,0,0,0,281,280,1,0,0,0,282,285,1,0,0,0,283,284,1,0,0,0,283,281,1,0,0,
  	0,284,286,1,0,0,0,285,283,1,0,0,0,286,287,5,2,0,0,287,29,1,0,0,0,288,
  	292,5,18,0,0,289,291,9,0,0,0,290,289,1,0,0,0,291,294,1,0,0,0,292,293,
  	1,0,0,0,292,290,1,0,0,0,293,295,1,0,0,0,294,292,1,0,0,0,295,296,5,2,0,
  	0,296,31,1,0,0,0,297,298,5,19,0,0,298,299,5,147,0,0,299,300,5,20,0,0,
  	300,301,3,44,22,0,301,302,5,8,0,0,302,303,3,114,57,0,303,304,5,2,0,0,
  	304,33,1,0,0,0,305,309,5,21,0,0,306,308,9,0,0,0,307,306,1,0,0,0,308,311,
  	1,0,0,0,309,310,1,0,0,0,309,307,1,0,0,0,310,312,1,0,0,0,311,309,1,0,0,
  	0,312,313,5,2,0,0,313,35,1,0,0,0,314,318,5,22,0,0,315,317,9,0,0,0,316,
  	315,1,0,0,0,317,320,1,0,0,0,318,319,1,0,0,0,318,316,1,0,0,0,319,321,1,
  	0,0,0,320,318,1,0,0,0,321,322,5,2,0,0,322,37,1,0,0,0,323,329,5,23,0,0,
  	324,325,3,40,20,0,325,326,5,2,0,0,326,328,1,0,0,0,327,324,1,0,0,0,328,
  	331,1,0,0,0,329,327,1,0,0,0,329,330,1,0,0,0,330,39,1,0,0,0,331,329,1,
  	0,0,0,332,335,5,147,0,0,333,334,5,8,0,0,334,336,3,42,21,0,335,333,1,0,
  	0,0,335,336,1,0,0,0,336,41,1,0,0,0,337,350,3,44,22,0,338,339,5,24,0,0,
  	339,340,5,25,0,0,340,345,5,147,0,0,341,342,5,7,0,0,342,344,5,147,0,0,
  	343,341,1,0,0,0,344,347,1,0,0,0,345,343,1,0,0,0,345,346,1,0,0,0,346,348,
  	1,0,0,0,347,345,1,0,0,0,348,350,5,26,0,0,349,337,1,0,0,0,349,338,1,0,
  	0,0,350,43,1,0,0,0,351,352,6,22,-1,0,352,376,5,27,0,0,353,376,5,28,0,
  	0,354,376,5,29,0,0,355,376,5,30,0,0,356,376,5,31,0,0,357,376,5,32,0,0,
  	358,376,5,33,0,0,359,376,5,34,0,0,360,376,5,147,0,0,361,363,5,35,0,0,
  	362,361,1,0,0,0,362,363,1,0,0,0,363,364,1,0,0,0,364,365,5,25,0,0,365,
  	370,3,46,23,0,366,367,7,1,0,0,367,369,3,46,23,0,368,366,1,0,0,0,369,372,
  	1,0,0,0,370,368,1,0,0,0,370,371,1,0,0,0,371,373,1,0,0,0,372,370,1,0,0,
  	0,373,374,5,26,0,0,374,376,1,0,0,0,375,351,1,0,0,0,375,353,1,0,0,0,375,
  	354,1,0,0,0,375,355,1,0,0,0,375,356,1,0,0,0,375,357,1,0,0,0,375,358,1,
  	0,0,0,375,359,1,0,0,0,375,360,1,0,0,0,375,362,1,0,0,0,376,382,1,0,0,0,
  	377,378,10,1,0,0,378,379,5,36,0,0,379,381,3,52,26,0,380,377,1,0,0,0,381,
  	384,1,0,0,0,382,380,1,0,0,0,382,383,1,0,0,0,383,45,1,0,0,0,384,382,1,
  	0,0,0,385,386,5,147,0,0,386,387,5,20,0,0,387,388,3,44,22,0,388,47,1,0,
  	0,0,389,395,5,37,0,0,390,391,3,50,25,0,391,392,5,2,0,0,392,394,1,0,0,
  	0,393,390,1,0,0,0,394,397,1,0,0,0,395,393,1,0,0,0,395,396,1,0,0,0,396,
  	49,1,0,0,0,397,395,1,0,0,0,398,399,5,147,0,0,399,400,5,20,0,0,400,403,
  	3,44,22,0,401,402,5,8,0,0,402,404,3,52,26,0,403,401,1,0,0,0,403,404,1,
  	0,0,0,404,51,1,0,0,0,405,406,6,26,-1,0,406,431,5,147,0,0,407,431,3,168,
  	84,0,408,409,3,160,80,0,409,410,3,52,26,7,410,431,1,0,0,0,411,412,5,15,
  	0,0,412,413,3,52,26,0,413,414,5,16,0,0,414,431,1,0,0,0,415,416,5,38,0,
  	0,416,417,3,54,27,0,417,418,5,39,0,0,418,431,1,0,0,0,419,420,5,25,0,0,
  	420,425,3,56,28,0,421,422,5,7,0,0,422,424,3,56,28,0,423,421,1,0,0,0,424,
  	427,1,0,0,0,425,423,1,0,0,0,425,426,1,0,0,0,426,428,1,0,0,0,427,425,1,
  	0,0,0,428,429,5,26,0,0,429,431,1,0,0,0,430,405,1,0,0,0,430,407,1,0,0,
  	0,430,408,1,0,0,0,430,411,1,0,0,0,430,415,1,0,0,0,430,419,1,0,0,0,431,
  	446,1,0,0,0,432,433,10,5,0,0,433,434,3,162,81,0,434,435,3,52,26,6,435,
  	445,1,0,0,0,436,437,10,4,0,0,437,438,3,166,83,0,438,439,3,52,26,5,439,
  	445,1,0,0,0,440,441,10,3,0,0,441,442,3,164,82,0,442,443,3,52,26,4,443,
  	445,1,0,0,0,444,432,1,0,0,0,444,436,1,0,0,0,444,440,1,0,0,0,445,448,1,
  	0,0,0,446,444,1,0,0,0,446,447,1,0,0,0,447,53,1,0,0,0,448,446,1,0,0,0,
  	449,454,3,52,26,0,450,451,5,7,0,0,451,453,3,52,26,0,452,450,1,0,0,0,453,
  	456,1,0,0,0,454,452,1,0,0,0,454,455,1,0,0,0,455,458,1,0,0,0,456,454,1,
  	0,0,0,457,449,1,0,0,0,457,458,1,0,0,0,458,55,1,0,0,0,459,460,5,147,0,
  	0,460,461,5,20,0,0,461,462,3,52,26,0,462,57,1,0,0,0,463,468,5,147,0,0,
  	464,465,5,7,0,0,465,467,5,147,0,0,466,464,1,0,0,0,467,470,1,0,0,0,468,
  	466,1,0,0,0,468,469,1,0,0,0,469,471,1,0,0,0,470,468,1,0,0,0,471,472,5,
  	20,0,0,472,474,3,44,22,0,473,475,3,60,30,0,474,473,1,0,0,0,474,475,1,
  	0,0,0,475,477,1,0,0,0,476,478,3,64,32,0,477,476,1,0,0,0,477,478,1,0,0,
  	0,478,59,1,0,0,0,479,480,5,40,0,0,480,481,3,62,31,0,481,61,1,0,0,0,482,
  	492,5,147,0,0,483,485,5,41,0,0,484,486,5,15,0,0,485,484,1,0,0,0,485,486,
  	1,0,0,0,486,487,1,0,0,0,487,489,5,147,0,0,488,490,5,16,0,0,489,488,1,
  	0,0,0,489,490,1,0,0,0,490,492,1,0,0,0,491,482,1,0,0,0,491,483,1,0,0,0,
  	492,63,1,0,0,0,493,494,5,42,0,0,494,495,5,8,0,0,495,496,3,52,26,0,496,
  	65,1,0,0,0,497,498,3,68,34,0,498,499,5,147,0,0,499,500,3,70,35,0,500,
  	501,5,13,0,0,501,503,3,70,35,0,502,504,5,2,0,0,503,502,1,0,0,0,503,504,
  	1,0,0,0,504,505,1,0,0,0,505,506,3,72,36,0,506,67,1,0,0,0,507,510,5,43,
  	0,0,508,510,5,44,0,0,509,507,1,0,0,0,509,508,1,0,0,0,510,69,1,0,0,0,511,
  	520,5,15,0,0,512,517,3,58,29,0,513,514,5,2,0,0,514,516,3,58,29,0,515,
  	513,1,0,0,0,516,519,1,0,0,0,517,515,1,0,0,0,517,518,1,0,0,0,518,521,1,
  	0,0,0,519,517,1,0,0,0,520,512,1,0,0,0,520,521,1,0,0,0,521,523,1,0,0,0,
  	522,524,5,2,0,0,523,522,1,0,0,0,523,524,1,0,0,0,524,525,1,0,0,0,525,526,
  	5,16,0,0,526,71,1,0,0,0,527,551,5,2,0,0,528,530,3,74,37,0,529,528,1,0,
  	0,0,529,530,1,0,0,0,530,532,1,0,0,0,531,533,3,76,38,0,532,531,1,0,0,0,
  	532,533,1,0,0,0,533,535,1,0,0,0,534,536,3,80,40,0,535,534,1,0,0,0,535,
  	536,1,0,0,0,536,537,1,0,0,0,537,543,5,45,0,0,538,539,3,78,39,0,539,540,
  	5,2,0,0,540,542,1,0,0,0,541,538,1,0,0,0,542,545,1,0,0,0,543,541,1,0,0,
  	0,543,544,1,0,0,0,544,546,1,0,0,0,545,543,1,0,0,0,546,548,5,46,0,0,547,
  	549,5,2,0,0,548,547,1,0,0,0,548,549,1,0,0,0,549,551,1,0,0,0,550,527,1,
  	0,0,0,550,529,1,0,0,0,551,73,1,0,0,0,552,556,5,47,0,0,553,555,9,0,0,0,
  	554,553,1,0,0,0,555,558,1,0,0,0,556,557,1,0,0,0,556,554,1,0,0,0,557,559,
  	1,0,0,0,558,556,1,0,0,0,559,569,5,48,0,0,560,564,5,49,0,0,561,563,9,0,
  	0,0,562,561,1,0,0,0,563,566,1,0,0,0,564,565,1,0,0,0,564,562,1,0,0,0,565,
  	567,1,0,0,0,566,564,1,0,0,0,567,569,5,50,0,0,568,552,1,0,0,0,568,560,
  	1,0,0,0,569,75,1,0,0,0,570,571,5,51,0,0,571,572,5,147,0,0,572,576,5,15,
  	0,0,573,575,9,0,0,0,574,573,1,0,0,0,575,578,1,0,0,0,576,577,1,0,0,0,576,
  	574,1,0,0,0,577,579,1,0,0,0,578,576,1,0,0,0,579,580,5,16,0,0,580,581,
  	5,2,0,0,581,77,1,0,0,0,582,586,3,98,49,0,583,586,3,82,41,0,584,586,3,
  	90,45,0,585,582,1,0,0,0,585,583,1,0,0,0,585,584,1,0,0,0,586,79,1,0,0,
  	0,587,593,5,19,0,0,588,589,3,58,29,0,589,590,5,2,0,0,590,592,1,0,0,0,
  	591,588,1,0,0,0,592,595,1,0,0,0,593,591,1,0,0,0,593,594,1,0,0,0,594,81,
  	1,0,0,0,595,593,1,0,0,0,596,600,3,84,42,0,597,600,3,86,43,0,598,600,3,
  	88,44,0,599,596,1,0,0,0,599,597,1,0,0,0,599,598,1,0,0,0,600,83,1,0,0,
  	0,601,602,5,52,0,0,602,603,5,2,0,0,603,85,1,0,0,0,604,608,5,53,0,0,605,
  	607,9,0,0,0,606,605,1,0,0,0,607,610,1,0,0,0,608,609,1,0,0,0,608,606,1,
  	0,0,0,609,611,1,0,0,0,610,608,1,0,0,0,611,612,5,2,0,0,612,87,1,0,0,0,
  	613,617,5,54,0,0,614,616,9,0,0,0,615,614,1,0,0,0,616,619,1,0,0,0,617,
  	618,1,0,0,0,617,615,1,0,0,0,618,620,1,0,0,0,619,617,1,0,0,0,620,621,5,
  	2,0,0,621,89,1,0,0,0,622,626,3,92,46,0,623,625,9,0,0,0,624,623,1,0,0,
  	0,625,628,1,0,0,0,626,627,1,0,0,0,626,624,1,0,0,0,627,629,1,0,0,0,628,
  	626,1,0,0,0,629,630,3,94,47,0,630,91,1,0,0,0,631,632,5,55,0,0,632,636,
  	5,15,0,0,633,635,9,0,0,0,634,633,1,0,0,0,635,638,1,0,0,0,636,637,1,0,
  	0,0,636,634,1,0,0,0,637,639,1,0,0,0,638,636,1,0,0,0,639,640,5,16,0,0,
  	640,93,1,0,0,0,641,645,5,45,0,0,642,644,9,0,0,0,643,642,1,0,0,0,644,647,
  	1,0,0,0,645,646,1,0,0,0,645,643,1,0,0,0,646,648,1,0,0,0,647,645,1,0,0,
  	0,648,649,5,46,0,0,649,95,1,0,0,0,650,651,5,43,0,0,651,652,5,56,0,0,652,
  	653,5,147,0,0,653,654,3,70,35,0,654,655,5,13,0,0,655,656,3,70,35,0,656,
  	97,1,0,0,0,657,658,3,100,50,0,658,659,5,8,0,0,659,660,3,114,57,0,660,
  	665,1,0,0,0,661,662,3,106,53,0,662,663,3,102,51,0,663,665,1,0,0,0,664,
  	657,1,0,0,0,664,661,1,0,0,0,665,99,1,0,0,0,666,667,5,15,0,0,667,683,5,
  	16,0,0,668,670,5,15,0,0,669,668,1,0,0,0,669,670,1,0,0,0,670,671,1,0,0,
  	0,671,676,5,147,0,0,672,673,5,7,0,0,673,675,5,147,0,0,674,672,1,0,0,0,
  	675,678,1,0,0,0,676,674,1,0,0,0,676,677,1,0,0,0,677,680,1,0,0,0,678,676,
  	1,0,0,0,679,681,5,16,0,0,680,679,1,0,0,0,680,681,1,0,0,0,681,683,1,0,
  	0,0,682,666,1,0,0,0,682,669,1,0,0,0,683,101,1,0,0,0,684,685,5,13,0,0,
  	685,686,3,104,52,0,686,103,1,0,0,0,687,688,5,147,0,0,688,690,5,7,0,0,
  	689,687,1,0,0,0,690,693,1,0,0,0,691,689,1,0,0,0,691,692,1,0,0,0,692,695,
  	1,0,0,0,693,691,1,0,0,0,694,696,7,2,0,0,695,694,1,0,0,0,695,696,1,0,0,
  	0,696,105,1,0,0,0,697,699,5,58,0,0,698,700,5,147,0,0,699,698,1,0,0,0,
  	699,700,1,0,0,0,700,702,1,0,0,0,701,703,3,108,54,0,702,701,1,0,0,0,703,
  	704,1,0,0,0,704,702,1,0,0,0,704,705,1,0,0,0,705,107,1,0,0,0,706,708,5,
  	59,0,0,707,706,1,0,0,0,707,708,1,0,0,0,708,710,1,0,0,0,709,711,5,60,0,
  	0,710,709,1,0,0,0,710,711,1,0,0,0,711,712,1,0,0,0,712,713,5,61,0,0,713,
  	722,5,147,0,0,714,718,5,62,0,0,715,716,3,112,56,0,716,717,5,2,0,0,717,
  	719,1,0,0,0,718,715,1,0,0,0,719,720,1,0,0,0,720,718,1,0,0,0,720,721,1,
  	0,0,0,721,723,1,0,0,0,722,714,1,0,0,0,722,723,1,0,0,0,723,724,1,0,0,0,
  	724,734,3,110,55,0,725,731,5,63,0,0,726,727,3,112,56,0,727,728,5,2,0,
  	0,728,730,1,0,0,0,729,726,1,0,0,0,730,733,1,0,0,0,731,729,1,0,0,0,731,
  	732,1,0,0,0,732,735,1,0,0,0,733,731,1,0,0,0,734,725,1,0,0,0,734,735,1,
  	0,0,0,735,109,1,0,0,0,736,753,3,98,49,0,737,739,3,80,40,0,738,737,1,0,
  	0,0,738,739,1,0,0,0,739,750,1,0,0,0,740,746,5,45,0,0,741,742,3,98,49,
  	0,742,743,5,2,0,0,743,745,1,0,0,0,744,741,1,0,0,0,745,748,1,0,0,0,746,
  	744,1,0,0,0,746,747,1,0,0,0,747,749,1,0,0,0,748,746,1,0,0,0,749,751,5,
  	46,0,0,750,740,1,0,0,0,750,751,1,0,0,0,751,753,1,0,0,0,752,736,1,0,0,
  	0,752,738,1,0,0,0,753,111,1,0,0,0,754,755,5,64,0,0,755,756,3,114,57,0,
  	756,757,5,65,0,0,757,758,5,147,0,0,758,765,1,0,0,0,759,760,5,64,0,0,760,
  	761,3,114,57,0,761,762,5,66,0,0,762,763,5,147,0,0,763,765,1,0,0,0,764,
  	754,1,0,0,0,764,759,1,0,0,0,765,113,1,0,0,0,766,783,3,158,79,0,767,768,
  	5,42,0,0,768,769,5,67,0,0,769,783,5,147,0,0,770,783,3,124,62,0,771,783,
  	3,126,63,0,772,783,3,128,64,0,773,783,3,130,65,0,774,783,3,132,66,0,775,
  	783,3,140,70,0,776,777,5,15,0,0,777,778,3,114,57,0,778,779,5,16,0,0,779,
  	783,1,0,0,0,780,783,3,146,73,0,781,783,3,118,59,0,782,766,1,0,0,0,782,
  	767,1,0,0,0,782,770,1,0,0,0,782,771,1,0,0,0,782,772,1,0,0,0,782,773,1,
  	0,0,0,782,774,1,0,0,0,782,775,1,0,0,0,782,776,1,0,0,0,782,780,1,0,0,0,
  	782,781,1,0,0,0,783,115,1,0,0,0,784,789,3,158,79,0,785,786,5,7,0,0,786,
  	788,3,158,79,0,787,785,1,0,0,0,788,791,1,0,0,0,789,787,1,0,0,0,789,790,
  	1,0,0,0,790,793,1,0,0,0,791,789,1,0,0,0,792,784,1,0,0,0,792,793,1,0,0,
  	0,793,117,1,0,0,0,794,797,3,120,60,0,795,797,3,122,61,0,796,794,1,0,0,
  	0,796,795,1,0,0,0,797,119,1,0,0,0,798,799,5,68,0,0,799,800,5,147,0,0,
  	800,801,5,69,0,0,801,802,5,147,0,0,802,803,5,16,0,0,803,804,3,70,35,0,
  	804,121,1,0,0,0,805,806,5,70,0,0,806,807,5,147,0,0,807,808,5,69,0,0,808,
  	809,5,147,0,0,809,810,5,16,0,0,810,811,3,70,35,0,811,123,1,0,0,0,812,
  	813,5,71,0,0,813,859,3,158,79,0,814,815,3,158,79,0,815,816,5,72,0,0,816,
  	817,3,124,62,0,817,859,1,0,0,0,818,819,3,158,79,0,819,820,5,72,0,0,820,
  	821,3,158,79,0,821,859,1,0,0,0,822,823,5,73,0,0,823,824,5,15,0,0,824,
  	829,3,158,79,0,825,826,5,7,0,0,826,828,3,158,79,0,827,825,1,0,0,0,828,
  	831,1,0,0,0,829,827,1,0,0,0,829,830,1,0,0,0,830,832,1,0,0,0,831,829,1,
  	0,0,0,832,833,5,2,0,0,833,834,3,52,26,0,834,835,5,2,0,0,835,840,3,158,
  	79,0,836,837,5,7,0,0,837,839,3,158,79,0,838,836,1,0,0,0,839,842,1,0,0,
  	0,840,838,1,0,0,0,840,841,1,0,0,0,841,843,1,0,0,0,842,840,1,0,0,0,843,
  	844,5,16,0,0,844,859,1,0,0,0,845,846,3,158,79,0,846,847,5,73,0,0,847,
  	848,3,158,79,0,848,859,1,0,0,0,849,850,3,158,79,0,850,851,5,40,0,0,851,
  	852,3,62,31,0,852,859,1,0,0,0,853,854,5,51,0,0,854,855,5,147,0,0,855,
  	856,3,158,79,0,856,857,3,158,79,0,857,859,1,0,0,0,858,812,1,0,0,0,858,
  	814,1,0,0,0,858,818,1,0,0,0,858,822,1,0,0,0,858,845,1,0,0,0,858,849,1,
  	0,0,0,858,853,1,0,0,0,859,125,1,0,0,0,860,862,5,74,0,0,861,860,1,0,0,
  	0,861,862,1,0,0,0,862,864,1,0,0,0,863,865,5,15,0,0,864,863,1,0,0,0,864,
  	865,1,0,0,0,865,866,1,0,0,0,866,868,3,116,58,0,867,869,5,16,0,0,868,867,
  	1,0,0,0,868,869,1,0,0,0,869,127,1,0,0,0,870,871,3,158,79,0,871,872,5,
  	38,0,0,872,873,5,140,0,0,873,874,5,57,0,0,874,875,5,140,0,0,875,876,5,
  	39,0,0,876,907,1,0,0,0,877,878,5,15,0,0,878,879,3,158,79,0,879,881,5,
  	75,0,0,880,882,3,136,68,0,881,880,1,0,0,0,882,883,1,0,0,0,883,881,1,0,
  	0,0,883,884,1,0,0,0,884,885,1,0,0,0,885,886,5,76,0,0,886,887,3,158,79,
  	0,887,888,5,16,0,0,888,907,1,0,0,0,889,890,3,158,79,0,890,891,5,36,0,
  	0,891,892,3,52,26,0,892,907,1,0,0,0,893,894,5,38,0,0,894,895,3,116,58,
  	0,895,903,5,39,0,0,896,897,5,7,0,0,897,898,5,38,0,0,898,899,3,116,58,
  	0,899,900,5,39,0,0,900,902,1,0,0,0,901,896,1,0,0,0,902,905,1,0,0,0,903,
  	901,1,0,0,0,903,904,1,0,0,0,904,907,1,0,0,0,905,903,1,0,0,0,906,870,1,
  	0,0,0,906,877,1,0,0,0,906,889,1,0,0,0,906,893,1,0,0,0,907,129,1,0,0,0,
  	908,909,5,25,0,0,909,914,3,134,67,0,910,911,7,1,0,0,911,913,3,134,67,
  	0,912,910,1,0,0,0,913,916,1,0,0,0,914,912,1,0,0,0,914,915,1,0,0,0,915,
  	917,1,0,0,0,916,914,1,0,0,0,917,918,5,26,0,0,918,131,1,0,0,0,919,920,
  	5,15,0,0,920,921,5,147,0,0,921,923,5,77,0,0,922,924,3,138,69,0,923,922,
  	1,0,0,0,924,925,1,0,0,0,925,923,1,0,0,0,925,926,1,0,0,0,926,927,1,0,0,
  	0,927,928,5,8,0,0,928,929,3,158,79,0,929,930,5,16,0,0,930,133,1,0,0,0,
  	931,932,5,147,0,0,932,933,5,20,0,0,933,934,3,158,79,0,934,135,1,0,0,0,
  	935,936,5,38,0,0,936,937,3,158,79,0,937,938,5,39,0,0,938,137,1,0,0,0,
  	939,940,5,75,0,0,940,943,5,147,0,0,941,943,3,136,68,0,942,939,1,0,0,0,
  	942,941,1,0,0,0,943,139,1,0,0,0,944,945,5,64,0,0,945,946,3,158,79,0,946,
  	947,5,78,0,0,947,948,3,158,79,0,948,949,5,79,0,0,949,950,3,158,79,0,950,
  	963,1,0,0,0,951,952,5,15,0,0,952,953,5,80,0,0,953,954,3,158,79,0,954,
  	956,5,81,0,0,955,957,3,142,71,0,956,955,1,0,0,0,957,958,1,0,0,0,958,956,
  	1,0,0,0,958,959,1,0,0,0,959,960,1,0,0,0,960,961,5,16,0,0,961,963,1,0,
  	0,0,962,944,1,0,0,0,962,951,1,0,0,0,963,141,1,0,0,0,964,965,5,82,0,0,
  	965,966,3,144,72,0,966,967,5,20,0,0,967,968,3,158,79,0,968,143,1,0,0,
  	0,969,978,5,147,0,0,970,978,5,143,0,0,971,973,5,83,0,0,972,971,1,0,0,
  	0,972,973,1,0,0,0,973,974,1,0,0,0,974,978,5,140,0,0,975,978,5,139,0,0,
  	976,978,5,84,0,0,977,969,1,0,0,0,977,970,1,0,0,0,977,972,1,0,0,0,977,
  	975,1,0,0,0,977,976,1,0,0,0,978,145,1,0,0,0,979,980,3,148,74,0,980,981,
  	5,15,0,0,981,982,3,116,58,0,982,983,5,16,0,0,983,1059,1,0,0,0,984,985,
  	3,154,77,0,985,986,5,85,0,0,986,987,3,148,74,0,987,988,5,7,0,0,988,989,
  	3,52,26,0,989,990,5,86,0,0,990,991,5,15,0,0,991,992,3,116,58,0,992,993,
  	5,16,0,0,993,1059,1,0,0,0,994,995,3,156,78,0,995,996,5,85,0,0,996,997,
  	3,116,58,0,997,998,5,86,0,0,998,999,5,15,0,0,999,1000,3,116,58,0,1000,
  	1001,5,16,0,0,1001,1059,1,0,0,0,1002,1003,5,87,0,0,1003,1004,5,85,0,0,
  	1004,1005,3,148,74,0,1005,1006,5,7,0,0,1006,1007,3,52,26,0,1007,1008,
  	5,86,0,0,1008,1009,5,64,0,0,1009,1010,3,158,79,0,1010,1011,5,76,0,0,1011,
  	1012,5,15,0,0,1012,1013,3,116,58,0,1013,1014,5,16,0,0,1014,1015,5,15,
  	0,0,1015,1016,3,116,58,0,1016,1017,5,16,0,0,1017,1059,1,0,0,0,1018,1019,
  	5,88,0,0,1019,1020,5,85,0,0,1020,1021,3,148,74,0,1021,1022,5,7,0,0,1022,
  	1023,3,52,26,0,1023,1024,5,86,0,0,1024,1025,5,64,0,0,1025,1026,3,158,
  	79,0,1026,1027,5,76,0,0,1027,1028,5,15,0,0,1028,1029,3,116,58,0,1029,
  	1030,5,16,0,0,1030,1031,5,15,0,0,1031,1032,3,116,58,0,1032,1033,5,16,
  	0,0,1033,1059,1,0,0,0,1034,1035,5,89,0,0,1035,1036,5,85,0,0,1036,1037,
  	3,148,74,0,1037,1038,5,7,0,0,1038,1039,3,52,26,0,1039,1040,5,86,0,0,1040,
  	1041,5,64,0,0,1041,1042,3,158,79,0,1042,1043,5,15,0,0,1043,1044,3,116,
  	58,0,1044,1045,5,16,0,0,1045,1059,1,0,0,0,1046,1047,5,90,0,0,1047,1048,
  	5,85,0,0,1048,1049,3,148,74,0,1049,1050,5,7,0,0,1050,1051,3,52,26,0,1051,
  	1052,5,86,0,0,1052,1053,5,64,0,0,1053,1054,3,158,79,0,1054,1055,5,15,
  	0,0,1055,1056,3,116,58,0,1056,1057,5,16,0,0,1057,1059,1,0,0,0,1058,979,
  	1,0,0,0,1058,984,1,0,0,0,1058,994,1,0,0,0,1058,1002,1,0,0,0,1058,1018,
  	1,0,0,0,1058,1034,1,0,0,0,1058,1046,1,0,0,0,1059,147,1,0,0,0,1060,1072,
  	5,147,0,0,1061,1072,3,150,75,0,1062,1072,3,152,76,0,1063,1064,5,15,0,
  	0,1064,1065,5,91,0,0,1065,1066,5,147,0,0,1066,1072,5,16,0,0,1067,1068,
  	5,15,0,0,1068,1069,5,92,0,0,1069,1070,5,147,0,0,1070,1072,5,16,0,0,1071,
  	1060,1,0,0,0,1071,1061,1,0,0,0,1071,1062,1,0,0,0,1071,1063,1,0,0,0,1071,
  	1067,1,0,0,0,1072,149,1,0,0,0,1073,1074,7,3,0,0,1074,151,1,0,0,0,1075,
  	1076,7,4,0,0,1076,153,1,0,0,0,1077,1087,5,130,0,0,1078,1087,5,131,0,0,
  	1079,1087,5,132,0,0,1080,1087,5,133,0,0,1081,1087,5,134,0,0,1082,1087,
  	5,135,0,0,1083,1087,5,136,0,0,1084,1087,5,137,0,0,1085,1087,5,138,0,0,
  	1086,1077,1,0,0,0,1086,1078,1,0,0,0,1086,1079,1,0,0,0,1086,1080,1,0,0,
  	0,1086,1081,1,0,0,0,1086,1082,1,0,0,0,1086,1083,1,0,0,0,1086,1084,1,0,
  	0,0,1086,1085,1,0,0,0,1087,155,1,0,0,0,1088,1093,5,135,0,0,1089,1093,
  	5,136,0,0,1090,1093,5,137,0,0,1091,1093,5,138,0,0,1092,1088,1,0,0,0,1092,
  	1089,1,0,0,0,1092,1090,1,0,0,0,1092,1091,1,0,0,0,1093,157,1,0,0,0,1094,
  	1095,6,79,-1,0,1095,1115,5,147,0,0,1096,1115,3,168,84,0,1097,1098,5,15,
  	0,0,1098,1103,3,158,79,0,1099,1100,5,7,0,0,1100,1102,3,158,79,0,1101,
  	1099,1,0,0,0,1102,1105,1,0,0,0,1103,1101,1,0,0,0,1103,1104,1,0,0,0,1104,
  	1106,1,0,0,0,1105,1103,1,0,0,0,1106,1107,5,16,0,0,1107,1115,1,0,0,0,1108,
  	1109,3,160,80,0,1109,1110,3,158,79,5,1110,1115,1,0,0,0,1111,1112,3,44,
  	22,0,1112,1113,3,158,79,1,1113,1115,1,0,0,0,1114,1094,1,0,0,0,1114,1096,
  	1,0,0,0,1114,1097,1,0,0,0,1114,1108,1,0,0,0,1114,1111,1,0,0,0,1115,1138,
  	1,0,0,0,1116,1117,10,4,0,0,1117,1118,3,162,81,0,1118,1119,3,158,79,5,
  	1119,1137,1,0,0,0,1120,1121,10,3,0,0,1121,1122,3,166,83,0,1122,1123,3,
  	158,79,4,1123,1137,1,0,0,0,1124,1125,10,2,0,0,1125,1126,3,164,82,0,1126,
  	1127,3,158,79,3,1127,1137,1,0,0,0,1128,1129,10,7,0,0,1129,1130,5,38,0,
  	0,1130,1131,3,52,26,0,1131,1132,5,39,0,0,1132,1137,1,0,0,0,1133,1134,
  	10,6,0,0,1134,1135,5,75,0,0,1135,1137,5,147,0,0,1136,1116,1,0,0,0,1136,
  	1120,1,0,0,0,1136,1124,1,0,0,0,1136,1128,1,0,0,0,1136,1133,1,0,0,0,1137,
  	1140,1,0,0,0,1138,1136,1,0,0,0,1138,1139,1,0,0,0,1139,159,1,0,0,0,1140,
  	1138,1,0,0,0,1141,1145,5,83,0,0,1142,1145,5,112,0,0,1143,1145,5,41,0,
  	0,1144,1141,1,0,0,0,1144,1142,1,0,0,0,1144,1143,1,0,0,0,1145,161,1,0,
  	0,0,1146,1153,5,112,0,0,1147,1153,5,83,0,0,1148,1153,5,113,0,0,1149,1153,
  	5,114,0,0,1150,1153,5,111,0,0,1151,1153,5,110,0,0,1152,1146,1,0,0,0,1152,
  	1147,1,0,0,0,1152,1148,1,0,0,0,1152,1149,1,0,0,0,1152,1150,1,0,0,0,1152,
  	1151,1,0,0,0,1153,163,1,0,0,0,1154,1155,7,5,0,0,1155,165,1,0,0,0,1156,
  	1157,7,6,0,0,1157,167,1,0,0,0,1158,1167,5,139,0,0,1159,1167,5,143,0,0,
  	1160,1167,5,140,0,0,1161,1167,5,141,0,0,1162,1167,5,144,0,0,1163,1167,
  	5,142,0,0,1164,1167,5,145,0,0,1165,1167,5,146,0,0,1166,1158,1,0,0,0,1166,
  	1159,1,0,0,0,1166,1160,1,0,0,0,1166,1161,1,0,0,0,1166,1162,1,0,0,0,1166,
  	1163,1,0,0,0,1166,1164,1,0,0,0,1166,1165,1,0,0,0,1167,169,1,0,0,0,112,
  	173,175,177,186,191,207,225,231,253,259,267,273,283,292,309,318,329,335,
  	345,349,362,370,375,382,395,403,425,430,444,446,454,457,468,474,477,485,
  	489,491,503,509,517,520,523,529,532,535,543,548,550,556,564,568,576,585,
  	593,599,608,617,626,636,645,664,669,676,680,682,691,695,699,704,707,710,
  	720,722,731,734,738,746,750,752,764,782,789,792,796,829,840,858,861,864,
  	868,883,903,906,914,925,942,958,962,972,977,1058,1071,1086,1092,1103,
  	1114,1136,1138,1144,1152,1166
  };
  staticData->serializedATN = antlr4::atn::SerializedATNView(serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

  antlr4::atn::ATNDeserializer deserializer;
  staticData->atn = deserializer.deserialize(staticData->serializedATN);

  const size_t count = staticData->atn->getNumberOfDecisions();
  staticData->decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
  }
  lustreParserStaticData = staticData.release();
}

}

LustreParser::LustreParser(TokenStream *input) : LustreParser(input, antlr4::atn::ParserATNSimulatorOptions()) {}

LustreParser::LustreParser(TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options) : Parser(input) {
  LustreParser::initialize();
  _interpreter = new atn::ParserATNSimulator(this, *lustreParserStaticData->atn, lustreParserStaticData->decisionToDFA, lustreParserStaticData->sharedContextCache, options);
}

LustreParser::~LustreParser() {
  delete _interpreter;
}

const atn::ATN& LustreParser::getATN() const {
  return *lustreParserStaticData->atn;
}

std::string LustreParser::getGrammarFileName() const {
  return "Lustre.g4";
}

const std::vector<std::string>& LustreParser::getRuleNames() const {
  return lustreParserStaticData->ruleNames;
}

const dfa::Vocabulary& LustreParser::getVocabulary() const {
  return lustreParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView LustreParser::getSerializedATN() const {
  return lustreParserStaticData->serializedATN;
}


//----------------- ProgramContext ------------------------------------------------------------------

LustreParser::ProgramContext::ProgramContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LustreParser::IncludeContext* LustreParser::ProgramContext::include() {
  return getRuleContext<LustreParser::IncludeContext>(0);
}

std::vector<LustreParser::DeclsContext *> LustreParser::ProgramContext::decls() {
  return getRuleContexts<LustreParser::DeclsContext>();
}

LustreParser::DeclsContext* LustreParser::ProgramContext::decls(size_t i) {
  return getRuleContext<LustreParser::DeclsContext>(i);
}

std::vector<LustreParser::Pack_listContext *> LustreParser::ProgramContext::pack_list() {
  return getRuleContexts<LustreParser::Pack_listContext>();
}

LustreParser::Pack_listContext* LustreParser::ProgramContext::pack_list(size_t i) {
  return getRuleContext<LustreParser::Pack_listContext>(i);
}


size_t LustreParser::ProgramContext::getRuleIndex() const {
  return LustreParser::RuleProgram;
}

void LustreParser::ProgramContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProgram(this);
}

void LustreParser::ProgramContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProgram(this);
}


std::any LustreParser::ProgramContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitProgram(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::ProgramContext* LustreParser::program() {
  ProgramContext *_localctx = _tracker.createInstance<ProgramContext>(_ctx, getState());
  enterRule(_localctx, 0, LustreParser::RuleProgram);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(177);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LustreParser::T__0: {
        enterOuterAlt(_localctx, 1);
        setState(170);
        include();
        break;
      }

      case LustreParser::T__2:
      case LustreParser::T__10:
      case LustreParser::T__13:
      case LustreParser::T__18:
      case LustreParser::T__20:
      case LustreParser::T__21:
      case LustreParser::T__22:
      case LustreParser::T__36:
      case LustreParser::T__42:
      case LustreParser::T__43: {
        enterOuterAlt(_localctx, 2);
        setState(173); 
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(173);
          _errHandler->sync(this);
          switch (_input->LA(1)) {
            case LustreParser::T__13:
            case LustreParser::T__18:
            case LustreParser::T__20:
            case LustreParser::T__21:
            case LustreParser::T__22:
            case LustreParser::T__36:
            case LustreParser::T__42:
            case LustreParser::T__43: {
              setState(171);
              decls();
              break;
            }

            case LustreParser::T__2:
            case LustreParser::T__10: {
              setState(172);
              pack_list();
              break;
            }

          default:
            throw NoViableAltException(this);
          }
          setState(175); 
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 26525733242888) != 0));
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IncludeContext ------------------------------------------------------------------

LustreParser::IncludeContext::IncludeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LustreParser::IncludeContext::STRING() {
  return getToken(LustreParser::STRING, 0);
}


size_t LustreParser::IncludeContext::getRuleIndex() const {
  return LustreParser::RuleInclude;
}

void LustreParser::IncludeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInclude(this);
}

void LustreParser::IncludeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInclude(this);
}


std::any LustreParser::IncludeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitInclude(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::IncludeContext* LustreParser::include() {
  IncludeContext *_localctx = _tracker.createInstance<IncludeContext>(_ctx, getState());
  enterRule(_localctx, 2, LustreParser::RuleInclude);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(179);
    match(LustreParser::T__0);
    setState(180);
    match(LustreParser::STRING);
    setState(181);
    match(LustreParser::T__1);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pack_listContext ------------------------------------------------------------------

LustreParser::Pack_listContext::Pack_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<LustreParser::One_parkContext *> LustreParser::Pack_listContext::one_park() {
  return getRuleContexts<LustreParser::One_parkContext>();
}

LustreParser::One_parkContext* LustreParser::Pack_listContext::one_park(size_t i) {
  return getRuleContext<LustreParser::One_parkContext>(i);
}


size_t LustreParser::Pack_listContext::getRuleIndex() const {
  return LustreParser::RulePack_list;
}

void LustreParser::Pack_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPack_list(this);
}

void LustreParser::Pack_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPack_list(this);
}


std::any LustreParser::Pack_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitPack_list(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Pack_listContext* LustreParser::pack_list() {
  Pack_listContext *_localctx = _tracker.createInstance<Pack_listContext>(_ctx, getState());
  enterRule(_localctx, 4, LustreParser::RulePack_list);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(184); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(183);
              one_park();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(186); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 3, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- One_parkContext ------------------------------------------------------------------

LustreParser::One_parkContext::One_parkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LustreParser::Model_declContext* LustreParser::One_parkContext::model_decl() {
  return getRuleContext<LustreParser::Model_declContext>(0);
}

LustreParser::Pack_declContext* LustreParser::One_parkContext::pack_decl() {
  return getRuleContext<LustreParser::Pack_declContext>(0);
}

LustreParser::Pack_eqContext* LustreParser::One_parkContext::pack_eq() {
  return getRuleContext<LustreParser::Pack_eqContext>(0);
}


size_t LustreParser::One_parkContext::getRuleIndex() const {
  return LustreParser::RuleOne_park;
}

void LustreParser::One_parkContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOne_park(this);
}

void LustreParser::One_parkContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOne_park(this);
}


std::any LustreParser::One_parkContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitOne_park(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::One_parkContext* LustreParser::one_park() {
  One_parkContext *_localctx = _tracker.createInstance<One_parkContext>(_ctx, getState());
  enterRule(_localctx, 6, LustreParser::RuleOne_park);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(191);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 4, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(188);
      model_decl();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(189);
      pack_decl();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(190);
      pack_eq();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pack_declContext ------------------------------------------------------------------

LustreParser::Pack_declContext::Pack_declContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LustreParser::Pack_declContext::ID() {
  return getToken(LustreParser::ID, 0);
}

LustreParser::UsesContext* LustreParser::Pack_declContext::uses() {
  return getRuleContext<LustreParser::UsesContext>(0);
}

LustreParser::ProvidesContext* LustreParser::Pack_declContext::provides() {
  return getRuleContext<LustreParser::ProvidesContext>(0);
}

LustreParser::DeclsContext* LustreParser::Pack_declContext::decls() {
  return getRuleContext<LustreParser::DeclsContext>(0);
}


size_t LustreParser::Pack_declContext::getRuleIndex() const {
  return LustreParser::RulePack_decl;
}

void LustreParser::Pack_declContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPack_decl(this);
}

void LustreParser::Pack_declContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPack_decl(this);
}


std::any LustreParser::Pack_declContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitPack_decl(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Pack_declContext* LustreParser::pack_decl() {
  Pack_declContext *_localctx = _tracker.createInstance<Pack_declContext>(_ctx, getState());
  enterRule(_localctx, 8, LustreParser::RulePack_decl);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(193);
    match(LustreParser::T__2);
    setState(194);
    match(LustreParser::ID);
    setState(195);
    uses();
    setState(196);
    provides();
    setState(197);
    match(LustreParser::T__3);
    setState(198);
    decls();
    setState(199);
    match(LustreParser::T__4);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UsesContext ------------------------------------------------------------------

LustreParser::UsesContext::UsesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> LustreParser::UsesContext::ID() {
  return getTokens(LustreParser::ID);
}

tree::TerminalNode* LustreParser::UsesContext::ID(size_t i) {
  return getToken(LustreParser::ID, i);
}


size_t LustreParser::UsesContext::getRuleIndex() const {
  return LustreParser::RuleUses;
}

void LustreParser::UsesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUses(this);
}

void LustreParser::UsesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUses(this);
}


std::any LustreParser::UsesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitUses(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::UsesContext* LustreParser::uses() {
  UsesContext *_localctx = _tracker.createInstance<UsesContext>(_ctx, getState());
  enterRule(_localctx, 10, LustreParser::RuleUses);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(201);
    match(LustreParser::T__5);
    setState(202);
    match(LustreParser::ID);
    setState(207);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == LustreParser::T__6) {
      setState(203);
      match(LustreParser::T__6);
      setState(204);
      match(LustreParser::ID);
      setState(209);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(210);
    match(LustreParser::T__1);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pack_eqContext ------------------------------------------------------------------

LustreParser::Pack_eqContext::Pack_eqContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> LustreParser::Pack_eqContext::ID() {
  return getTokens(LustreParser::ID);
}

tree::TerminalNode* LustreParser::Pack_eqContext::ID(size_t i) {
  return getToken(LustreParser::ID, i);
}


size_t LustreParser::Pack_eqContext::getRuleIndex() const {
  return LustreParser::RulePack_eq;
}

void LustreParser::Pack_eqContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPack_eq(this);
}

void LustreParser::Pack_eqContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPack_eq(this);
}


std::any LustreParser::Pack_eqContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitPack_eq(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Pack_eqContext* LustreParser::pack_eq() {
  Pack_eqContext *_localctx = _tracker.createInstance<Pack_eqContext>(_ctx, getState());
  enterRule(_localctx, 12, LustreParser::RulePack_eq);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(212);
    match(LustreParser::T__2);
    setState(213);
    match(LustreParser::ID);
    setState(214);
    _la = _input->LA(1);
    if (!(_la == LustreParser::T__7

    || _la == LustreParser::T__8)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(215);
    match(LustreParser::ID);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ProvidesContext ------------------------------------------------------------------

LustreParser::ProvidesContext::ProvidesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<LustreParser::ProvideContext *> LustreParser::ProvidesContext::provide() {
  return getRuleContexts<LustreParser::ProvideContext>();
}

LustreParser::ProvideContext* LustreParser::ProvidesContext::provide(size_t i) {
  return getRuleContext<LustreParser::ProvideContext>(i);
}


size_t LustreParser::ProvidesContext::getRuleIndex() const {
  return LustreParser::RuleProvides;
}

void LustreParser::ProvidesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProvides(this);
}

void LustreParser::ProvidesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProvides(this);
}


std::any LustreParser::ProvidesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitProvides(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::ProvidesContext* LustreParser::provides() {
  ProvidesContext *_localctx = _tracker.createInstance<ProvidesContext>(_ctx, getState());
  enterRule(_localctx, 14, LustreParser::RuleProvides);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(217);
    match(LustreParser::T__9);
    setState(218);
    provide();
    setState(219);
    match(LustreParser::T__1);
    setState(225);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 26525726408704) != 0)) {
      setState(220);
      provide();
      setState(221);
      match(LustreParser::T__1);
      setState(227);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ProvideContext ------------------------------------------------------------------

LustreParser::ProvideContext::ProvideContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LustreParser::Const_blockContext* LustreParser::ProvideContext::const_block() {
  return getRuleContext<LustreParser::Const_blockContext>(0);
}

LustreParser::Type_blockContext* LustreParser::ProvideContext::type_block() {
  return getRuleContext<LustreParser::Type_blockContext>(0);
}

LustreParser::User_op_provideContext* LustreParser::ProvideContext::user_op_provide() {
  return getRuleContext<LustreParser::User_op_provideContext>(0);
}


size_t LustreParser::ProvideContext::getRuleIndex() const {
  return LustreParser::RuleProvide;
}

void LustreParser::ProvideContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProvide(this);
}

void LustreParser::ProvideContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProvide(this);
}


std::any LustreParser::ProvideContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitProvide(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::ProvideContext* LustreParser::provide() {
  ProvideContext *_localctx = _tracker.createInstance<ProvideContext>(_ctx, getState());
  enterRule(_localctx, 16, LustreParser::RuleProvide);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(231);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LustreParser::T__36: {
        enterOuterAlt(_localctx, 1);
        setState(228);
        const_block();
        break;
      }

      case LustreParser::T__22: {
        enterOuterAlt(_localctx, 2);
        setState(229);
        type_block();
        break;
      }

      case LustreParser::T__42:
      case LustreParser::T__43: {
        enterOuterAlt(_localctx, 3);
        setState(230);
        user_op_provide();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Model_declContext ------------------------------------------------------------------

LustreParser::Model_declContext::Model_declContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LustreParser::Model_declContext::ID() {
  return getToken(LustreParser::ID, 0);
}

LustreParser::UsesContext* LustreParser::Model_declContext::uses() {
  return getRuleContext<LustreParser::UsesContext>(0);
}

LustreParser::User_op_provideContext* LustreParser::Model_declContext::user_op_provide() {
  return getRuleContext<LustreParser::User_op_provideContext>(0);
}

LustreParser::DeclsContext* LustreParser::Model_declContext::decls() {
  return getRuleContext<LustreParser::DeclsContext>(0);
}


size_t LustreParser::Model_declContext::getRuleIndex() const {
  return LustreParser::RuleModel_decl;
}

void LustreParser::Model_declContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModel_decl(this);
}

void LustreParser::Model_declContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModel_decl(this);
}


std::any LustreParser::Model_declContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitModel_decl(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Model_declContext* LustreParser::model_decl() {
  Model_declContext *_localctx = _tracker.createInstance<Model_declContext>(_ctx, getState());
  enterRule(_localctx, 18, LustreParser::RuleModel_decl);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(233);
    match(LustreParser::T__10);
    setState(234);
    match(LustreParser::ID);
    setState(235);
    uses();
    setState(236);
    match(LustreParser::T__11);
    setState(237);
    user_op_provide();
    setState(238);
    match(LustreParser::T__3);
    setState(239);
    decls();
    setState(240);
    match(LustreParser::T__4);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- User_op_provideContext ------------------------------------------------------------------

LustreParser::User_op_provideContext::User_op_provideContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LustreParser::Op_kindContext* LustreParser::User_op_provideContext::op_kind() {
  return getRuleContext<LustreParser::Op_kindContext>(0);
}

tree::TerminalNode* LustreParser::User_op_provideContext::ID() {
  return getToken(LustreParser::ID, 0);
}

std::vector<LustreParser::ParamsContext *> LustreParser::User_op_provideContext::params() {
  return getRuleContexts<LustreParser::ParamsContext>();
}

LustreParser::ParamsContext* LustreParser::User_op_provideContext::params(size_t i) {
  return getRuleContext<LustreParser::ParamsContext>(i);
}


size_t LustreParser::User_op_provideContext::getRuleIndex() const {
  return LustreParser::RuleUser_op_provide;
}

void LustreParser::User_op_provideContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUser_op_provide(this);
}

void LustreParser::User_op_provideContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUser_op_provide(this);
}


std::any LustreParser::User_op_provideContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitUser_op_provide(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::User_op_provideContext* LustreParser::user_op_provide() {
  User_op_provideContext *_localctx = _tracker.createInstance<User_op_provideContext>(_ctx, getState());
  enterRule(_localctx, 20, LustreParser::RuleUser_op_provide);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(242);
    op_kind();
    setState(243);
    match(LustreParser::ID);
    setState(244);
    params();
    setState(245);
    match(LustreParser::T__12);
    setState(246);
    params();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DeclsContext ------------------------------------------------------------------

LustreParser::DeclsContext::DeclsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::DeclsContext::getRuleIndex() const {
  return LustreParser::RuleDecls;
}

void LustreParser::DeclsContext::copyFrom(DeclsContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Decls_typeContext ------------------------------------------------------------------

LustreParser::Type_blockContext* LustreParser::Decls_typeContext::type_block() {
  return getRuleContext<LustreParser::Type_blockContext>(0);
}

LustreParser::Decls_typeContext::Decls_typeContext(DeclsContext *ctx) { copyFrom(ctx); }

void LustreParser::Decls_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDecls_type(this);
}
void LustreParser::Decls_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDecls_type(this);
}

std::any LustreParser::Decls_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitDecls_type(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Decls_user_opContext ------------------------------------------------------------------

LustreParser::User_op_declContext* LustreParser::Decls_user_opContext::user_op_decl() {
  return getRuleContext<LustreParser::User_op_declContext>(0);
}

LustreParser::Decls_user_opContext::Decls_user_opContext(DeclsContext *ctx) { copyFrom(ctx); }

void LustreParser::Decls_user_opContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDecls_user_op(this);
}
void LustreParser::Decls_user_opContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDecls_user_op(this);
}

std::any LustreParser::Decls_user_opContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitDecls_user_op(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Decls_import_opContext ------------------------------------------------------------------

LustreParser::Import_op_declContext* LustreParser::Decls_import_opContext::import_op_decl() {
  return getRuleContext<LustreParser::Import_op_declContext>(0);
}

LustreParser::Decls_import_opContext::Decls_import_opContext(DeclsContext *ctx) { copyFrom(ctx); }

void LustreParser::Decls_import_opContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDecls_import_op(this);
}
void LustreParser::Decls_import_opContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDecls_import_op(this);
}

std::any LustreParser::Decls_import_opContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitDecls_import_op(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Decls_constContext ------------------------------------------------------------------

LustreParser::Const_blockContext* LustreParser::Decls_constContext::const_block() {
  return getRuleContext<LustreParser::Const_blockContext>(0);
}

LustreParser::Decls_constContext::Decls_constContext(DeclsContext *ctx) { copyFrom(ctx); }

void LustreParser::Decls_constContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDecls_const(this);
}
void LustreParser::Decls_constContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDecls_const(this);
}

std::any LustreParser::Decls_constContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitDecls_const(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Decls_kind2Context ------------------------------------------------------------------

LustreParser::Kind2_declContext* LustreParser::Decls_kind2Context::kind2_decl() {
  return getRuleContext<LustreParser::Kind2_declContext>(0);
}

LustreParser::Decls_kind2Context::Decls_kind2Context(DeclsContext *ctx) { copyFrom(ctx); }

void LustreParser::Decls_kind2Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDecls_kind2(this);
}
void LustreParser::Decls_kind2Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDecls_kind2(this);
}

std::any LustreParser::Decls_kind2Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitDecls_kind2(this);
  else
    return visitor->visitChildren(this);
}
LustreParser::DeclsContext* LustreParser::decls() {
  DeclsContext *_localctx = _tracker.createInstance<DeclsContext>(_ctx, getState());
  enterRule(_localctx, 22, LustreParser::RuleDecls);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(253);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 8, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<LustreParser::Decls_typeContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(248);
      type_block();
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<LustreParser::Decls_constContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(249);
      const_block();
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<LustreParser::Decls_import_opContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(250);
      import_op_decl();
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<LustreParser::Decls_user_opContext>(_localctx);
      enterOuterAlt(_localctx, 4);
      setState(251);
      user_op_decl();
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<LustreParser::Decls_kind2Context>(_localctx);
      enterOuterAlt(_localctx, 5);
      setState(252);
      kind2_decl();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Kind2_declContext ------------------------------------------------------------------

LustreParser::Kind2_declContext::Kind2_declContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::Kind2_declContext::getRuleIndex() const {
  return LustreParser::RuleKind2_decl;
}

void LustreParser::Kind2_declContext::copyFrom(Kind2_declContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Decls_guaranteeContext ------------------------------------------------------------------

LustreParser::Guarantee_declContext* LustreParser::Decls_guaranteeContext::guarantee_decl() {
  return getRuleContext<LustreParser::Guarantee_declContext>(0);
}

LustreParser::Decls_guaranteeContext::Decls_guaranteeContext(Kind2_declContext *ctx) { copyFrom(ctx); }

void LustreParser::Decls_guaranteeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDecls_guarantee(this);
}
void LustreParser::Decls_guaranteeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDecls_guarantee(this);
}

std::any LustreParser::Decls_guaranteeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitDecls_guarantee(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Decls_ghost_varContext ------------------------------------------------------------------

LustreParser::Var_declContext* LustreParser::Decls_ghost_varContext::var_decl() {
  return getRuleContext<LustreParser::Var_declContext>(0);
}

LustreParser::Decls_ghost_varContext::Decls_ghost_varContext(Kind2_declContext *ctx) { copyFrom(ctx); }

void LustreParser::Decls_ghost_varContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDecls_ghost_var(this);
}
void LustreParser::Decls_ghost_varContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDecls_ghost_var(this);
}

std::any LustreParser::Decls_ghost_varContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitDecls_ghost_var(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Decls_modeContext ------------------------------------------------------------------

LustreParser::Mode_declContext* LustreParser::Decls_modeContext::mode_decl() {
  return getRuleContext<LustreParser::Mode_declContext>(0);
}

LustreParser::Decls_modeContext::Decls_modeContext(Kind2_declContext *ctx) { copyFrom(ctx); }

void LustreParser::Decls_modeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDecls_mode(this);
}
void LustreParser::Decls_modeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDecls_mode(this);
}

std::any LustreParser::Decls_modeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitDecls_mode(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Decls_assumeContext ------------------------------------------------------------------

LustreParser::Assume_declContext* LustreParser::Decls_assumeContext::assume_decl() {
  return getRuleContext<LustreParser::Assume_declContext>(0);
}

LustreParser::Decls_assumeContext::Decls_assumeContext(Kind2_declContext *ctx) { copyFrom(ctx); }

void LustreParser::Decls_assumeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDecls_assume(this);
}
void LustreParser::Decls_assumeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDecls_assume(this);
}

std::any LustreParser::Decls_assumeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitDecls_assume(this);
  else
    return visitor->visitChildren(this);
}
LustreParser::Kind2_declContext* LustreParser::kind2_decl() {
  Kind2_declContext *_localctx = _tracker.createInstance<Kind2_declContext>(_ctx, getState());
  enterRule(_localctx, 24, LustreParser::RuleKind2_decl);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(259);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LustreParser::T__13: {
        _localctx = _tracker.createInstance<LustreParser::Decls_modeContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(255);
        mode_decl();
        break;
      }

      case LustreParser::T__18: {
        _localctx = _tracker.createInstance<LustreParser::Decls_ghost_varContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(256);
        var_decl();
        break;
      }

      case LustreParser::T__20: {
        _localctx = _tracker.createInstance<LustreParser::Decls_assumeContext>(_localctx);
        enterOuterAlt(_localctx, 3);
        setState(257);
        assume_decl();
        break;
      }

      case LustreParser::T__21: {
        _localctx = _tracker.createInstance<LustreParser::Decls_guaranteeContext>(_localctx);
        enterOuterAlt(_localctx, 4);
        setState(258);
        guarantee_decl();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Mode_declContext ------------------------------------------------------------------

LustreParser::Mode_declContext::Mode_declContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LustreParser::Mode_declContext::ID() {
  return getToken(LustreParser::ID, 0);
}

std::vector<LustreParser::RequirementContext *> LustreParser::Mode_declContext::requirement() {
  return getRuleContexts<LustreParser::RequirementContext>();
}

LustreParser::RequirementContext* LustreParser::Mode_declContext::requirement(size_t i) {
  return getRuleContext<LustreParser::RequirementContext>(i);
}

std::vector<LustreParser::AssuranceContext *> LustreParser::Mode_declContext::assurance() {
  return getRuleContexts<LustreParser::AssuranceContext>();
}

LustreParser::AssuranceContext* LustreParser::Mode_declContext::assurance(size_t i) {
  return getRuleContext<LustreParser::AssuranceContext>(i);
}


size_t LustreParser::Mode_declContext::getRuleIndex() const {
  return LustreParser::RuleMode_decl;
}

void LustreParser::Mode_declContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMode_decl(this);
}

void LustreParser::Mode_declContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMode_decl(this);
}


std::any LustreParser::Mode_declContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitMode_decl(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Mode_declContext* LustreParser::mode_decl() {
  Mode_declContext *_localctx = _tracker.createInstance<Mode_declContext>(_ctx, getState());
  enterRule(_localctx, 26, LustreParser::RuleMode_decl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(261);
    match(LustreParser::T__13);
    setState(262);
    match(LustreParser::ID);
    setState(263);
    match(LustreParser::T__14);
    setState(267);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == LustreParser::T__16) {
      setState(264);
      requirement();
      setState(269);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(273);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == LustreParser::T__17) {
      setState(270);
      assurance();
      setState(275);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(276);
    match(LustreParser::T__15);
    setState(277);
    match(LustreParser::T__1);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RequirementContext ------------------------------------------------------------------

LustreParser::RequirementContext::RequirementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::RequirementContext::getRuleIndex() const {
  return LustreParser::RuleRequirement;
}

void LustreParser::RequirementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRequirement(this);
}

void LustreParser::RequirementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRequirement(this);
}


std::any LustreParser::RequirementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitRequirement(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::RequirementContext* LustreParser::requirement() {
  RequirementContext *_localctx = _tracker.createInstance<RequirementContext>(_ctx, getState());
  enterRule(_localctx, 28, LustreParser::RuleRequirement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(279);
    match(LustreParser::T__16);
    setState(283);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 12, _ctx);
    while (alt != 1 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1 + 1) {
        setState(280);
        matchWildcard(); 
      }
      setState(285);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 12, _ctx);
    }
    setState(286);
    match(LustreParser::T__1);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssuranceContext ------------------------------------------------------------------

LustreParser::AssuranceContext::AssuranceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::AssuranceContext::getRuleIndex() const {
  return LustreParser::RuleAssurance;
}

void LustreParser::AssuranceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssurance(this);
}

void LustreParser::AssuranceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssurance(this);
}


std::any LustreParser::AssuranceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitAssurance(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::AssuranceContext* LustreParser::assurance() {
  AssuranceContext *_localctx = _tracker.createInstance<AssuranceContext>(_ctx, getState());
  enterRule(_localctx, 30, LustreParser::RuleAssurance);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(288);
    match(LustreParser::T__17);
    setState(292);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 13, _ctx);
    while (alt != 1 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1 + 1) {
        setState(289);
        matchWildcard(); 
      }
      setState(294);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 13, _ctx);
    }
    setState(295);
    match(LustreParser::T__1);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Var_declContext ------------------------------------------------------------------

LustreParser::Var_declContext::Var_declContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LustreParser::Var_declContext::ID() {
  return getToken(LustreParser::ID, 0);
}

LustreParser::TypeContext* LustreParser::Var_declContext::type() {
  return getRuleContext<LustreParser::TypeContext>(0);
}

LustreParser::ExprContext* LustreParser::Var_declContext::expr() {
  return getRuleContext<LustreParser::ExprContext>(0);
}


size_t LustreParser::Var_declContext::getRuleIndex() const {
  return LustreParser::RuleVar_decl;
}

void LustreParser::Var_declContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVar_decl(this);
}

void LustreParser::Var_declContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVar_decl(this);
}


std::any LustreParser::Var_declContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitVar_decl(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Var_declContext* LustreParser::var_decl() {
  Var_declContext *_localctx = _tracker.createInstance<Var_declContext>(_ctx, getState());
  enterRule(_localctx, 32, LustreParser::RuleVar_decl);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(297);
    match(LustreParser::T__18);
    setState(298);
    match(LustreParser::ID);
    setState(299);
    match(LustreParser::T__19);
    setState(300);
    type(0);
    setState(301);
    match(LustreParser::T__7);
    setState(302);
    expr();
    setState(303);
    match(LustreParser::T__1);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Assume_declContext ------------------------------------------------------------------

LustreParser::Assume_declContext::Assume_declContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::Assume_declContext::getRuleIndex() const {
  return LustreParser::RuleAssume_decl;
}

void LustreParser::Assume_declContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssume_decl(this);
}

void LustreParser::Assume_declContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssume_decl(this);
}


std::any LustreParser::Assume_declContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitAssume_decl(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Assume_declContext* LustreParser::assume_decl() {
  Assume_declContext *_localctx = _tracker.createInstance<Assume_declContext>(_ctx, getState());
  enterRule(_localctx, 34, LustreParser::RuleAssume_decl);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(305);
    match(LustreParser::T__20);
    setState(309);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 14, _ctx);
    while (alt != 1 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1 + 1) {
        setState(306);
        matchWildcard(); 
      }
      setState(311);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 14, _ctx);
    }
    setState(312);
    match(LustreParser::T__1);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Guarantee_declContext ------------------------------------------------------------------

LustreParser::Guarantee_declContext::Guarantee_declContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::Guarantee_declContext::getRuleIndex() const {
  return LustreParser::RuleGuarantee_decl;
}

void LustreParser::Guarantee_declContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGuarantee_decl(this);
}

void LustreParser::Guarantee_declContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGuarantee_decl(this);
}


std::any LustreParser::Guarantee_declContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitGuarantee_decl(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Guarantee_declContext* LustreParser::guarantee_decl() {
  Guarantee_declContext *_localctx = _tracker.createInstance<Guarantee_declContext>(_ctx, getState());
  enterRule(_localctx, 36, LustreParser::RuleGuarantee_decl);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(314);
    match(LustreParser::T__21);
    setState(318);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 15, _ctx);
    while (alt != 1 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1 + 1) {
        setState(315);
        matchWildcard(); 
      }
      setState(320);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 15, _ctx);
    }
    setState(321);
    match(LustreParser::T__1);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Type_blockContext ------------------------------------------------------------------

LustreParser::Type_blockContext::Type_blockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<LustreParser::Type_declContext *> LustreParser::Type_blockContext::type_decl() {
  return getRuleContexts<LustreParser::Type_declContext>();
}

LustreParser::Type_declContext* LustreParser::Type_blockContext::type_decl(size_t i) {
  return getRuleContext<LustreParser::Type_declContext>(i);
}


size_t LustreParser::Type_blockContext::getRuleIndex() const {
  return LustreParser::RuleType_block;
}

void LustreParser::Type_blockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType_block(this);
}

void LustreParser::Type_blockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType_block(this);
}


std::any LustreParser::Type_blockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitType_block(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Type_blockContext* LustreParser::type_block() {
  Type_blockContext *_localctx = _tracker.createInstance<Type_blockContext>(_ctx, getState());
  enterRule(_localctx, 38, LustreParser::RuleType_block);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(323);
    match(LustreParser::T__22);
    setState(329);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == LustreParser::ID) {
      setState(324);
      type_decl();
      setState(325);
      match(LustreParser::T__1);
      setState(331);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Type_declContext ------------------------------------------------------------------

LustreParser::Type_declContext::Type_declContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LustreParser::Type_declContext::ID() {
  return getToken(LustreParser::ID, 0);
}

LustreParser::Type_defContext* LustreParser::Type_declContext::type_def() {
  return getRuleContext<LustreParser::Type_defContext>(0);
}


size_t LustreParser::Type_declContext::getRuleIndex() const {
  return LustreParser::RuleType_decl;
}

void LustreParser::Type_declContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType_decl(this);
}

void LustreParser::Type_declContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType_decl(this);
}


std::any LustreParser::Type_declContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitType_decl(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Type_declContext* LustreParser::type_decl() {
  Type_declContext *_localctx = _tracker.createInstance<Type_declContext>(_ctx, getState());
  enterRule(_localctx, 40, LustreParser::RuleType_decl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(332);
    match(LustreParser::ID);
    setState(335);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == LustreParser::T__7) {
      setState(333);
      match(LustreParser::T__7);
      setState(334);
      type_def();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Type_defContext ------------------------------------------------------------------

LustreParser::Type_defContext::Type_defContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::Type_defContext::getRuleIndex() const {
  return LustreParser::RuleType_def;
}

void LustreParser::Type_defContext::copyFrom(Type_defContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Type_def_typeContext ------------------------------------------------------------------

LustreParser::TypeContext* LustreParser::Type_def_typeContext::type() {
  return getRuleContext<LustreParser::TypeContext>(0);
}

LustreParser::Type_def_typeContext::Type_def_typeContext(Type_defContext *ctx) { copyFrom(ctx); }

void LustreParser::Type_def_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType_def_type(this);
}
void LustreParser::Type_def_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType_def_type(this);
}

std::any LustreParser::Type_def_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitType_def_type(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Type_def_enumContext ------------------------------------------------------------------

std::vector<tree::TerminalNode *> LustreParser::Type_def_enumContext::ID() {
  return getTokens(LustreParser::ID);
}

tree::TerminalNode* LustreParser::Type_def_enumContext::ID(size_t i) {
  return getToken(LustreParser::ID, i);
}

LustreParser::Type_def_enumContext::Type_def_enumContext(Type_defContext *ctx) { copyFrom(ctx); }

void LustreParser::Type_def_enumContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType_def_enum(this);
}
void LustreParser::Type_def_enumContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType_def_enum(this);
}

std::any LustreParser::Type_def_enumContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitType_def_enum(this);
  else
    return visitor->visitChildren(this);
}
LustreParser::Type_defContext* LustreParser::type_def() {
  Type_defContext *_localctx = _tracker.createInstance<Type_defContext>(_ctx, getState());
  enterRule(_localctx, 42, LustreParser::RuleType_def);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(349);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LustreParser::T__24:
      case LustreParser::T__26:
      case LustreParser::T__27:
      case LustreParser::T__28:
      case LustreParser::T__29:
      case LustreParser::T__30:
      case LustreParser::T__31:
      case LustreParser::T__32:
      case LustreParser::T__33:
      case LustreParser::T__34:
      case LustreParser::ID: {
        _localctx = _tracker.createInstance<LustreParser::Type_def_typeContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(337);
        type(0);
        break;
      }

      case LustreParser::T__23: {
        _localctx = _tracker.createInstance<LustreParser::Type_def_enumContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(338);
        match(LustreParser::T__23);
        setState(339);
        match(LustreParser::T__24);
        setState(340);
        match(LustreParser::ID);
        setState(345);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == LustreParser::T__6) {
          setState(341);
          match(LustreParser::T__6);
          setState(342);
          match(LustreParser::ID);
          setState(347);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(348);
        match(LustreParser::T__25);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeContext ------------------------------------------------------------------

LustreParser::TypeContext::TypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::TypeContext::getRuleIndex() const {
  return LustreParser::RuleType;
}

void LustreParser::TypeContext::copyFrom(TypeContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Type_realContext ------------------------------------------------------------------

LustreParser::Type_realContext::Type_realContext(TypeContext *ctx) { copyFrom(ctx); }

void LustreParser::Type_realContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType_real(this);
}
void LustreParser::Type_realContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType_real(this);
}

std::any LustreParser::Type_realContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitType_real(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Type_floatContext ------------------------------------------------------------------

LustreParser::Type_floatContext::Type_floatContext(TypeContext *ctx) { copyFrom(ctx); }

void LustreParser::Type_floatContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType_float(this);
}
void LustreParser::Type_floatContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType_float(this);
}

std::any LustreParser::Type_floatContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitType_float(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Type_boolContext ------------------------------------------------------------------

LustreParser::Type_boolContext::Type_boolContext(TypeContext *ctx) { copyFrom(ctx); }

void LustreParser::Type_boolContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType_bool(this);
}
void LustreParser::Type_boolContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType_bool(this);
}

std::any LustreParser::Type_boolContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitType_bool(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Type_arrayContext ------------------------------------------------------------------

LustreParser::TypeContext* LustreParser::Type_arrayContext::type() {
  return getRuleContext<LustreParser::TypeContext>(0);
}

LustreParser::Const_exprContext* LustreParser::Type_arrayContext::const_expr() {
  return getRuleContext<LustreParser::Const_exprContext>(0);
}

LustreParser::Type_arrayContext::Type_arrayContext(TypeContext *ctx) { copyFrom(ctx); }

void LustreParser::Type_arrayContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType_array(this);
}
void LustreParser::Type_arrayContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType_array(this);
}

std::any LustreParser::Type_arrayContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitType_array(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Type_charContext ------------------------------------------------------------------

LustreParser::Type_charContext::Type_charContext(TypeContext *ctx) { copyFrom(ctx); }

void LustreParser::Type_charContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType_char(this);
}
void LustreParser::Type_charContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType_char(this);
}

std::any LustreParser::Type_charContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitType_char(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Type_idContext ------------------------------------------------------------------

tree::TerminalNode* LustreParser::Type_idContext::ID() {
  return getToken(LustreParser::ID, 0);
}

LustreParser::Type_idContext::Type_idContext(TypeContext *ctx) { copyFrom(ctx); }

void LustreParser::Type_idContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType_id(this);
}
void LustreParser::Type_idContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType_id(this);
}

std::any LustreParser::Type_idContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitType_id(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Type_ushortContext ------------------------------------------------------------------

LustreParser::Type_ushortContext::Type_ushortContext(TypeContext *ctx) { copyFrom(ctx); }

void LustreParser::Type_ushortContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType_ushort(this);
}
void LustreParser::Type_ushortContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType_ushort(this);
}

std::any LustreParser::Type_ushortContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitType_ushort(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Type_uintContext ------------------------------------------------------------------

LustreParser::Type_uintContext::Type_uintContext(TypeContext *ctx) { copyFrom(ctx); }

void LustreParser::Type_uintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType_uint(this);
}
void LustreParser::Type_uintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType_uint(this);
}

std::any LustreParser::Type_uintContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitType_uint(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Type_shortContext ------------------------------------------------------------------

LustreParser::Type_shortContext::Type_shortContext(TypeContext *ctx) { copyFrom(ctx); }

void LustreParser::Type_shortContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType_short(this);
}
void LustreParser::Type_shortContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType_short(this);
}

std::any LustreParser::Type_shortContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitType_short(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Type_structContext ------------------------------------------------------------------

std::vector<LustreParser::Field_declContext *> LustreParser::Type_structContext::field_decl() {
  return getRuleContexts<LustreParser::Field_declContext>();
}

LustreParser::Field_declContext* LustreParser::Type_structContext::field_decl(size_t i) {
  return getRuleContext<LustreParser::Field_declContext>(i);
}

LustreParser::Type_structContext::Type_structContext(TypeContext *ctx) { copyFrom(ctx); }

void LustreParser::Type_structContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType_struct(this);
}
void LustreParser::Type_structContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType_struct(this);
}

std::any LustreParser::Type_structContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitType_struct(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Type_intContext ------------------------------------------------------------------

LustreParser::Type_intContext::Type_intContext(TypeContext *ctx) { copyFrom(ctx); }

void LustreParser::Type_intContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType_int(this);
}
void LustreParser::Type_intContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType_int(this);
}

std::any LustreParser::Type_intContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitType_int(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::TypeContext* LustreParser::type() {
   return type(0);
}

LustreParser::TypeContext* LustreParser::type(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  LustreParser::TypeContext *_localctx = _tracker.createInstance<TypeContext>(_ctx, parentState);
  LustreParser::TypeContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 44;
  enterRecursionRule(_localctx, 44, LustreParser::RuleType, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(375);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LustreParser::T__26: {
        _localctx = _tracker.createInstance<Type_intContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;

        setState(352);
        match(LustreParser::T__26);
        break;
      }

      case LustreParser::T__27: {
        _localctx = _tracker.createInstance<Type_boolContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        setState(353);
        match(LustreParser::T__27);
        break;
      }

      case LustreParser::T__28: {
        _localctx = _tracker.createInstance<Type_charContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        setState(354);
        match(LustreParser::T__28);
        break;
      }

      case LustreParser::T__29: {
        _localctx = _tracker.createInstance<Type_shortContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        setState(355);
        match(LustreParser::T__29);
        break;
      }

      case LustreParser::T__30: {
        _localctx = _tracker.createInstance<Type_ushortContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        setState(356);
        match(LustreParser::T__30);
        break;
      }

      case LustreParser::T__31: {
        _localctx = _tracker.createInstance<Type_uintContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        setState(357);
        match(LustreParser::T__31);
        break;
      }

      case LustreParser::T__32: {
        _localctx = _tracker.createInstance<Type_floatContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        setState(358);
        match(LustreParser::T__32);
        break;
      }

      case LustreParser::T__33: {
        _localctx = _tracker.createInstance<Type_realContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        setState(359);
        match(LustreParser::T__33);
        break;
      }

      case LustreParser::ID: {
        _localctx = _tracker.createInstance<Type_idContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        setState(360);
        match(LustreParser::ID);
        break;
      }

      case LustreParser::T__24:
      case LustreParser::T__34: {
        _localctx = _tracker.createInstance<Type_structContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        setState(362);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == LustreParser::T__34) {
          setState(361);
          match(LustreParser::T__34);
        }
        setState(364);
        match(LustreParser::T__24);
        setState(365);
        field_decl();
        setState(370);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == LustreParser::T__1

        || _la == LustreParser::T__6) {
          setState(366);
          _la = _input->LA(1);
          if (!(_la == LustreParser::T__1

          || _la == LustreParser::T__6)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(367);
          field_decl();
          setState(372);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(373);
        match(LustreParser::T__25);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    _ctx->stop = _input->LT(-1);
    setState(382);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 23, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        auto newContext = _tracker.createInstance<Type_arrayContext>(_tracker.createInstance<TypeContext>(parentContext, parentState));
        _localctx = newContext;
        pushNewRecursionContext(newContext, startState, RuleType);
        setState(377);

        if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
        setState(378);
        match(LustreParser::T__35);
        setState(379);
        const_expr(0); 
      }
      setState(384);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 23, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Field_declContext ------------------------------------------------------------------

LustreParser::Field_declContext::Field_declContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LustreParser::Field_declContext::ID() {
  return getToken(LustreParser::ID, 0);
}

LustreParser::TypeContext* LustreParser::Field_declContext::type() {
  return getRuleContext<LustreParser::TypeContext>(0);
}


size_t LustreParser::Field_declContext::getRuleIndex() const {
  return LustreParser::RuleField_decl;
}

void LustreParser::Field_declContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterField_decl(this);
}

void LustreParser::Field_declContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitField_decl(this);
}


std::any LustreParser::Field_declContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitField_decl(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Field_declContext* LustreParser::field_decl() {
  Field_declContext *_localctx = _tracker.createInstance<Field_declContext>(_ctx, getState());
  enterRule(_localctx, 46, LustreParser::RuleField_decl);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(385);
    match(LustreParser::ID);
    setState(386);
    match(LustreParser::T__19);
    setState(387);
    type(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Const_blockContext ------------------------------------------------------------------

LustreParser::Const_blockContext::Const_blockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<LustreParser::Const_declContext *> LustreParser::Const_blockContext::const_decl() {
  return getRuleContexts<LustreParser::Const_declContext>();
}

LustreParser::Const_declContext* LustreParser::Const_blockContext::const_decl(size_t i) {
  return getRuleContext<LustreParser::Const_declContext>(i);
}


size_t LustreParser::Const_blockContext::getRuleIndex() const {
  return LustreParser::RuleConst_block;
}

void LustreParser::Const_blockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConst_block(this);
}

void LustreParser::Const_blockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConst_block(this);
}


std::any LustreParser::Const_blockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitConst_block(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Const_blockContext* LustreParser::const_block() {
  Const_blockContext *_localctx = _tracker.createInstance<Const_blockContext>(_ctx, getState());
  enterRule(_localctx, 48, LustreParser::RuleConst_block);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(389);
    match(LustreParser::T__36);
    setState(395);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == LustreParser::ID) {
      setState(390);
      const_decl();
      setState(391);
      match(LustreParser::T__1);
      setState(397);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Const_declContext ------------------------------------------------------------------

LustreParser::Const_declContext::Const_declContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LustreParser::Const_declContext::ID() {
  return getToken(LustreParser::ID, 0);
}

LustreParser::TypeContext* LustreParser::Const_declContext::type() {
  return getRuleContext<LustreParser::TypeContext>(0);
}

LustreParser::Const_exprContext* LustreParser::Const_declContext::const_expr() {
  return getRuleContext<LustreParser::Const_exprContext>(0);
}


size_t LustreParser::Const_declContext::getRuleIndex() const {
  return LustreParser::RuleConst_decl;
}

void LustreParser::Const_declContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConst_decl(this);
}

void LustreParser::Const_declContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConst_decl(this);
}


std::any LustreParser::Const_declContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitConst_decl(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Const_declContext* LustreParser::const_decl() {
  Const_declContext *_localctx = _tracker.createInstance<Const_declContext>(_ctx, getState());
  enterRule(_localctx, 50, LustreParser::RuleConst_decl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(398);
    match(LustreParser::ID);
    setState(399);
    match(LustreParser::T__19);
    setState(400);
    type(0);
    setState(403);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == LustreParser::T__7) {
      setState(401);
      match(LustreParser::T__7);
      setState(402);
      const_expr(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Const_exprContext ------------------------------------------------------------------

LustreParser::Const_exprContext::Const_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::Const_exprContext::getRuleIndex() const {
  return LustreParser::RuleConst_expr;
}

void LustreParser::Const_exprContext::copyFrom(Const_exprContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Const_idContext ------------------------------------------------------------------

tree::TerminalNode* LustreParser::Const_idContext::ID() {
  return getToken(LustreParser::ID, 0);
}

LustreParser::Const_idContext::Const_idContext(Const_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Const_idContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConst_id(this);
}
void LustreParser::Const_idContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConst_id(this);
}

std::any LustreParser::Const_idContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitConst_id(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Const_parenContext ------------------------------------------------------------------

LustreParser::Const_exprContext* LustreParser::Const_parenContext::const_expr() {
  return getRuleContext<LustreParser::Const_exprContext>(0);
}

LustreParser::Const_parenContext::Const_parenContext(Const_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Const_parenContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConst_paren(this);
}
void LustreParser::Const_parenContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConst_paren(this);
}

std::any LustreParser::Const_parenContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitConst_paren(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Const_bin_relationContext ------------------------------------------------------------------

std::vector<LustreParser::Const_exprContext *> LustreParser::Const_bin_relationContext::const_expr() {
  return getRuleContexts<LustreParser::Const_exprContext>();
}

LustreParser::Const_exprContext* LustreParser::Const_bin_relationContext::const_expr(size_t i) {
  return getRuleContext<LustreParser::Const_exprContext>(i);
}

LustreParser::Bin_relation_opContext* LustreParser::Const_bin_relationContext::bin_relation_op() {
  return getRuleContext<LustreParser::Bin_relation_opContext>(0);
}

LustreParser::Const_bin_relationContext::Const_bin_relationContext(Const_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Const_bin_relationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConst_bin_relation(this);
}
void LustreParser::Const_bin_relationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConst_bin_relation(this);
}

std::any LustreParser::Const_bin_relationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitConst_bin_relation(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Const_atomContext ------------------------------------------------------------------

LustreParser::AtomContext* LustreParser::Const_atomContext::atom() {
  return getRuleContext<LustreParser::AtomContext>(0);
}

LustreParser::Const_atomContext::Const_atomContext(Const_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Const_atomContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConst_atom(this);
}
void LustreParser::Const_atomContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConst_atom(this);
}

std::any LustreParser::Const_atomContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitConst_atom(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Const_unary_arithContext ------------------------------------------------------------------

LustreParser::Unary_arith_opContext* LustreParser::Const_unary_arithContext::unary_arith_op() {
  return getRuleContext<LustreParser::Unary_arith_opContext>(0);
}

LustreParser::Const_exprContext* LustreParser::Const_unary_arithContext::const_expr() {
  return getRuleContext<LustreParser::Const_exprContext>(0);
}

LustreParser::Const_unary_arithContext::Const_unary_arithContext(Const_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Const_unary_arithContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConst_unary_arith(this);
}
void LustreParser::Const_unary_arithContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConst_unary_arith(this);
}

std::any LustreParser::Const_unary_arithContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitConst_unary_arith(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Const_structContext ------------------------------------------------------------------

std::vector<LustreParser::Const_label_exprContext *> LustreParser::Const_structContext::const_label_expr() {
  return getRuleContexts<LustreParser::Const_label_exprContext>();
}

LustreParser::Const_label_exprContext* LustreParser::Const_structContext::const_label_expr(size_t i) {
  return getRuleContext<LustreParser::Const_label_exprContext>(i);
}

LustreParser::Const_structContext::Const_structContext(Const_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Const_structContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConst_struct(this);
}
void LustreParser::Const_structContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConst_struct(this);
}

std::any LustreParser::Const_structContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitConst_struct(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Const_bin_arithContext ------------------------------------------------------------------

std::vector<LustreParser::Const_exprContext *> LustreParser::Const_bin_arithContext::const_expr() {
  return getRuleContexts<LustreParser::Const_exprContext>();
}

LustreParser::Const_exprContext* LustreParser::Const_bin_arithContext::const_expr(size_t i) {
  return getRuleContext<LustreParser::Const_exprContext>(i);
}

LustreParser::Bin_arith_opContext* LustreParser::Const_bin_arithContext::bin_arith_op() {
  return getRuleContext<LustreParser::Bin_arith_opContext>(0);
}

LustreParser::Const_bin_arithContext::Const_bin_arithContext(Const_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Const_bin_arithContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConst_bin_arith(this);
}
void LustreParser::Const_bin_arithContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConst_bin_arith(this);
}

std::any LustreParser::Const_bin_arithContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitConst_bin_arith(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Const_bin_boolContext ------------------------------------------------------------------

std::vector<LustreParser::Const_exprContext *> LustreParser::Const_bin_boolContext::const_expr() {
  return getRuleContexts<LustreParser::Const_exprContext>();
}

LustreParser::Const_exprContext* LustreParser::Const_bin_boolContext::const_expr(size_t i) {
  return getRuleContext<LustreParser::Const_exprContext>(i);
}

LustreParser::Bin_bool_opContext* LustreParser::Const_bin_boolContext::bin_bool_op() {
  return getRuleContext<LustreParser::Bin_bool_opContext>(0);
}

LustreParser::Const_bin_boolContext::Const_bin_boolContext(Const_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Const_bin_boolContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConst_bin_bool(this);
}
void LustreParser::Const_bin_boolContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConst_bin_bool(this);
}

std::any LustreParser::Const_bin_boolContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitConst_bin_bool(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Const_arrayContext ------------------------------------------------------------------

LustreParser::Const_listContext* LustreParser::Const_arrayContext::const_list() {
  return getRuleContext<LustreParser::Const_listContext>(0);
}

LustreParser::Const_arrayContext::Const_arrayContext(Const_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Const_arrayContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConst_array(this);
}
void LustreParser::Const_arrayContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConst_array(this);
}

std::any LustreParser::Const_arrayContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitConst_array(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Const_exprContext* LustreParser::const_expr() {
   return const_expr(0);
}

LustreParser::Const_exprContext* LustreParser::const_expr(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  LustreParser::Const_exprContext *_localctx = _tracker.createInstance<Const_exprContext>(_ctx, parentState);
  LustreParser::Const_exprContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 52;
  enterRecursionRule(_localctx, 52, LustreParser::RuleConst_expr, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(430);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LustreParser::ID: {
        _localctx = _tracker.createInstance<Const_idContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;

        setState(406);
        match(LustreParser::ID);
        break;
      }

      case LustreParser::BOOL:
      case LustreParser::INTEGER:
      case LustreParser::UINT:
      case LustreParser::REAL:
      case LustreParser::CHAR:
      case LustreParser::FLOAT:
      case LustreParser::USHORT:
      case LustreParser::SHORT: {
        _localctx = _tracker.createInstance<Const_atomContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        setState(407);
        atom();
        break;
      }

      case LustreParser::T__40:
      case LustreParser::T__82:
      case LustreParser::T__111: {
        _localctx = _tracker.createInstance<Const_unary_arithContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        setState(408);
        unary_arith_op();
        setState(409);
        const_expr(7);
        break;
      }

      case LustreParser::T__14: {
        _localctx = _tracker.createInstance<Const_parenContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        setState(411);
        match(LustreParser::T__14);
        setState(412);
        const_expr(0);
        setState(413);
        match(LustreParser::T__15);
        break;
      }

      case LustreParser::T__37: {
        _localctx = _tracker.createInstance<Const_arrayContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        setState(415);
        match(LustreParser::T__37);
        setState(416);
        const_list();
        setState(417);
        match(LustreParser::T__38);
        break;
      }

      case LustreParser::T__24: {
        _localctx = _tracker.createInstance<Const_structContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        setState(419);
        match(LustreParser::T__24);
        setState(420);
        const_label_expr();
        setState(425);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == LustreParser::T__6) {
          setState(421);
          match(LustreParser::T__6);
          setState(422);
          const_label_expr();
          setState(427);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(428);
        match(LustreParser::T__25);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    _ctx->stop = _input->LT(-1);
    setState(446);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 29, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(444);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 28, _ctx)) {
        case 1: {
          auto newContext = _tracker.createInstance<Const_bin_arithContext>(_tracker.createInstance<Const_exprContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleConst_expr);
          setState(432);

          if (!(precpred(_ctx, 5))) throw FailedPredicateException(this, "precpred(_ctx, 5)");
          setState(433);
          bin_arith_op();
          setState(434);
          const_expr(6);
          break;
        }

        case 2: {
          auto newContext = _tracker.createInstance<Const_bin_boolContext>(_tracker.createInstance<Const_exprContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleConst_expr);
          setState(436);

          if (!(precpred(_ctx, 4))) throw FailedPredicateException(this, "precpred(_ctx, 4)");
          setState(437);
          bin_bool_op();
          setState(438);
          const_expr(5);
          break;
        }

        case 3: {
          auto newContext = _tracker.createInstance<Const_bin_relationContext>(_tracker.createInstance<Const_exprContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleConst_expr);
          setState(440);

          if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
          setState(441);
          bin_relation_op();
          setState(442);
          const_expr(4);
          break;
        }

        default:
          break;
        } 
      }
      setState(448);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 29, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Const_listContext ------------------------------------------------------------------

LustreParser::Const_listContext::Const_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<LustreParser::Const_exprContext *> LustreParser::Const_listContext::const_expr() {
  return getRuleContexts<LustreParser::Const_exprContext>();
}

LustreParser::Const_exprContext* LustreParser::Const_listContext::const_expr(size_t i) {
  return getRuleContext<LustreParser::Const_exprContext>(i);
}


size_t LustreParser::Const_listContext::getRuleIndex() const {
  return LustreParser::RuleConst_list;
}

void LustreParser::Const_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConst_list(this);
}

void LustreParser::Const_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConst_list(this);
}


std::any LustreParser::Const_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitConst_list(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Const_listContext* LustreParser::const_list() {
  Const_listContext *_localctx = _tracker.createInstance<Const_listContext>(_ctx, getState());
  enterRule(_localctx, 54, LustreParser::RuleConst_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(457);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 2473934749696) != 0) || ((((_la - 83) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 83)) & -72057593501057023) != 0) || _la == LustreParser::ID) {
      setState(449);
      const_expr(0);
      setState(454);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == LustreParser::T__6) {
        setState(450);
        match(LustreParser::T__6);
        setState(451);
        const_expr(0);
        setState(456);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Const_label_exprContext ------------------------------------------------------------------

LustreParser::Const_label_exprContext::Const_label_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LustreParser::Const_label_exprContext::ID() {
  return getToken(LustreParser::ID, 0);
}

LustreParser::Const_exprContext* LustreParser::Const_label_exprContext::const_expr() {
  return getRuleContext<LustreParser::Const_exprContext>(0);
}


size_t LustreParser::Const_label_exprContext::getRuleIndex() const {
  return LustreParser::RuleConst_label_expr;
}

void LustreParser::Const_label_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConst_label_expr(this);
}

void LustreParser::Const_label_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConst_label_expr(this);
}


std::any LustreParser::Const_label_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitConst_label_expr(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Const_label_exprContext* LustreParser::const_label_expr() {
  Const_label_exprContext *_localctx = _tracker.createInstance<Const_label_exprContext>(_ctx, getState());
  enterRule(_localctx, 56, LustreParser::RuleConst_label_expr);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(459);
    match(LustreParser::ID);
    setState(460);
    match(LustreParser::T__19);
    setState(461);
    const_expr(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Var_declsContext ------------------------------------------------------------------

LustreParser::Var_declsContext::Var_declsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> LustreParser::Var_declsContext::ID() {
  return getTokens(LustreParser::ID);
}

tree::TerminalNode* LustreParser::Var_declsContext::ID(size_t i) {
  return getToken(LustreParser::ID, i);
}

LustreParser::TypeContext* LustreParser::Var_declsContext::type() {
  return getRuleContext<LustreParser::TypeContext>(0);
}

LustreParser::When_declContext* LustreParser::Var_declsContext::when_decl() {
  return getRuleContext<LustreParser::When_declContext>(0);
}

LustreParser::Last_declContext* LustreParser::Var_declsContext::last_decl() {
  return getRuleContext<LustreParser::Last_declContext>(0);
}


size_t LustreParser::Var_declsContext::getRuleIndex() const {
  return LustreParser::RuleVar_decls;
}

void LustreParser::Var_declsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVar_decls(this);
}

void LustreParser::Var_declsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVar_decls(this);
}


std::any LustreParser::Var_declsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitVar_decls(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Var_declsContext* LustreParser::var_decls() {
  Var_declsContext *_localctx = _tracker.createInstance<Var_declsContext>(_ctx, getState());
  enterRule(_localctx, 58, LustreParser::RuleVar_decls);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(463);
    match(LustreParser::ID);
    setState(468);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == LustreParser::T__6) {
      setState(464);
      match(LustreParser::T__6);
      setState(465);
      match(LustreParser::ID);
      setState(470);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(471);
    match(LustreParser::T__19);
    setState(472);
    type(0);
    setState(474);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == LustreParser::T__39) {
      setState(473);
      when_decl();
    }
    setState(477);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == LustreParser::T__41) {
      setState(476);
      last_decl();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- When_declContext ------------------------------------------------------------------

LustreParser::When_declContext::When_declContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LustreParser::Clock_exprContext* LustreParser::When_declContext::clock_expr() {
  return getRuleContext<LustreParser::Clock_exprContext>(0);
}


size_t LustreParser::When_declContext::getRuleIndex() const {
  return LustreParser::RuleWhen_decl;
}

void LustreParser::When_declContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWhen_decl(this);
}

void LustreParser::When_declContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWhen_decl(this);
}


std::any LustreParser::When_declContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitWhen_decl(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::When_declContext* LustreParser::when_decl() {
  When_declContext *_localctx = _tracker.createInstance<When_declContext>(_ctx, getState());
  enterRule(_localctx, 60, LustreParser::RuleWhen_decl);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(479);
    match(LustreParser::T__39);
    setState(480);
    clock_expr();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Clock_exprContext ------------------------------------------------------------------

LustreParser::Clock_exprContext::Clock_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::Clock_exprContext::getRuleIndex() const {
  return LustreParser::RuleClock_expr;
}

void LustreParser::Clock_exprContext::copyFrom(Clock_exprContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Clock_idContext ------------------------------------------------------------------

tree::TerminalNode* LustreParser::Clock_idContext::ID() {
  return getToken(LustreParser::ID, 0);
}

LustreParser::Clock_idContext::Clock_idContext(Clock_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Clock_idContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClock_id(this);
}
void LustreParser::Clock_idContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClock_id(this);
}

std::any LustreParser::Clock_idContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitClock_id(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Clock_notContext ------------------------------------------------------------------

tree::TerminalNode* LustreParser::Clock_notContext::ID() {
  return getToken(LustreParser::ID, 0);
}

LustreParser::Clock_notContext::Clock_notContext(Clock_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Clock_notContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClock_not(this);
}
void LustreParser::Clock_notContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClock_not(this);
}

std::any LustreParser::Clock_notContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitClock_not(this);
  else
    return visitor->visitChildren(this);
}
LustreParser::Clock_exprContext* LustreParser::clock_expr() {
  Clock_exprContext *_localctx = _tracker.createInstance<Clock_exprContext>(_ctx, getState());
  enterRule(_localctx, 62, LustreParser::RuleClock_expr);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(491);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LustreParser::ID: {
        _localctx = _tracker.createInstance<LustreParser::Clock_idContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(482);
        match(LustreParser::ID);
        break;
      }

      case LustreParser::T__40: {
        _localctx = _tracker.createInstance<LustreParser::Clock_notContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(483);
        match(LustreParser::T__40);
        setState(485);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == LustreParser::T__14) {
          setState(484);
          match(LustreParser::T__14);
        }
        setState(487);
        match(LustreParser::ID);
        setState(489);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 36, _ctx)) {
        case 1: {
          setState(488);
          match(LustreParser::T__15);
          break;
        }

        default:
          break;
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Last_declContext ------------------------------------------------------------------

LustreParser::Last_declContext::Last_declContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LustreParser::Const_exprContext* LustreParser::Last_declContext::const_expr() {
  return getRuleContext<LustreParser::Const_exprContext>(0);
}


size_t LustreParser::Last_declContext::getRuleIndex() const {
  return LustreParser::RuleLast_decl;
}

void LustreParser::Last_declContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLast_decl(this);
}

void LustreParser::Last_declContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLast_decl(this);
}


std::any LustreParser::Last_declContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitLast_decl(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Last_declContext* LustreParser::last_decl() {
  Last_declContext *_localctx = _tracker.createInstance<Last_declContext>(_ctx, getState());
  enterRule(_localctx, 64, LustreParser::RuleLast_decl);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(493);
    match(LustreParser::T__41);
    setState(494);
    match(LustreParser::T__7);
    setState(495);
    const_expr(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- User_op_declContext ------------------------------------------------------------------

LustreParser::User_op_declContext::User_op_declContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LustreParser::Op_kindContext* LustreParser::User_op_declContext::op_kind() {
  return getRuleContext<LustreParser::Op_kindContext>(0);
}

tree::TerminalNode* LustreParser::User_op_declContext::ID() {
  return getToken(LustreParser::ID, 0);
}

std::vector<LustreParser::ParamsContext *> LustreParser::User_op_declContext::params() {
  return getRuleContexts<LustreParser::ParamsContext>();
}

LustreParser::ParamsContext* LustreParser::User_op_declContext::params(size_t i) {
  return getRuleContext<LustreParser::ParamsContext>(i);
}

LustreParser::Op_bodyContext* LustreParser::User_op_declContext::op_body() {
  return getRuleContext<LustreParser::Op_bodyContext>(0);
}


size_t LustreParser::User_op_declContext::getRuleIndex() const {
  return LustreParser::RuleUser_op_decl;
}

void LustreParser::User_op_declContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUser_op_decl(this);
}

void LustreParser::User_op_declContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUser_op_decl(this);
}


std::any LustreParser::User_op_declContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitUser_op_decl(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::User_op_declContext* LustreParser::user_op_decl() {
  User_op_declContext *_localctx = _tracker.createInstance<User_op_declContext>(_ctx, getState());
  enterRule(_localctx, 66, LustreParser::RuleUser_op_decl);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(497);
    op_kind();
    setState(498);
    match(LustreParser::ID);
    setState(499);
    params();
    setState(500);
    match(LustreParser::T__12);
    setState(501);
    params();
    setState(503);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 38, _ctx)) {
    case 1: {
      setState(502);
      match(LustreParser::T__1);
      break;
    }

    default:
      break;
    }
    setState(505);
    op_body();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_kindContext ------------------------------------------------------------------

LustreParser::Op_kindContext::Op_kindContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::Op_kindContext::getRuleIndex() const {
  return LustreParser::RuleOp_kind;
}

void LustreParser::Op_kindContext::copyFrom(Op_kindContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Op_kind_nodeContext ------------------------------------------------------------------

LustreParser::Op_kind_nodeContext::Op_kind_nodeContext(Op_kindContext *ctx) { copyFrom(ctx); }

void LustreParser::Op_kind_nodeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_kind_node(this);
}
void LustreParser::Op_kind_nodeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_kind_node(this);
}

std::any LustreParser::Op_kind_nodeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitOp_kind_node(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Op_kind_funtionContext ------------------------------------------------------------------

LustreParser::Op_kind_funtionContext::Op_kind_funtionContext(Op_kindContext *ctx) { copyFrom(ctx); }

void LustreParser::Op_kind_funtionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_kind_funtion(this);
}
void LustreParser::Op_kind_funtionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_kind_funtion(this);
}

std::any LustreParser::Op_kind_funtionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitOp_kind_funtion(this);
  else
    return visitor->visitChildren(this);
}
LustreParser::Op_kindContext* LustreParser::op_kind() {
  Op_kindContext *_localctx = _tracker.createInstance<Op_kindContext>(_ctx, getState());
  enterRule(_localctx, 68, LustreParser::RuleOp_kind);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(509);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LustreParser::T__42: {
        _localctx = _tracker.createInstance<LustreParser::Op_kind_funtionContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(507);
        match(LustreParser::T__42);
        break;
      }

      case LustreParser::T__43: {
        _localctx = _tracker.createInstance<LustreParser::Op_kind_nodeContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(508);
        match(LustreParser::T__43);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ParamsContext ------------------------------------------------------------------

LustreParser::ParamsContext::ParamsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<LustreParser::Var_declsContext *> LustreParser::ParamsContext::var_decls() {
  return getRuleContexts<LustreParser::Var_declsContext>();
}

LustreParser::Var_declsContext* LustreParser::ParamsContext::var_decls(size_t i) {
  return getRuleContext<LustreParser::Var_declsContext>(i);
}


size_t LustreParser::ParamsContext::getRuleIndex() const {
  return LustreParser::RuleParams;
}

void LustreParser::ParamsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParams(this);
}

void LustreParser::ParamsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParams(this);
}


std::any LustreParser::ParamsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitParams(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::ParamsContext* LustreParser::params() {
  ParamsContext *_localctx = _tracker.createInstance<ParamsContext>(_ctx, getState());
  enterRule(_localctx, 70, LustreParser::RuleParams);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(511);
    match(LustreParser::T__14);
    setState(520);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == LustreParser::ID) {
      setState(512);
      var_decls();
      setState(517);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 40, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(513);
          match(LustreParser::T__1);
          setState(514);
          var_decls(); 
        }
        setState(519);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 40, _ctx);
      }
    }
    setState(523);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == LustreParser::T__1) {
      setState(522);
      match(LustreParser::T__1);
    }
    setState(525);
    match(LustreParser::T__15);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Op_bodyContext ------------------------------------------------------------------

LustreParser::Op_bodyContext::Op_bodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::Op_bodyContext::getRuleIndex() const {
  return LustreParser::RuleOp_body;
}

void LustreParser::Op_bodyContext::copyFrom(Op_bodyContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Op_body_nullContext ------------------------------------------------------------------

LustreParser::Op_body_nullContext::Op_body_nullContext(Op_bodyContext *ctx) { copyFrom(ctx); }

void LustreParser::Op_body_nullContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_body_null(this);
}
void LustreParser::Op_body_nullContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_body_null(this);
}

std::any LustreParser::Op_body_nullContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitOp_body_null(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Op_body_ctxContext ------------------------------------------------------------------

LustreParser::Contract_statementContext* LustreParser::Op_body_ctxContext::contract_statement() {
  return getRuleContext<LustreParser::Contract_statementContext>(0);
}

LustreParser::Merge_declContext* LustreParser::Op_body_ctxContext::merge_decl() {
  return getRuleContext<LustreParser::Merge_declContext>(0);
}

LustreParser::Local_blockContext* LustreParser::Op_body_ctxContext::local_block() {
  return getRuleContext<LustreParser::Local_blockContext>(0);
}

std::vector<LustreParser::Let_blockContext *> LustreParser::Op_body_ctxContext::let_block() {
  return getRuleContexts<LustreParser::Let_blockContext>();
}

LustreParser::Let_blockContext* LustreParser::Op_body_ctxContext::let_block(size_t i) {
  return getRuleContext<LustreParser::Let_blockContext>(i);
}

LustreParser::Op_body_ctxContext::Op_body_ctxContext(Op_bodyContext *ctx) { copyFrom(ctx); }

void LustreParser::Op_body_ctxContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOp_body_ctx(this);
}
void LustreParser::Op_body_ctxContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOp_body_ctx(this);
}

std::any LustreParser::Op_body_ctxContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitOp_body_ctx(this);
  else
    return visitor->visitChildren(this);
}
LustreParser::Op_bodyContext* LustreParser::op_body() {
  Op_bodyContext *_localctx = _tracker.createInstance<Op_bodyContext>(_ctx, getState());
  enterRule(_localctx, 72, LustreParser::RuleOp_body);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(550);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LustreParser::T__1: {
        _localctx = _tracker.createInstance<LustreParser::Op_body_nullContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(527);
        match(LustreParser::T__1);
        break;
      }

      case LustreParser::T__18:
      case LustreParser::T__44:
      case LustreParser::T__46:
      case LustreParser::T__48:
      case LustreParser::T__50: {
        _localctx = _tracker.createInstance<LustreParser::Op_body_ctxContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(529);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == LustreParser::T__46

        || _la == LustreParser::T__48) {
          setState(528);
          contract_statement();
        }
        setState(532);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == LustreParser::T__50) {
          setState(531);
          merge_decl();
        }
        setState(535);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == LustreParser::T__18) {
          setState(534);
          local_block();
        }
        setState(537);
        match(LustreParser::T__44);
        setState(543);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 355784370562301952) != 0) || _la == LustreParser::ID) {
          setState(538);
          let_block();
          setState(539);
          match(LustreParser::T__1);
          setState(545);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(546);
        match(LustreParser::T__45);
        setState(548);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == LustreParser::T__1) {
          setState(547);
          match(LustreParser::T__1);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Contract_statementContext ------------------------------------------------------------------

LustreParser::Contract_statementContext::Contract_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::Contract_statementContext::getRuleIndex() const {
  return LustreParser::RuleContract_statement;
}

void LustreParser::Contract_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterContract_statement(this);
}

void LustreParser::Contract_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitContract_statement(this);
}


std::any LustreParser::Contract_statementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitContract_statement(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Contract_statementContext* LustreParser::contract_statement() {
  Contract_statementContext *_localctx = _tracker.createInstance<Contract_statementContext>(_ctx, getState());
  enterRule(_localctx, 74, LustreParser::RuleContract_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(568);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LustreParser::T__46: {
        enterOuterAlt(_localctx, 1);
        setState(552);
        match(LustreParser::T__46);
        setState(556);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 49, _ctx);
        while (alt != 1 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1 + 1) {
            setState(553);
            matchWildcard(); 
          }
          setState(558);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 49, _ctx);
        }
        setState(559);
        match(LustreParser::T__47);
        break;
      }

      case LustreParser::T__48: {
        enterOuterAlt(_localctx, 2);
        setState(560);
        match(LustreParser::T__48);
        setState(564);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 50, _ctx);
        while (alt != 1 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1 + 1) {
            setState(561);
            matchWildcard(); 
          }
          setState(566);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 50, _ctx);
        }
        setState(567);
        match(LustreParser::T__49);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Merge_declContext ------------------------------------------------------------------

LustreParser::Merge_declContext::Merge_declContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LustreParser::Merge_declContext::ID() {
  return getToken(LustreParser::ID, 0);
}


size_t LustreParser::Merge_declContext::getRuleIndex() const {
  return LustreParser::RuleMerge_decl;
}

void LustreParser::Merge_declContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMerge_decl(this);
}

void LustreParser::Merge_declContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMerge_decl(this);
}


std::any LustreParser::Merge_declContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitMerge_decl(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Merge_declContext* LustreParser::merge_decl() {
  Merge_declContext *_localctx = _tracker.createInstance<Merge_declContext>(_ctx, getState());
  enterRule(_localctx, 76, LustreParser::RuleMerge_decl);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(570);
    match(LustreParser::T__50);
    setState(571);
    match(LustreParser::ID);
    setState(572);
    match(LustreParser::T__14);
    setState(576);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 52, _ctx);
    while (alt != 1 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1 + 1) {
        setState(573);
        matchWildcard(); 
      }
      setState(578);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 52, _ctx);
    }
    setState(579);
    match(LustreParser::T__15);
    setState(580);
    match(LustreParser::T__1);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Let_blockContext ------------------------------------------------------------------

LustreParser::Let_blockContext::Let_blockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::Let_blockContext::getRuleIndex() const {
  return LustreParser::RuleLet_block;
}

void LustreParser::Let_blockContext::copyFrom(Let_blockContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Let_block_kind2_frame_blockContext ------------------------------------------------------------------

LustreParser::Frame_blockContext* LustreParser::Let_block_kind2_frame_blockContext::frame_block() {
  return getRuleContext<LustreParser::Frame_blockContext>(0);
}

LustreParser::Let_block_kind2_frame_blockContext::Let_block_kind2_frame_blockContext(Let_blockContext *ctx) { copyFrom(ctx); }

void LustreParser::Let_block_kind2_frame_blockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLet_block_kind2_frame_block(this);
}
void LustreParser::Let_block_kind2_frame_blockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLet_block_kind2_frame_block(this);
}

std::any LustreParser::Let_block_kind2_frame_blockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitLet_block_kind2_frame_block(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Let_block_kind2_kind2_StatementContext ------------------------------------------------------------------

LustreParser::Kind2_StatementContext* LustreParser::Let_block_kind2_kind2_StatementContext::kind2_Statement() {
  return getRuleContext<LustreParser::Kind2_StatementContext>(0);
}

LustreParser::Let_block_kind2_kind2_StatementContext::Let_block_kind2_kind2_StatementContext(Let_blockContext *ctx) { copyFrom(ctx); }

void LustreParser::Let_block_kind2_kind2_StatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLet_block_kind2_kind2_Statement(this);
}
void LustreParser::Let_block_kind2_kind2_StatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLet_block_kind2_kind2_Statement(this);
}

std::any LustreParser::Let_block_kind2_kind2_StatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitLet_block_kind2_kind2_Statement(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Let_block_equationContext ------------------------------------------------------------------

LustreParser::EquationContext* LustreParser::Let_block_equationContext::equation() {
  return getRuleContext<LustreParser::EquationContext>(0);
}

LustreParser::Let_block_equationContext::Let_block_equationContext(Let_blockContext *ctx) { copyFrom(ctx); }

void LustreParser::Let_block_equationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLet_block_equation(this);
}
void LustreParser::Let_block_equationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLet_block_equation(this);
}

std::any LustreParser::Let_block_equationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitLet_block_equation(this);
  else
    return visitor->visitChildren(this);
}
LustreParser::Let_blockContext* LustreParser::let_block() {
  Let_blockContext *_localctx = _tracker.createInstance<Let_blockContext>(_ctx, getState());
  enterRule(_localctx, 78, LustreParser::RuleLet_block);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(585);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LustreParser::T__14:
      case LustreParser::T__57:
      case LustreParser::ID: {
        _localctx = _tracker.createInstance<LustreParser::Let_block_equationContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(582);
        equation();
        break;
      }

      case LustreParser::T__51:
      case LustreParser::T__52:
      case LustreParser::T__53: {
        _localctx = _tracker.createInstance<LustreParser::Let_block_kind2_kind2_StatementContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(583);
        kind2_Statement();
        break;
      }

      case LustreParser::T__54: {
        _localctx = _tracker.createInstance<LustreParser::Let_block_kind2_frame_blockContext>(_localctx);
        enterOuterAlt(_localctx, 3);
        setState(584);
        frame_block();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Local_blockContext ------------------------------------------------------------------

LustreParser::Local_blockContext::Local_blockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<LustreParser::Var_declsContext *> LustreParser::Local_blockContext::var_decls() {
  return getRuleContexts<LustreParser::Var_declsContext>();
}

LustreParser::Var_declsContext* LustreParser::Local_blockContext::var_decls(size_t i) {
  return getRuleContext<LustreParser::Var_declsContext>(i);
}


size_t LustreParser::Local_blockContext::getRuleIndex() const {
  return LustreParser::RuleLocal_block;
}

void LustreParser::Local_blockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLocal_block(this);
}

void LustreParser::Local_blockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLocal_block(this);
}


std::any LustreParser::Local_blockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitLocal_block(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Local_blockContext* LustreParser::local_block() {
  Local_blockContext *_localctx = _tracker.createInstance<Local_blockContext>(_ctx, getState());
  enterRule(_localctx, 80, LustreParser::RuleLocal_block);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(587);
    match(LustreParser::T__18);
    setState(593);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == LustreParser::ID) {
      setState(588);
      var_decls();
      setState(589);
      match(LustreParser::T__1);
      setState(595);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Kind2_StatementContext ------------------------------------------------------------------

LustreParser::Kind2_StatementContext::Kind2_StatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LustreParser::MainStatementContext* LustreParser::Kind2_StatementContext::mainStatement() {
  return getRuleContext<LustreParser::MainStatementContext>(0);
}

LustreParser::PropertyStatementContext* LustreParser::Kind2_StatementContext::propertyStatement() {
  return getRuleContext<LustreParser::PropertyStatementContext>(0);
}

LustreParser::CheckStatementContext* LustreParser::Kind2_StatementContext::checkStatement() {
  return getRuleContext<LustreParser::CheckStatementContext>(0);
}


size_t LustreParser::Kind2_StatementContext::getRuleIndex() const {
  return LustreParser::RuleKind2_Statement;
}

void LustreParser::Kind2_StatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKind2_Statement(this);
}

void LustreParser::Kind2_StatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKind2_Statement(this);
}


std::any LustreParser::Kind2_StatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitKind2_Statement(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Kind2_StatementContext* LustreParser::kind2_Statement() {
  Kind2_StatementContext *_localctx = _tracker.createInstance<Kind2_StatementContext>(_ctx, getState());
  enterRule(_localctx, 82, LustreParser::RuleKind2_Statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(599);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LustreParser::T__51: {
        enterOuterAlt(_localctx, 1);
        setState(596);
        mainStatement();
        break;
      }

      case LustreParser::T__52: {
        enterOuterAlt(_localctx, 2);
        setState(597);
        propertyStatement();
        break;
      }

      case LustreParser::T__53: {
        enterOuterAlt(_localctx, 3);
        setState(598);
        checkStatement();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MainStatementContext ------------------------------------------------------------------

LustreParser::MainStatementContext::MainStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::MainStatementContext::getRuleIndex() const {
  return LustreParser::RuleMainStatement;
}

void LustreParser::MainStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMainStatement(this);
}

void LustreParser::MainStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMainStatement(this);
}


std::any LustreParser::MainStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitMainStatement(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::MainStatementContext* LustreParser::mainStatement() {
  MainStatementContext *_localctx = _tracker.createInstance<MainStatementContext>(_ctx, getState());
  enterRule(_localctx, 84, LustreParser::RuleMainStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(601);
    match(LustreParser::T__51);
    setState(602);
    match(LustreParser::T__1);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PropertyStatementContext ------------------------------------------------------------------

LustreParser::PropertyStatementContext::PropertyStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::PropertyStatementContext::getRuleIndex() const {
  return LustreParser::RulePropertyStatement;
}

void LustreParser::PropertyStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPropertyStatement(this);
}

void LustreParser::PropertyStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPropertyStatement(this);
}


std::any LustreParser::PropertyStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitPropertyStatement(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::PropertyStatementContext* LustreParser::propertyStatement() {
  PropertyStatementContext *_localctx = _tracker.createInstance<PropertyStatementContext>(_ctx, getState());
  enterRule(_localctx, 86, LustreParser::RulePropertyStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(604);
    match(LustreParser::T__52);
    setState(608);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 56, _ctx);
    while (alt != 1 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1 + 1) {
        setState(605);
        matchWildcard(); 
      }
      setState(610);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 56, _ctx);
    }
    setState(611);
    match(LustreParser::T__1);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CheckStatementContext ------------------------------------------------------------------

LustreParser::CheckStatementContext::CheckStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::CheckStatementContext::getRuleIndex() const {
  return LustreParser::RuleCheckStatement;
}

void LustreParser::CheckStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCheckStatement(this);
}

void LustreParser::CheckStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCheckStatement(this);
}


std::any LustreParser::CheckStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitCheckStatement(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::CheckStatementContext* LustreParser::checkStatement() {
  CheckStatementContext *_localctx = _tracker.createInstance<CheckStatementContext>(_ctx, getState());
  enterRule(_localctx, 88, LustreParser::RuleCheckStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(613);
    match(LustreParser::T__53);
    setState(617);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 57, _ctx);
    while (alt != 1 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1 + 1) {
        setState(614);
        matchWildcard(); 
      }
      setState(619);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 57, _ctx);
    }
    setState(620);
    match(LustreParser::T__1);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Frame_blockContext ------------------------------------------------------------------

LustreParser::Frame_blockContext::Frame_blockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LustreParser::Frame_initContext* LustreParser::Frame_blockContext::frame_init() {
  return getRuleContext<LustreParser::Frame_initContext>(0);
}

LustreParser::Frame_bodyContext* LustreParser::Frame_blockContext::frame_body() {
  return getRuleContext<LustreParser::Frame_bodyContext>(0);
}


size_t LustreParser::Frame_blockContext::getRuleIndex() const {
  return LustreParser::RuleFrame_block;
}

void LustreParser::Frame_blockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFrame_block(this);
}

void LustreParser::Frame_blockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFrame_block(this);
}


std::any LustreParser::Frame_blockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitFrame_block(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Frame_blockContext* LustreParser::frame_block() {
  Frame_blockContext *_localctx = _tracker.createInstance<Frame_blockContext>(_ctx, getState());
  enterRule(_localctx, 90, LustreParser::RuleFrame_block);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(622);
    frame_init();
    setState(626);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 58, _ctx);
    while (alt != 1 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1 + 1) {
        setState(623);
        matchWildcard(); 
      }
      setState(628);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 58, _ctx);
    }
    setState(629);
    frame_body();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Frame_initContext ------------------------------------------------------------------

LustreParser::Frame_initContext::Frame_initContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::Frame_initContext::getRuleIndex() const {
  return LustreParser::RuleFrame_init;
}

void LustreParser::Frame_initContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFrame_init(this);
}

void LustreParser::Frame_initContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFrame_init(this);
}


std::any LustreParser::Frame_initContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitFrame_init(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Frame_initContext* LustreParser::frame_init() {
  Frame_initContext *_localctx = _tracker.createInstance<Frame_initContext>(_ctx, getState());
  enterRule(_localctx, 92, LustreParser::RuleFrame_init);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(631);
    match(LustreParser::T__54);
    setState(632);
    match(LustreParser::T__14);
    setState(636);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 59, _ctx);
    while (alt != 1 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1 + 1) {
        setState(633);
        matchWildcard(); 
      }
      setState(638);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 59, _ctx);
    }
    setState(639);
    match(LustreParser::T__15);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Frame_bodyContext ------------------------------------------------------------------

LustreParser::Frame_bodyContext::Frame_bodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::Frame_bodyContext::getRuleIndex() const {
  return LustreParser::RuleFrame_body;
}

void LustreParser::Frame_bodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFrame_body(this);
}

void LustreParser::Frame_bodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFrame_body(this);
}


std::any LustreParser::Frame_bodyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitFrame_body(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Frame_bodyContext* LustreParser::frame_body() {
  Frame_bodyContext *_localctx = _tracker.createInstance<Frame_bodyContext>(_ctx, getState());
  enterRule(_localctx, 94, LustreParser::RuleFrame_body);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(641);
    match(LustreParser::T__44);
    setState(645);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 60, _ctx);
    while (alt != 1 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1 + 1) {
        setState(642);
        matchWildcard(); 
      }
      setState(647);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 60, _ctx);
    }
    setState(648);
    match(LustreParser::T__45);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Import_op_declContext ------------------------------------------------------------------

LustreParser::Import_op_declContext::Import_op_declContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LustreParser::Import_op_declContext::ID() {
  return getToken(LustreParser::ID, 0);
}

std::vector<LustreParser::ParamsContext *> LustreParser::Import_op_declContext::params() {
  return getRuleContexts<LustreParser::ParamsContext>();
}

LustreParser::ParamsContext* LustreParser::Import_op_declContext::params(size_t i) {
  return getRuleContext<LustreParser::ParamsContext>(i);
}


size_t LustreParser::Import_op_declContext::getRuleIndex() const {
  return LustreParser::RuleImport_op_decl;
}

void LustreParser::Import_op_declContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImport_op_decl(this);
}

void LustreParser::Import_op_declContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImport_op_decl(this);
}


std::any LustreParser::Import_op_declContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitImport_op_decl(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Import_op_declContext* LustreParser::import_op_decl() {
  Import_op_declContext *_localctx = _tracker.createInstance<Import_op_declContext>(_ctx, getState());
  enterRule(_localctx, 96, LustreParser::RuleImport_op_decl);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(650);
    match(LustreParser::T__42);
    setState(651);
    match(LustreParser::T__55);
    setState(652);
    match(LustreParser::ID);
    setState(653);
    params();
    setState(654);
    match(LustreParser::T__12);
    setState(655);
    params();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EquationContext ------------------------------------------------------------------

LustreParser::EquationContext::EquationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::EquationContext::getRuleIndex() const {
  return LustreParser::RuleEquation;
}

void LustreParser::EquationContext::copyFrom(EquationContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Equation_state_machineContext ------------------------------------------------------------------

LustreParser::State_machineContext* LustreParser::Equation_state_machineContext::state_machine() {
  return getRuleContext<LustreParser::State_machineContext>(0);
}

LustreParser::ReturnContext* LustreParser::Equation_state_machineContext::return_() {
  return getRuleContext<LustreParser::ReturnContext>(0);
}

LustreParser::Equation_state_machineContext::Equation_state_machineContext(EquationContext *ctx) { copyFrom(ctx); }

void LustreParser::Equation_state_machineContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEquation_state_machine(this);
}
void LustreParser::Equation_state_machineContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEquation_state_machine(this);
}

std::any LustreParser::Equation_state_machineContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitEquation_state_machine(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Equation_exprContext ------------------------------------------------------------------

LustreParser::LhsContext* LustreParser::Equation_exprContext::lhs() {
  return getRuleContext<LustreParser::LhsContext>(0);
}

LustreParser::ExprContext* LustreParser::Equation_exprContext::expr() {
  return getRuleContext<LustreParser::ExprContext>(0);
}

LustreParser::Equation_exprContext::Equation_exprContext(EquationContext *ctx) { copyFrom(ctx); }

void LustreParser::Equation_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEquation_expr(this);
}
void LustreParser::Equation_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEquation_expr(this);
}

std::any LustreParser::Equation_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitEquation_expr(this);
  else
    return visitor->visitChildren(this);
}
LustreParser::EquationContext* LustreParser::equation() {
  EquationContext *_localctx = _tracker.createInstance<EquationContext>(_ctx, getState());
  enterRule(_localctx, 98, LustreParser::RuleEquation);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(664);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LustreParser::T__14:
      case LustreParser::ID: {
        _localctx = _tracker.createInstance<LustreParser::Equation_exprContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(657);
        lhs();
        setState(658);
        match(LustreParser::T__7);
        setState(659);
        expr();
        break;
      }

      case LustreParser::T__57: {
        _localctx = _tracker.createInstance<LustreParser::Equation_state_machineContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(661);
        state_machine();
        setState(662);
        return_();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LhsContext ------------------------------------------------------------------

LustreParser::LhsContext::LhsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::LhsContext::getRuleIndex() const {
  return LustreParser::RuleLhs;
}

void LustreParser::LhsContext::copyFrom(LhsContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Lhs_pairContext ------------------------------------------------------------------

LustreParser::Lhs_pairContext::Lhs_pairContext(LhsContext *ctx) { copyFrom(ctx); }

void LustreParser::Lhs_pairContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLhs_pair(this);
}
void LustreParser::Lhs_pairContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLhs_pair(this);
}

std::any LustreParser::Lhs_pairContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitLhs_pair(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Lhs_id_listContext ------------------------------------------------------------------

std::vector<tree::TerminalNode *> LustreParser::Lhs_id_listContext::ID() {
  return getTokens(LustreParser::ID);
}

tree::TerminalNode* LustreParser::Lhs_id_listContext::ID(size_t i) {
  return getToken(LustreParser::ID, i);
}

LustreParser::Lhs_id_listContext::Lhs_id_listContext(LhsContext *ctx) { copyFrom(ctx); }

void LustreParser::Lhs_id_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLhs_id_list(this);
}
void LustreParser::Lhs_id_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLhs_id_list(this);
}

std::any LustreParser::Lhs_id_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitLhs_id_list(this);
  else
    return visitor->visitChildren(this);
}
LustreParser::LhsContext* LustreParser::lhs() {
  LhsContext *_localctx = _tracker.createInstance<LhsContext>(_ctx, getState());
  enterRule(_localctx, 100, LustreParser::RuleLhs);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(682);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 65, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<LustreParser::Lhs_pairContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(666);
      match(LustreParser::T__14);
      setState(667);
      match(LustreParser::T__15);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<LustreParser::Lhs_id_listContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(669);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == LustreParser::T__14) {
        setState(668);
        match(LustreParser::T__14);
      }
      setState(671);
      match(LustreParser::ID);
      setState(676);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == LustreParser::T__6) {
        setState(672);
        match(LustreParser::T__6);
        setState(673);
        match(LustreParser::ID);
        setState(678);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(680);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == LustreParser::T__15) {
        setState(679);
        match(LustreParser::T__15);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReturnContext ------------------------------------------------------------------

LustreParser::ReturnContext::ReturnContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LustreParser::Returns_varContext* LustreParser::ReturnContext::returns_var() {
  return getRuleContext<LustreParser::Returns_varContext>(0);
}


size_t LustreParser::ReturnContext::getRuleIndex() const {
  return LustreParser::RuleReturn;
}

void LustreParser::ReturnContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReturn(this);
}

void LustreParser::ReturnContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReturn(this);
}


std::any LustreParser::ReturnContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitReturn(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::ReturnContext* LustreParser::return_() {
  ReturnContext *_localctx = _tracker.createInstance<ReturnContext>(_ctx, getState());
  enterRule(_localctx, 102, LustreParser::RuleReturn);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(684);
    match(LustreParser::T__12);
    setState(685);
    returns_var();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Returns_varContext ------------------------------------------------------------------

LustreParser::Returns_varContext::Returns_varContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> LustreParser::Returns_varContext::ID() {
  return getTokens(LustreParser::ID);
}

tree::TerminalNode* LustreParser::Returns_varContext::ID(size_t i) {
  return getToken(LustreParser::ID, i);
}


size_t LustreParser::Returns_varContext::getRuleIndex() const {
  return LustreParser::RuleReturns_var;
}

void LustreParser::Returns_varContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReturns_var(this);
}

void LustreParser::Returns_varContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReturns_var(this);
}


std::any LustreParser::Returns_varContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitReturns_var(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Returns_varContext* LustreParser::returns_var() {
  Returns_varContext *_localctx = _tracker.createInstance<Returns_varContext>(_ctx, getState());
  enterRule(_localctx, 104, LustreParser::RuleReturns_var);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(691);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 66, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(687);
        match(LustreParser::ID);
        setState(688);
        match(LustreParser::T__6); 
      }
      setState(693);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 66, _ctx);
    }
    setState(695);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == LustreParser::T__56 || _la == LustreParser::ID) {
      setState(694);
      _la = _input->LA(1);
      if (!(_la == LustreParser::T__56 || _la == LustreParser::ID)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- State_machineContext ------------------------------------------------------------------

LustreParser::State_machineContext::State_machineContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LustreParser::State_machineContext::ID() {
  return getToken(LustreParser::ID, 0);
}

std::vector<LustreParser::State_declContext *> LustreParser::State_machineContext::state_decl() {
  return getRuleContexts<LustreParser::State_declContext>();
}

LustreParser::State_declContext* LustreParser::State_machineContext::state_decl(size_t i) {
  return getRuleContext<LustreParser::State_declContext>(i);
}


size_t LustreParser::State_machineContext::getRuleIndex() const {
  return LustreParser::RuleState_machine;
}

void LustreParser::State_machineContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterState_machine(this);
}

void LustreParser::State_machineContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitState_machine(this);
}


std::any LustreParser::State_machineContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitState_machine(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::State_machineContext* LustreParser::state_machine() {
  State_machineContext *_localctx = _tracker.createInstance<State_machineContext>(_ctx, getState());
  enterRule(_localctx, 106, LustreParser::RuleState_machine);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(697);
    match(LustreParser::T__57);
    setState(699);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == LustreParser::ID) {
      setState(698);
      match(LustreParser::ID);
    }
    setState(702); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(701);
      state_decl();
      setState(704); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 4035225266123964416) != 0));
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- State_declContext ------------------------------------------------------------------

LustreParser::State_declContext::State_declContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LustreParser::State_declContext::ID() {
  return getToken(LustreParser::ID, 0);
}

LustreParser::Data_defContext* LustreParser::State_declContext::data_def() {
  return getRuleContext<LustreParser::Data_defContext>(0);
}

std::vector<LustreParser::TransitionContext *> LustreParser::State_declContext::transition() {
  return getRuleContexts<LustreParser::TransitionContext>();
}

LustreParser::TransitionContext* LustreParser::State_declContext::transition(size_t i) {
  return getRuleContext<LustreParser::TransitionContext>(i);
}


size_t LustreParser::State_declContext::getRuleIndex() const {
  return LustreParser::RuleState_decl;
}

void LustreParser::State_declContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterState_decl(this);
}

void LustreParser::State_declContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitState_decl(this);
}


std::any LustreParser::State_declContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitState_decl(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::State_declContext* LustreParser::state_decl() {
  State_declContext *_localctx = _tracker.createInstance<State_declContext>(_ctx, getState());
  enterRule(_localctx, 108, LustreParser::RuleState_decl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(707);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == LustreParser::T__58) {
      setState(706);
      match(LustreParser::T__58);
    }
    setState(710);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == LustreParser::T__59) {
      setState(709);
      match(LustreParser::T__59);
    }
    setState(712);
    match(LustreParser::T__60);
    setState(713);
    match(LustreParser::ID);
    setState(722);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == LustreParser::T__61) {
      setState(714);
      match(LustreParser::T__61);
      setState(718); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(715);
        transition();
        setState(716);
        match(LustreParser::T__1);
        setState(720); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == LustreParser::T__63);
    }
    setState(724);
    data_def();
    setState(734);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == LustreParser::T__62) {
      setState(725);
      match(LustreParser::T__62);
      setState(731);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == LustreParser::T__63) {
        setState(726);
        transition();
        setState(727);
        match(LustreParser::T__1);
        setState(733);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Data_defContext ------------------------------------------------------------------

LustreParser::Data_defContext::Data_defContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::Data_defContext::getRuleIndex() const {
  return LustreParser::RuleData_def;
}

void LustreParser::Data_defContext::copyFrom(Data_defContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- State_machine_data_def_local_blockContext ------------------------------------------------------------------

LustreParser::Local_blockContext* LustreParser::State_machine_data_def_local_blockContext::local_block() {
  return getRuleContext<LustreParser::Local_blockContext>(0);
}

std::vector<LustreParser::EquationContext *> LustreParser::State_machine_data_def_local_blockContext::equation() {
  return getRuleContexts<LustreParser::EquationContext>();
}

LustreParser::EquationContext* LustreParser::State_machine_data_def_local_blockContext::equation(size_t i) {
  return getRuleContext<LustreParser::EquationContext>(i);
}

LustreParser::State_machine_data_def_local_blockContext::State_machine_data_def_local_blockContext(Data_defContext *ctx) { copyFrom(ctx); }

void LustreParser::State_machine_data_def_local_blockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterState_machine_data_def_local_block(this);
}
void LustreParser::State_machine_data_def_local_blockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitState_machine_data_def_local_block(this);
}

std::any LustreParser::State_machine_data_def_local_blockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitState_machine_data_def_local_block(this);
  else
    return visitor->visitChildren(this);
}
//----------------- State_machine_data_def_equationContext ------------------------------------------------------------------

LustreParser::EquationContext* LustreParser::State_machine_data_def_equationContext::equation() {
  return getRuleContext<LustreParser::EquationContext>(0);
}

LustreParser::State_machine_data_def_equationContext::State_machine_data_def_equationContext(Data_defContext *ctx) { copyFrom(ctx); }

void LustreParser::State_machine_data_def_equationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterState_machine_data_def_equation(this);
}
void LustreParser::State_machine_data_def_equationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitState_machine_data_def_equation(this);
}

std::any LustreParser::State_machine_data_def_equationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitState_machine_data_def_equation(this);
  else
    return visitor->visitChildren(this);
}
LustreParser::Data_defContext* LustreParser::data_def() {
  Data_defContext *_localctx = _tracker.createInstance<Data_defContext>(_ctx, getState());
  enterRule(_localctx, 110, LustreParser::RuleData_def);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(752);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LustreParser::T__14:
      case LustreParser::T__57:
      case LustreParser::ID: {
        _localctx = _tracker.createInstance<LustreParser::State_machine_data_def_equationContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(736);
        equation();
        break;
      }

      case LustreParser::T__12:
      case LustreParser::T__18:
      case LustreParser::T__44:
      case LustreParser::T__58:
      case LustreParser::T__59:
      case LustreParser::T__60:
      case LustreParser::T__62: {
        _localctx = _tracker.createInstance<LustreParser::State_machine_data_def_local_blockContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(738);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == LustreParser::T__18) {
          setState(737);
          local_block();
        }
        setState(750);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == LustreParser::T__44) {
          setState(740);
          match(LustreParser::T__44);
          setState(746);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == LustreParser::T__14

          || _la == LustreParser::T__57 || _la == LustreParser::ID) {
            setState(741);
            equation();
            setState(742);
            match(LustreParser::T__1);
            setState(748);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          setState(749);
          match(LustreParser::T__45);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TransitionContext ------------------------------------------------------------------

LustreParser::TransitionContext::TransitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::TransitionContext::getRuleIndex() const {
  return LustreParser::RuleTransition;
}

void LustreParser::TransitionContext::copyFrom(TransitionContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- State_machine_transition_restartContext ------------------------------------------------------------------

LustreParser::ExprContext* LustreParser::State_machine_transition_restartContext::expr() {
  return getRuleContext<LustreParser::ExprContext>(0);
}

tree::TerminalNode* LustreParser::State_machine_transition_restartContext::ID() {
  return getToken(LustreParser::ID, 0);
}

LustreParser::State_machine_transition_restartContext::State_machine_transition_restartContext(TransitionContext *ctx) { copyFrom(ctx); }

void LustreParser::State_machine_transition_restartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterState_machine_transition_restart(this);
}
void LustreParser::State_machine_transition_restartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitState_machine_transition_restart(this);
}

std::any LustreParser::State_machine_transition_restartContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitState_machine_transition_restart(this);
  else
    return visitor->visitChildren(this);
}
//----------------- State_machine_transition_resumeContext ------------------------------------------------------------------

LustreParser::ExprContext* LustreParser::State_machine_transition_resumeContext::expr() {
  return getRuleContext<LustreParser::ExprContext>(0);
}

tree::TerminalNode* LustreParser::State_machine_transition_resumeContext::ID() {
  return getToken(LustreParser::ID, 0);
}

LustreParser::State_machine_transition_resumeContext::State_machine_transition_resumeContext(TransitionContext *ctx) { copyFrom(ctx); }

void LustreParser::State_machine_transition_resumeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterState_machine_transition_resume(this);
}
void LustreParser::State_machine_transition_resumeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitState_machine_transition_resume(this);
}

std::any LustreParser::State_machine_transition_resumeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitState_machine_transition_resume(this);
  else
    return visitor->visitChildren(this);
}
LustreParser::TransitionContext* LustreParser::transition() {
  TransitionContext *_localctx = _tracker.createInstance<TransitionContext>(_ctx, getState());
  enterRule(_localctx, 112, LustreParser::RuleTransition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(764);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 80, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<LustreParser::State_machine_transition_resumeContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(754);
      match(LustreParser::T__63);
      setState(755);
      expr();
      setState(756);
      match(LustreParser::T__64);
      setState(757);
      match(LustreParser::ID);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<LustreParser::State_machine_transition_restartContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(759);
      match(LustreParser::T__63);
      setState(760);
      expr();
      setState(761);
      match(LustreParser::T__65);
      setState(762);
      match(LustreParser::ID);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExprContext ------------------------------------------------------------------

LustreParser::ExprContext::ExprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::ExprContext::getRuleIndex() const {
  return LustreParser::RuleExpr;
}

void LustreParser::ExprContext::copyFrom(ExprContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Expr_apply_exprContext ------------------------------------------------------------------

LustreParser::Apply_exprContext* LustreParser::Expr_apply_exprContext::apply_expr() {
  return getRuleContext<LustreParser::Apply_exprContext>(0);
}

LustreParser::Expr_apply_exprContext::Expr_apply_exprContext(ExprContext *ctx) { copyFrom(ctx); }

void LustreParser::Expr_apply_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpr_apply_expr(this);
}
void LustreParser::Expr_apply_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpr_apply_expr(this);
}

std::any LustreParser::Expr_apply_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitExpr_apply_expr(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Expr_simple_exprContext ------------------------------------------------------------------

LustreParser::Simple_exprContext* LustreParser::Expr_simple_exprContext::simple_expr() {
  return getRuleContext<LustreParser::Simple_exprContext>(0);
}

LustreParser::Expr_simple_exprContext::Expr_simple_exprContext(ExprContext *ctx) { copyFrom(ctx); }

void LustreParser::Expr_simple_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpr_simple_expr(this);
}
void LustreParser::Expr_simple_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpr_simple_expr(this);
}

std::any LustreParser::Expr_simple_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitExpr_simple_expr(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Expr_mixed_constructorContext ------------------------------------------------------------------

LustreParser::Mixed_constructorContext* LustreParser::Expr_mixed_constructorContext::mixed_constructor() {
  return getRuleContext<LustreParser::Mixed_constructorContext>(0);
}

LustreParser::Expr_mixed_constructorContext::Expr_mixed_constructorContext(ExprContext *ctx) { copyFrom(ctx); }

void LustreParser::Expr_mixed_constructorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpr_mixed_constructor(this);
}
void LustreParser::Expr_mixed_constructorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpr_mixed_constructor(this);
}

std::any LustreParser::Expr_mixed_constructorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitExpr_mixed_constructor(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Expr_tempo_exprContext ------------------------------------------------------------------

LustreParser::Tempo_exprContext* LustreParser::Expr_tempo_exprContext::tempo_expr() {
  return getRuleContext<LustreParser::Tempo_exprContext>(0);
}

LustreParser::Expr_tempo_exprContext::Expr_tempo_exprContext(ExprContext *ctx) { copyFrom(ctx); }

void LustreParser::Expr_tempo_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpr_tempo_expr(this);
}
void LustreParser::Expr_tempo_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpr_tempo_expr(this);
}

std::any LustreParser::Expr_tempo_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitExpr_tempo_expr(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Expr_struct_exprContext ------------------------------------------------------------------

LustreParser::Struct_exprContext* LustreParser::Expr_struct_exprContext::struct_expr() {
  return getRuleContext<LustreParser::Struct_exprContext>(0);
}

LustreParser::Expr_struct_exprContext::Expr_struct_exprContext(ExprContext *ctx) { copyFrom(ctx); }

void LustreParser::Expr_struct_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpr_struct_expr(this);
}
void LustreParser::Expr_struct_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpr_struct_expr(this);
}

std::any LustreParser::Expr_struct_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitExpr_struct_expr(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Expr_bool_exprContext ------------------------------------------------------------------

LustreParser::Bool_exprContext* LustreParser::Expr_bool_exprContext::bool_expr() {
  return getRuleContext<LustreParser::Bool_exprContext>(0);
}

LustreParser::Expr_bool_exprContext::Expr_bool_exprContext(ExprContext *ctx) { copyFrom(ctx); }

void LustreParser::Expr_bool_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpr_bool_expr(this);
}
void LustreParser::Expr_bool_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpr_bool_expr(this);
}

std::any LustreParser::Expr_bool_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitExpr_bool_expr(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Expr_last_declContext ------------------------------------------------------------------

tree::TerminalNode* LustreParser::Expr_last_declContext::ID() {
  return getToken(LustreParser::ID, 0);
}

LustreParser::Expr_last_declContext::Expr_last_declContext(ExprContext *ctx) { copyFrom(ctx); }

void LustreParser::Expr_last_declContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpr_last_decl(this);
}
void LustreParser::Expr_last_declContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpr_last_decl(this);
}

std::any LustreParser::Expr_last_declContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitExpr_last_decl(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Expr_parenContext ------------------------------------------------------------------

LustreParser::ExprContext* LustreParser::Expr_parenContext::expr() {
  return getRuleContext<LustreParser::ExprContext>(0);
}

LustreParser::Expr_parenContext::Expr_parenContext(ExprContext *ctx) { copyFrom(ctx); }

void LustreParser::Expr_parenContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpr_paren(this);
}
void LustreParser::Expr_parenContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpr_paren(this);
}

std::any LustreParser::Expr_parenContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitExpr_paren(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Expr_array_exprContext ------------------------------------------------------------------

LustreParser::Array_exprContext* LustreParser::Expr_array_exprContext::array_expr() {
  return getRuleContext<LustreParser::Array_exprContext>(0);
}

LustreParser::Expr_array_exprContext::Expr_array_exprContext(ExprContext *ctx) { copyFrom(ctx); }

void LustreParser::Expr_array_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpr_array_expr(this);
}
void LustreParser::Expr_array_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpr_array_expr(this);
}

std::any LustreParser::Expr_array_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitExpr_array_expr(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Expr_kind2Context ------------------------------------------------------------------

LustreParser::Kind2_exprContext* LustreParser::Expr_kind2Context::kind2_expr() {
  return getRuleContext<LustreParser::Kind2_exprContext>(0);
}

LustreParser::Expr_kind2Context::Expr_kind2Context(ExprContext *ctx) { copyFrom(ctx); }

void LustreParser::Expr_kind2Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpr_kind2(this);
}
void LustreParser::Expr_kind2Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpr_kind2(this);
}

std::any LustreParser::Expr_kind2Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitExpr_kind2(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Expr_switch_exprContext ------------------------------------------------------------------

LustreParser::Switch_exprContext* LustreParser::Expr_switch_exprContext::switch_expr() {
  return getRuleContext<LustreParser::Switch_exprContext>(0);
}

LustreParser::Expr_switch_exprContext::Expr_switch_exprContext(ExprContext *ctx) { copyFrom(ctx); }

void LustreParser::Expr_switch_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpr_switch_expr(this);
}
void LustreParser::Expr_switch_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpr_switch_expr(this);
}

std::any LustreParser::Expr_switch_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitExpr_switch_expr(this);
  else
    return visitor->visitChildren(this);
}
LustreParser::ExprContext* LustreParser::expr() {
  ExprContext *_localctx = _tracker.createInstance<ExprContext>(_ctx, getState());
  enterRule(_localctx, 114, LustreParser::RuleExpr);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(782);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 81, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<LustreParser::Expr_simple_exprContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(766);
      simple_expr(0);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<LustreParser::Expr_last_declContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(767);
      match(LustreParser::T__41);
      setState(768);
      match(LustreParser::T__66);
      setState(769);
      match(LustreParser::ID);
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<LustreParser::Expr_tempo_exprContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(770);
      tempo_expr();
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<LustreParser::Expr_bool_exprContext>(_localctx);
      enterOuterAlt(_localctx, 4);
      setState(771);
      bool_expr();
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<LustreParser::Expr_array_exprContext>(_localctx);
      enterOuterAlt(_localctx, 5);
      setState(772);
      array_expr();
      break;
    }

    case 6: {
      _localctx = _tracker.createInstance<LustreParser::Expr_struct_exprContext>(_localctx);
      enterOuterAlt(_localctx, 6);
      setState(773);
      struct_expr();
      break;
    }

    case 7: {
      _localctx = _tracker.createInstance<LustreParser::Expr_mixed_constructorContext>(_localctx);
      enterOuterAlt(_localctx, 7);
      setState(774);
      mixed_constructor();
      break;
    }

    case 8: {
      _localctx = _tracker.createInstance<LustreParser::Expr_switch_exprContext>(_localctx);
      enterOuterAlt(_localctx, 8);
      setState(775);
      switch_expr();
      break;
    }

    case 9: {
      _localctx = _tracker.createInstance<LustreParser::Expr_parenContext>(_localctx);
      enterOuterAlt(_localctx, 9);
      setState(776);
      match(LustreParser::T__14);
      setState(777);
      expr();
      setState(778);
      match(LustreParser::T__15);
      break;
    }

    case 10: {
      _localctx = _tracker.createInstance<LustreParser::Expr_apply_exprContext>(_localctx);
      enterOuterAlt(_localctx, 10);
      setState(780);
      apply_expr();
      break;
    }

    case 11: {
      _localctx = _tracker.createInstance<LustreParser::Expr_kind2Context>(_localctx);
      enterOuterAlt(_localctx, 11);
      setState(781);
      kind2_expr();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ListContext ------------------------------------------------------------------

LustreParser::ListContext::ListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<LustreParser::Simple_exprContext *> LustreParser::ListContext::simple_expr() {
  return getRuleContexts<LustreParser::Simple_exprContext>();
}

LustreParser::Simple_exprContext* LustreParser::ListContext::simple_expr(size_t i) {
  return getRuleContext<LustreParser::Simple_exprContext>(i);
}


size_t LustreParser::ListContext::getRuleIndex() const {
  return LustreParser::RuleList;
}

void LustreParser::ListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterList(this);
}

void LustreParser::ListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitList(this);
}


std::any LustreParser::ListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitList(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::ListContext* LustreParser::list() {
  ListContext *_localctx = _tracker.createInstance<ListContext>(_ctx, getState());
  enterRule(_localctx, 116, LustreParser::RuleList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(792);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 2267642101760) != 0) || ((((_la - 83) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 83)) & -72057593501057023) != 0) || _la == LustreParser::ID) {
      setState(784);
      simple_expr(0);
      setState(789);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == LustreParser::T__6) {
        setState(785);
        match(LustreParser::T__6);
        setState(786);
        simple_expr(0);
        setState(791);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Kind2_exprContext ------------------------------------------------------------------

LustreParser::Kind2_exprContext::Kind2_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LustreParser::Activate_exprContext* LustreParser::Kind2_exprContext::activate_expr() {
  return getRuleContext<LustreParser::Activate_exprContext>(0);
}

LustreParser::Restart_exprContext* LustreParser::Kind2_exprContext::restart_expr() {
  return getRuleContext<LustreParser::Restart_exprContext>(0);
}


size_t LustreParser::Kind2_exprContext::getRuleIndex() const {
  return LustreParser::RuleKind2_expr;
}

void LustreParser::Kind2_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKind2_expr(this);
}

void LustreParser::Kind2_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKind2_expr(this);
}


std::any LustreParser::Kind2_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitKind2_expr(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Kind2_exprContext* LustreParser::kind2_expr() {
  Kind2_exprContext *_localctx = _tracker.createInstance<Kind2_exprContext>(_ctx, getState());
  enterRule(_localctx, 118, LustreParser::RuleKind2_expr);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(796);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LustreParser::T__67: {
        enterOuterAlt(_localctx, 1);
        setState(794);
        activate_expr();
        break;
      }

      case LustreParser::T__69: {
        enterOuterAlt(_localctx, 2);
        setState(795);
        restart_expr();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Activate_exprContext ------------------------------------------------------------------

LustreParser::Activate_exprContext::Activate_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> LustreParser::Activate_exprContext::ID() {
  return getTokens(LustreParser::ID);
}

tree::TerminalNode* LustreParser::Activate_exprContext::ID(size_t i) {
  return getToken(LustreParser::ID, i);
}

LustreParser::ParamsContext* LustreParser::Activate_exprContext::params() {
  return getRuleContext<LustreParser::ParamsContext>(0);
}


size_t LustreParser::Activate_exprContext::getRuleIndex() const {
  return LustreParser::RuleActivate_expr;
}

void LustreParser::Activate_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterActivate_expr(this);
}

void LustreParser::Activate_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitActivate_expr(this);
}


std::any LustreParser::Activate_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitActivate_expr(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Activate_exprContext* LustreParser::activate_expr() {
  Activate_exprContext *_localctx = _tracker.createInstance<Activate_exprContext>(_ctx, getState());
  enterRule(_localctx, 120, LustreParser::RuleActivate_expr);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(798);
    match(LustreParser::T__67);
    setState(799);
    match(LustreParser::ID);
    setState(800);
    match(LustreParser::T__68);
    setState(801);
    match(LustreParser::ID);
    setState(802);
    match(LustreParser::T__15);
    setState(803);
    params();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Restart_exprContext ------------------------------------------------------------------

LustreParser::Restart_exprContext::Restart_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> LustreParser::Restart_exprContext::ID() {
  return getTokens(LustreParser::ID);
}

tree::TerminalNode* LustreParser::Restart_exprContext::ID(size_t i) {
  return getToken(LustreParser::ID, i);
}

LustreParser::ParamsContext* LustreParser::Restart_exprContext::params() {
  return getRuleContext<LustreParser::ParamsContext>(0);
}


size_t LustreParser::Restart_exprContext::getRuleIndex() const {
  return LustreParser::RuleRestart_expr;
}

void LustreParser::Restart_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRestart_expr(this);
}

void LustreParser::Restart_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRestart_expr(this);
}


std::any LustreParser::Restart_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitRestart_expr(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Restart_exprContext* LustreParser::restart_expr() {
  Restart_exprContext *_localctx = _tracker.createInstance<Restart_exprContext>(_ctx, getState());
  enterRule(_localctx, 122, LustreParser::RuleRestart_expr);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(805);
    match(LustreParser::T__69);
    setState(806);
    match(LustreParser::ID);
    setState(807);
    match(LustreParser::T__68);
    setState(808);
    match(LustreParser::ID);
    setState(809);
    match(LustreParser::T__15);
    setState(810);
    params();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Tempo_exprContext ------------------------------------------------------------------

LustreParser::Tempo_exprContext::Tempo_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::Tempo_exprContext::getRuleIndex() const {
  return LustreParser::RuleTempo_expr;
}

void LustreParser::Tempo_exprContext::copyFrom(Tempo_exprContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Tempo_expr_arrow_tempoContext ------------------------------------------------------------------

LustreParser::Simple_exprContext* LustreParser::Tempo_expr_arrow_tempoContext::simple_expr() {
  return getRuleContext<LustreParser::Simple_exprContext>(0);
}

LustreParser::Tempo_exprContext* LustreParser::Tempo_expr_arrow_tempoContext::tempo_expr() {
  return getRuleContext<LustreParser::Tempo_exprContext>(0);
}

LustreParser::Tempo_expr_arrow_tempoContext::Tempo_expr_arrow_tempoContext(Tempo_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Tempo_expr_arrow_tempoContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTempo_expr_arrow_tempo(this);
}
void LustreParser::Tempo_expr_arrow_tempoContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTempo_expr_arrow_tempo(this);
}

std::any LustreParser::Tempo_expr_arrow_tempoContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitTempo_expr_arrow_tempo(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Tempo_expr_mergeContext ------------------------------------------------------------------

tree::TerminalNode* LustreParser::Tempo_expr_mergeContext::ID() {
  return getToken(LustreParser::ID, 0);
}

std::vector<LustreParser::Simple_exprContext *> LustreParser::Tempo_expr_mergeContext::simple_expr() {
  return getRuleContexts<LustreParser::Simple_exprContext>();
}

LustreParser::Simple_exprContext* LustreParser::Tempo_expr_mergeContext::simple_expr(size_t i) {
  return getRuleContext<LustreParser::Simple_exprContext>(i);
}

LustreParser::Tempo_expr_mergeContext::Tempo_expr_mergeContext(Tempo_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Tempo_expr_mergeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTempo_expr_merge(this);
}
void LustreParser::Tempo_expr_mergeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTempo_expr_merge(this);
}

std::any LustreParser::Tempo_expr_mergeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitTempo_expr_merge(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Tempo_expr_arrowContext ------------------------------------------------------------------

std::vector<LustreParser::Simple_exprContext *> LustreParser::Tempo_expr_arrowContext::simple_expr() {
  return getRuleContexts<LustreParser::Simple_exprContext>();
}

LustreParser::Simple_exprContext* LustreParser::Tempo_expr_arrowContext::simple_expr(size_t i) {
  return getRuleContext<LustreParser::Simple_exprContext>(i);
}

LustreParser::Tempo_expr_arrowContext::Tempo_expr_arrowContext(Tempo_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Tempo_expr_arrowContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTempo_expr_arrow(this);
}
void LustreParser::Tempo_expr_arrowContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTempo_expr_arrow(this);
}

std::any LustreParser::Tempo_expr_arrowContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitTempo_expr_arrow(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Tempo_expr_fbyContext ------------------------------------------------------------------

std::vector<LustreParser::Simple_exprContext *> LustreParser::Tempo_expr_fbyContext::simple_expr() {
  return getRuleContexts<LustreParser::Simple_exprContext>();
}

LustreParser::Simple_exprContext* LustreParser::Tempo_expr_fbyContext::simple_expr(size_t i) {
  return getRuleContext<LustreParser::Simple_exprContext>(i);
}

LustreParser::Const_exprContext* LustreParser::Tempo_expr_fbyContext::const_expr() {
  return getRuleContext<LustreParser::Const_exprContext>(0);
}

LustreParser::Tempo_expr_fbyContext::Tempo_expr_fbyContext(Tempo_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Tempo_expr_fbyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTempo_expr_fby(this);
}
void LustreParser::Tempo_expr_fbyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTempo_expr_fby(this);
}

std::any LustreParser::Tempo_expr_fbyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitTempo_expr_fby(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Tempo_expr_preContext ------------------------------------------------------------------

LustreParser::Simple_exprContext* LustreParser::Tempo_expr_preContext::simple_expr() {
  return getRuleContext<LustreParser::Simple_exprContext>(0);
}

LustreParser::Tempo_expr_preContext::Tempo_expr_preContext(Tempo_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Tempo_expr_preContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTempo_expr_pre(this);
}
void LustreParser::Tempo_expr_preContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTempo_expr_pre(this);
}

std::any LustreParser::Tempo_expr_preContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitTempo_expr_pre(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Tempo_expr_whenContext ------------------------------------------------------------------

LustreParser::Simple_exprContext* LustreParser::Tempo_expr_whenContext::simple_expr() {
  return getRuleContext<LustreParser::Simple_exprContext>(0);
}

LustreParser::Clock_exprContext* LustreParser::Tempo_expr_whenContext::clock_expr() {
  return getRuleContext<LustreParser::Clock_exprContext>(0);
}

LustreParser::Tempo_expr_whenContext::Tempo_expr_whenContext(Tempo_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Tempo_expr_whenContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTempo_expr_when(this);
}
void LustreParser::Tempo_expr_whenContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTempo_expr_when(this);
}

std::any LustreParser::Tempo_expr_whenContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitTempo_expr_when(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Tempo_expr_fby_noconstContext ------------------------------------------------------------------

std::vector<LustreParser::Simple_exprContext *> LustreParser::Tempo_expr_fby_noconstContext::simple_expr() {
  return getRuleContexts<LustreParser::Simple_exprContext>();
}

LustreParser::Simple_exprContext* LustreParser::Tempo_expr_fby_noconstContext::simple_expr(size_t i) {
  return getRuleContext<LustreParser::Simple_exprContext>(i);
}

LustreParser::Tempo_expr_fby_noconstContext::Tempo_expr_fby_noconstContext(Tempo_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Tempo_expr_fby_noconstContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTempo_expr_fby_noconst(this);
}
void LustreParser::Tempo_expr_fby_noconstContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTempo_expr_fby_noconst(this);
}

std::any LustreParser::Tempo_expr_fby_noconstContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitTempo_expr_fby_noconst(this);
  else
    return visitor->visitChildren(this);
}
LustreParser::Tempo_exprContext* LustreParser::tempo_expr() {
  Tempo_exprContext *_localctx = _tracker.createInstance<Tempo_exprContext>(_ctx, getState());
  enterRule(_localctx, 124, LustreParser::RuleTempo_expr);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(858);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 87, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<LustreParser::Tempo_expr_preContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(812);
      match(LustreParser::T__70);
      setState(813);
      simple_expr(0);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<LustreParser::Tempo_expr_arrow_tempoContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(814);
      simple_expr(0);
      setState(815);
      match(LustreParser::T__71);
      setState(816);
      tempo_expr();
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<LustreParser::Tempo_expr_arrowContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(818);
      simple_expr(0);
      setState(819);
      match(LustreParser::T__71);
      setState(820);
      simple_expr(0);
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<LustreParser::Tempo_expr_fbyContext>(_localctx);
      enterOuterAlt(_localctx, 4);
      setState(822);
      match(LustreParser::T__72);
      setState(823);
      match(LustreParser::T__14);
      setState(824);
      simple_expr(0);
      setState(829);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == LustreParser::T__6) {
        setState(825);
        match(LustreParser::T__6);
        setState(826);
        simple_expr(0);
        setState(831);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(832);
      match(LustreParser::T__1);
      setState(833);
      const_expr(0);
      setState(834);
      match(LustreParser::T__1);
      setState(835);
      simple_expr(0);
      setState(840);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == LustreParser::T__6) {
        setState(836);
        match(LustreParser::T__6);
        setState(837);
        simple_expr(0);
        setState(842);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(843);
      match(LustreParser::T__15);
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<LustreParser::Tempo_expr_fby_noconstContext>(_localctx);
      enterOuterAlt(_localctx, 5);
      setState(845);
      simple_expr(0);
      setState(846);
      match(LustreParser::T__72);
      setState(847);
      simple_expr(0);
      break;
    }

    case 6: {
      _localctx = _tracker.createInstance<LustreParser::Tempo_expr_whenContext>(_localctx);
      enterOuterAlt(_localctx, 6);
      setState(849);
      simple_expr(0);
      setState(850);
      match(LustreParser::T__39);
      setState(851);
      clock_expr();
      break;
    }

    case 7: {
      _localctx = _tracker.createInstance<LustreParser::Tempo_expr_mergeContext>(_localctx);
      enterOuterAlt(_localctx, 7);
      setState(853);
      match(LustreParser::T__50);
      setState(854);
      match(LustreParser::ID);

      setState(855);
      simple_expr(0);

      setState(856);
      simple_expr(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bool_exprContext ------------------------------------------------------------------

LustreParser::Bool_exprContext::Bool_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LustreParser::ListContext* LustreParser::Bool_exprContext::list() {
  return getRuleContext<LustreParser::ListContext>(0);
}


size_t LustreParser::Bool_exprContext::getRuleIndex() const {
  return LustreParser::RuleBool_expr;
}

void LustreParser::Bool_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBool_expr(this);
}

void LustreParser::Bool_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBool_expr(this);
}


std::any LustreParser::Bool_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitBool_expr(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Bool_exprContext* LustreParser::bool_expr() {
  Bool_exprContext *_localctx = _tracker.createInstance<Bool_exprContext>(_ctx, getState());
  enterRule(_localctx, 126, LustreParser::RuleBool_expr);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(861);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == LustreParser::T__73) {
      setState(860);
      match(LustreParser::T__73);
    }
    setState(864);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 89, _ctx)) {
    case 1: {
      setState(863);
      match(LustreParser::T__14);
      break;
    }

    default:
      break;
    }
    setState(866);
    list();
    setState(868);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 90, _ctx)) {
    case 1: {
      setState(867);
      match(LustreParser::T__15);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Array_exprContext ------------------------------------------------------------------

LustreParser::Array_exprContext::Array_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::Array_exprContext::getRuleIndex() const {
  return LustreParser::RuleArray_expr;
}

void LustreParser::Array_exprContext::copyFrom(Array_exprContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Array_expr_splitContext ------------------------------------------------------------------

LustreParser::Simple_exprContext* LustreParser::Array_expr_splitContext::simple_expr() {
  return getRuleContext<LustreParser::Simple_exprContext>(0);
}

std::vector<tree::TerminalNode *> LustreParser::Array_expr_splitContext::INTEGER() {
  return getTokens(LustreParser::INTEGER);
}

tree::TerminalNode* LustreParser::Array_expr_splitContext::INTEGER(size_t i) {
  return getToken(LustreParser::INTEGER, i);
}

LustreParser::Array_expr_splitContext::Array_expr_splitContext(Array_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Array_expr_splitContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArray_expr_split(this);
}
void LustreParser::Array_expr_splitContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArray_expr_split(this);
}

std::any LustreParser::Array_expr_splitContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitArray_expr_split(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Array_expr_andContext ------------------------------------------------------------------

LustreParser::Simple_exprContext* LustreParser::Array_expr_andContext::simple_expr() {
  return getRuleContext<LustreParser::Simple_exprContext>(0);
}

LustreParser::Const_exprContext* LustreParser::Array_expr_andContext::const_expr() {
  return getRuleContext<LustreParser::Const_exprContext>(0);
}

LustreParser::Array_expr_andContext::Array_expr_andContext(Array_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Array_expr_andContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArray_expr_and(this);
}
void LustreParser::Array_expr_andContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArray_expr_and(this);
}

std::any LustreParser::Array_expr_andContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitArray_expr_and(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Array_expr_listContext ------------------------------------------------------------------

std::vector<LustreParser::ListContext *> LustreParser::Array_expr_listContext::list() {
  return getRuleContexts<LustreParser::ListContext>();
}

LustreParser::ListContext* LustreParser::Array_expr_listContext::list(size_t i) {
  return getRuleContext<LustreParser::ListContext>(i);
}

LustreParser::Array_expr_listContext::Array_expr_listContext(Array_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Array_expr_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArray_expr_list(this);
}
void LustreParser::Array_expr_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArray_expr_list(this);
}

std::any LustreParser::Array_expr_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitArray_expr_list(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Array_expr_dynamicContext ------------------------------------------------------------------

std::vector<LustreParser::Simple_exprContext *> LustreParser::Array_expr_dynamicContext::simple_expr() {
  return getRuleContexts<LustreParser::Simple_exprContext>();
}

LustreParser::Simple_exprContext* LustreParser::Array_expr_dynamicContext::simple_expr(size_t i) {
  return getRuleContext<LustreParser::Simple_exprContext>(i);
}

std::vector<LustreParser::IndexContext *> LustreParser::Array_expr_dynamicContext::index() {
  return getRuleContexts<LustreParser::IndexContext>();
}

LustreParser::IndexContext* LustreParser::Array_expr_dynamicContext::index(size_t i) {
  return getRuleContext<LustreParser::IndexContext>(i);
}

LustreParser::Array_expr_dynamicContext::Array_expr_dynamicContext(Array_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Array_expr_dynamicContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArray_expr_dynamic(this);
}
void LustreParser::Array_expr_dynamicContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArray_expr_dynamic(this);
}

std::any LustreParser::Array_expr_dynamicContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitArray_expr_dynamic(this);
  else
    return visitor->visitChildren(this);
}
LustreParser::Array_exprContext* LustreParser::array_expr() {
  Array_exprContext *_localctx = _tracker.createInstance<Array_exprContext>(_ctx, getState());
  enterRule(_localctx, 128, LustreParser::RuleArray_expr);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(906);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 93, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<LustreParser::Array_expr_splitContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(870);
      simple_expr(0);
      setState(871);
      match(LustreParser::T__37);
      setState(872);
      match(LustreParser::INTEGER);
      setState(873);
      match(LustreParser::T__56);
      setState(874);
      match(LustreParser::INTEGER);
      setState(875);
      match(LustreParser::T__38);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<LustreParser::Array_expr_dynamicContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(877);
      match(LustreParser::T__14);
      setState(878);
      simple_expr(0);
      setState(879);
      match(LustreParser::T__74);
      setState(881); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(880);
        index();
        setState(883); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == LustreParser::T__37);
      setState(885);
      match(LustreParser::T__75);
      setState(886);
      simple_expr(0);
      setState(887);
      match(LustreParser::T__15);
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<LustreParser::Array_expr_andContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(889);
      simple_expr(0);
      setState(890);
      match(LustreParser::T__35);
      setState(891);
      const_expr(0);
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<LustreParser::Array_expr_listContext>(_localctx);
      enterOuterAlt(_localctx, 4);
      setState(893);
      match(LustreParser::T__37);
      setState(894);
      list();
      setState(895);
      match(LustreParser::T__38);
      setState(903);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == LustreParser::T__6) {
        setState(896);
        match(LustreParser::T__6);
        setState(897);
        match(LustreParser::T__37);
        setState(898);
        list();
        setState(899);
        match(LustreParser::T__38);
        setState(905);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Struct_exprContext ------------------------------------------------------------------

LustreParser::Struct_exprContext::Struct_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<LustreParser::Label_exprContext *> LustreParser::Struct_exprContext::label_expr() {
  return getRuleContexts<LustreParser::Label_exprContext>();
}

LustreParser::Label_exprContext* LustreParser::Struct_exprContext::label_expr(size_t i) {
  return getRuleContext<LustreParser::Label_exprContext>(i);
}


size_t LustreParser::Struct_exprContext::getRuleIndex() const {
  return LustreParser::RuleStruct_expr;
}

void LustreParser::Struct_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStruct_expr(this);
}

void LustreParser::Struct_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStruct_expr(this);
}


std::any LustreParser::Struct_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitStruct_expr(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Struct_exprContext* LustreParser::struct_expr() {
  Struct_exprContext *_localctx = _tracker.createInstance<Struct_exprContext>(_ctx, getState());
  enterRule(_localctx, 130, LustreParser::RuleStruct_expr);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(908);
    match(LustreParser::T__24);
    setState(909);
    label_expr();
    setState(914);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == LustreParser::T__1

    || _la == LustreParser::T__6) {
      setState(910);
      _la = _input->LA(1);
      if (!(_la == LustreParser::T__1

      || _la == LustreParser::T__6)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(911);
      label_expr();
      setState(916);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(917);
    match(LustreParser::T__25);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Mixed_constructorContext ------------------------------------------------------------------

LustreParser::Mixed_constructorContext::Mixed_constructorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LustreParser::Mixed_constructorContext::ID() {
  return getToken(LustreParser::ID, 0);
}

LustreParser::Simple_exprContext* LustreParser::Mixed_constructorContext::simple_expr() {
  return getRuleContext<LustreParser::Simple_exprContext>(0);
}

std::vector<LustreParser::Label_or_indexContext *> LustreParser::Mixed_constructorContext::label_or_index() {
  return getRuleContexts<LustreParser::Label_or_indexContext>();
}

LustreParser::Label_or_indexContext* LustreParser::Mixed_constructorContext::label_or_index(size_t i) {
  return getRuleContext<LustreParser::Label_or_indexContext>(i);
}


size_t LustreParser::Mixed_constructorContext::getRuleIndex() const {
  return LustreParser::RuleMixed_constructor;
}

void LustreParser::Mixed_constructorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMixed_constructor(this);
}

void LustreParser::Mixed_constructorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMixed_constructor(this);
}


std::any LustreParser::Mixed_constructorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitMixed_constructor(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Mixed_constructorContext* LustreParser::mixed_constructor() {
  Mixed_constructorContext *_localctx = _tracker.createInstance<Mixed_constructorContext>(_ctx, getState());
  enterRule(_localctx, 132, LustreParser::RuleMixed_constructor);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(919);
    match(LustreParser::T__14);
    setState(920);
    match(LustreParser::ID);
    setState(921);
    match(LustreParser::T__76);
    setState(923); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(922);
      label_or_index();
      setState(925); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == LustreParser::T__37

    || _la == LustreParser::T__74);
    setState(927);
    match(LustreParser::T__7);
    setState(928);
    simple_expr(0);
    setState(929);
    match(LustreParser::T__15);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Label_exprContext ------------------------------------------------------------------

LustreParser::Label_exprContext::Label_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LustreParser::Label_exprContext::ID() {
  return getToken(LustreParser::ID, 0);
}

LustreParser::Simple_exprContext* LustreParser::Label_exprContext::simple_expr() {
  return getRuleContext<LustreParser::Simple_exprContext>(0);
}


size_t LustreParser::Label_exprContext::getRuleIndex() const {
  return LustreParser::RuleLabel_expr;
}

void LustreParser::Label_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLabel_expr(this);
}

void LustreParser::Label_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLabel_expr(this);
}


std::any LustreParser::Label_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitLabel_expr(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Label_exprContext* LustreParser::label_expr() {
  Label_exprContext *_localctx = _tracker.createInstance<Label_exprContext>(_ctx, getState());
  enterRule(_localctx, 134, LustreParser::RuleLabel_expr);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(931);
    match(LustreParser::ID);
    setState(932);
    match(LustreParser::T__19);
    setState(933);
    simple_expr(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexContext ------------------------------------------------------------------

LustreParser::IndexContext::IndexContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LustreParser::Simple_exprContext* LustreParser::IndexContext::simple_expr() {
  return getRuleContext<LustreParser::Simple_exprContext>(0);
}


size_t LustreParser::IndexContext::getRuleIndex() const {
  return LustreParser::RuleIndex;
}

void LustreParser::IndexContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndex(this);
}

void LustreParser::IndexContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndex(this);
}


std::any LustreParser::IndexContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitIndex(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::IndexContext* LustreParser::index() {
  IndexContext *_localctx = _tracker.createInstance<IndexContext>(_ctx, getState());
  enterRule(_localctx, 136, LustreParser::RuleIndex);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(935);
    match(LustreParser::T__37);
    setState(936);
    simple_expr(0);
    setState(937);
    match(LustreParser::T__38);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Label_or_indexContext ------------------------------------------------------------------

LustreParser::Label_or_indexContext::Label_or_indexContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::Label_or_indexContext::getRuleIndex() const {
  return LustreParser::RuleLabel_or_index;
}

void LustreParser::Label_or_indexContext::copyFrom(Label_or_indexContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Mix_labelContext ------------------------------------------------------------------

tree::TerminalNode* LustreParser::Mix_labelContext::ID() {
  return getToken(LustreParser::ID, 0);
}

LustreParser::Mix_labelContext::Mix_labelContext(Label_or_indexContext *ctx) { copyFrom(ctx); }

void LustreParser::Mix_labelContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMix_label(this);
}
void LustreParser::Mix_labelContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMix_label(this);
}

std::any LustreParser::Mix_labelContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitMix_label(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Mix_indexContext ------------------------------------------------------------------

LustreParser::IndexContext* LustreParser::Mix_indexContext::index() {
  return getRuleContext<LustreParser::IndexContext>(0);
}

LustreParser::Mix_indexContext::Mix_indexContext(Label_or_indexContext *ctx) { copyFrom(ctx); }

void LustreParser::Mix_indexContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMix_index(this);
}
void LustreParser::Mix_indexContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMix_index(this);
}

std::any LustreParser::Mix_indexContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitMix_index(this);
  else
    return visitor->visitChildren(this);
}
LustreParser::Label_or_indexContext* LustreParser::label_or_index() {
  Label_or_indexContext *_localctx = _tracker.createInstance<Label_or_indexContext>(_ctx, getState());
  enterRule(_localctx, 138, LustreParser::RuleLabel_or_index);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(942);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LustreParser::T__74: {
        _localctx = _tracker.createInstance<LustreParser::Mix_labelContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(939);
        match(LustreParser::T__74);
        setState(940);
        match(LustreParser::ID);
        break;
      }

      case LustreParser::T__37: {
        _localctx = _tracker.createInstance<LustreParser::Mix_indexContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(941);
        index();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Switch_exprContext ------------------------------------------------------------------

LustreParser::Switch_exprContext::Switch_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::Switch_exprContext::getRuleIndex() const {
  return LustreParser::RuleSwitch_expr;
}

void LustreParser::Switch_exprContext::copyFrom(Switch_exprContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Switch_expr_ifelseContext ------------------------------------------------------------------

std::vector<LustreParser::Simple_exprContext *> LustreParser::Switch_expr_ifelseContext::simple_expr() {
  return getRuleContexts<LustreParser::Simple_exprContext>();
}

LustreParser::Simple_exprContext* LustreParser::Switch_expr_ifelseContext::simple_expr(size_t i) {
  return getRuleContext<LustreParser::Simple_exprContext>(i);
}

LustreParser::Switch_expr_ifelseContext::Switch_expr_ifelseContext(Switch_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Switch_expr_ifelseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSwitch_expr_ifelse(this);
}
void LustreParser::Switch_expr_ifelseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSwitch_expr_ifelse(this);
}

std::any LustreParser::Switch_expr_ifelseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitSwitch_expr_ifelse(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Switch_expr_caseContext ------------------------------------------------------------------

LustreParser::Simple_exprContext* LustreParser::Switch_expr_caseContext::simple_expr() {
  return getRuleContext<LustreParser::Simple_exprContext>(0);
}

std::vector<LustreParser::Case_exprContext *> LustreParser::Switch_expr_caseContext::case_expr() {
  return getRuleContexts<LustreParser::Case_exprContext>();
}

LustreParser::Case_exprContext* LustreParser::Switch_expr_caseContext::case_expr(size_t i) {
  return getRuleContext<LustreParser::Case_exprContext>(i);
}

LustreParser::Switch_expr_caseContext::Switch_expr_caseContext(Switch_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Switch_expr_caseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSwitch_expr_case(this);
}
void LustreParser::Switch_expr_caseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSwitch_expr_case(this);
}

std::any LustreParser::Switch_expr_caseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitSwitch_expr_case(this);
  else
    return visitor->visitChildren(this);
}
LustreParser::Switch_exprContext* LustreParser::switch_expr() {
  Switch_exprContext *_localctx = _tracker.createInstance<Switch_exprContext>(_ctx, getState());
  enterRule(_localctx, 140, LustreParser::RuleSwitch_expr);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(962);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LustreParser::T__63: {
        _localctx = _tracker.createInstance<LustreParser::Switch_expr_ifelseContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(944);
        match(LustreParser::T__63);
        setState(945);
        simple_expr(0);
        setState(946);
        match(LustreParser::T__77);
        setState(947);
        simple_expr(0);
        setState(948);
        match(LustreParser::T__78);
        setState(949);
        simple_expr(0);
        break;
      }

      case LustreParser::T__14: {
        _localctx = _tracker.createInstance<LustreParser::Switch_expr_caseContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(951);
        match(LustreParser::T__14);
        setState(952);
        match(LustreParser::T__79);
        setState(953);
        simple_expr(0);
        setState(954);
        match(LustreParser::T__80);
        setState(956); 
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(955);
          case_expr();
          setState(958); 
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while (_la == LustreParser::T__81);
        setState(960);
        match(LustreParser::T__15);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Case_exprContext ------------------------------------------------------------------

LustreParser::Case_exprContext::Case_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LustreParser::PatternContext* LustreParser::Case_exprContext::pattern() {
  return getRuleContext<LustreParser::PatternContext>(0);
}

LustreParser::Simple_exprContext* LustreParser::Case_exprContext::simple_expr() {
  return getRuleContext<LustreParser::Simple_exprContext>(0);
}


size_t LustreParser::Case_exprContext::getRuleIndex() const {
  return LustreParser::RuleCase_expr;
}

void LustreParser::Case_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCase_expr(this);
}

void LustreParser::Case_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCase_expr(this);
}


std::any LustreParser::Case_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitCase_expr(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Case_exprContext* LustreParser::case_expr() {
  Case_exprContext *_localctx = _tracker.createInstance<Case_exprContext>(_ctx, getState());
  enterRule(_localctx, 142, LustreParser::RuleCase_expr);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(964);
    match(LustreParser::T__81);
    setState(965);
    pattern();
    setState(966);
    match(LustreParser::T__19);
    setState(967);
    simple_expr(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PatternContext ------------------------------------------------------------------

LustreParser::PatternContext::PatternContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LustreParser::PatternContext::ID() {
  return getToken(LustreParser::ID, 0);
}

tree::TerminalNode* LustreParser::PatternContext::CHAR() {
  return getToken(LustreParser::CHAR, 0);
}

tree::TerminalNode* LustreParser::PatternContext::INTEGER() {
  return getToken(LustreParser::INTEGER, 0);
}

tree::TerminalNode* LustreParser::PatternContext::BOOL() {
  return getToken(LustreParser::BOOL, 0);
}


size_t LustreParser::PatternContext::getRuleIndex() const {
  return LustreParser::RulePattern;
}

void LustreParser::PatternContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPattern(this);
}

void LustreParser::PatternContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPattern(this);
}


std::any LustreParser::PatternContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitPattern(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::PatternContext* LustreParser::pattern() {
  PatternContext *_localctx = _tracker.createInstance<PatternContext>(_ctx, getState());
  enterRule(_localctx, 144, LustreParser::RulePattern);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(977);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LustreParser::ID: {
        enterOuterAlt(_localctx, 1);
        setState(969);
        match(LustreParser::ID);
        break;
      }

      case LustreParser::CHAR: {
        enterOuterAlt(_localctx, 2);
        setState(970);
        match(LustreParser::CHAR);
        break;
      }

      case LustreParser::T__82:
      case LustreParser::INTEGER: {
        enterOuterAlt(_localctx, 3);
        setState(972);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == LustreParser::T__82) {
          setState(971);
          match(LustreParser::T__82);
        }
        setState(974);
        match(LustreParser::INTEGER);
        break;
      }

      case LustreParser::BOOL: {
        enterOuterAlt(_localctx, 4);
        setState(975);
        match(LustreParser::BOOL);
        break;
      }

      case LustreParser::T__83: {
        enterOuterAlt(_localctx, 5);
        setState(976);
        match(LustreParser::T__83);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Apply_exprContext ------------------------------------------------------------------

LustreParser::Apply_exprContext::Apply_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::Apply_exprContext::getRuleIndex() const {
  return LustreParser::RuleApply_expr;
}

void LustreParser::Apply_exprContext::copyFrom(Apply_exprContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Apply_prefixContext ------------------------------------------------------------------

LustreParser::Prefix_operatorContext* LustreParser::Apply_prefixContext::prefix_operator() {
  return getRuleContext<LustreParser::Prefix_operatorContext>(0);
}

LustreParser::ListContext* LustreParser::Apply_prefixContext::list() {
  return getRuleContext<LustreParser::ListContext>(0);
}

LustreParser::Apply_prefixContext::Apply_prefixContext(Apply_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Apply_prefixContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterApply_prefix(this);
}
void LustreParser::Apply_prefixContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitApply_prefix(this);
}

std::any LustreParser::Apply_prefixContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitApply_prefix(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Apply_iteratorContext ------------------------------------------------------------------

LustreParser::IteratorContext* LustreParser::Apply_iteratorContext::iterator() {
  return getRuleContext<LustreParser::IteratorContext>(0);
}

LustreParser::Prefix_operatorContext* LustreParser::Apply_iteratorContext::prefix_operator() {
  return getRuleContext<LustreParser::Prefix_operatorContext>(0);
}

LustreParser::Const_exprContext* LustreParser::Apply_iteratorContext::const_expr() {
  return getRuleContext<LustreParser::Const_exprContext>(0);
}

LustreParser::ListContext* LustreParser::Apply_iteratorContext::list() {
  return getRuleContext<LustreParser::ListContext>(0);
}

LustreParser::Apply_iteratorContext::Apply_iteratorContext(Apply_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Apply_iteratorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterApply_iterator(this);
}
void LustreParser::Apply_iteratorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitApply_iterator(this);
}

std::any LustreParser::Apply_iteratorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitApply_iterator(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Apply_mapwIContext ------------------------------------------------------------------

LustreParser::Prefix_operatorContext* LustreParser::Apply_mapwIContext::prefix_operator() {
  return getRuleContext<LustreParser::Prefix_operatorContext>(0);
}

LustreParser::Const_exprContext* LustreParser::Apply_mapwIContext::const_expr() {
  return getRuleContext<LustreParser::Const_exprContext>(0);
}

LustreParser::Simple_exprContext* LustreParser::Apply_mapwIContext::simple_expr() {
  return getRuleContext<LustreParser::Simple_exprContext>(0);
}

std::vector<LustreParser::ListContext *> LustreParser::Apply_mapwIContext::list() {
  return getRuleContexts<LustreParser::ListContext>();
}

LustreParser::ListContext* LustreParser::Apply_mapwIContext::list(size_t i) {
  return getRuleContext<LustreParser::ListContext>(i);
}

LustreParser::Apply_mapwIContext::Apply_mapwIContext(Apply_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Apply_mapwIContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterApply_mapwI(this);
}
void LustreParser::Apply_mapwIContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitApply_mapwI(this);
}

std::any LustreParser::Apply_mapwIContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitApply_mapwI(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Apply_iterator_lv6Context ------------------------------------------------------------------

LustreParser::Iterator_lv6Context* LustreParser::Apply_iterator_lv6Context::iterator_lv6() {
  return getRuleContext<LustreParser::Iterator_lv6Context>(0);
}

std::vector<LustreParser::ListContext *> LustreParser::Apply_iterator_lv6Context::list() {
  return getRuleContexts<LustreParser::ListContext>();
}

LustreParser::ListContext* LustreParser::Apply_iterator_lv6Context::list(size_t i) {
  return getRuleContext<LustreParser::ListContext>(i);
}

LustreParser::Apply_iterator_lv6Context::Apply_iterator_lv6Context(Apply_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Apply_iterator_lv6Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterApply_iterator_lv6(this);
}
void LustreParser::Apply_iterator_lv6Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitApply_iterator_lv6(this);
}

std::any LustreParser::Apply_iterator_lv6Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitApply_iterator_lv6(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Apply_mapwContext ------------------------------------------------------------------

LustreParser::Prefix_operatorContext* LustreParser::Apply_mapwContext::prefix_operator() {
  return getRuleContext<LustreParser::Prefix_operatorContext>(0);
}

LustreParser::Const_exprContext* LustreParser::Apply_mapwContext::const_expr() {
  return getRuleContext<LustreParser::Const_exprContext>(0);
}

LustreParser::Simple_exprContext* LustreParser::Apply_mapwContext::simple_expr() {
  return getRuleContext<LustreParser::Simple_exprContext>(0);
}

std::vector<LustreParser::ListContext *> LustreParser::Apply_mapwContext::list() {
  return getRuleContexts<LustreParser::ListContext>();
}

LustreParser::ListContext* LustreParser::Apply_mapwContext::list(size_t i) {
  return getRuleContext<LustreParser::ListContext>(i);
}

LustreParser::Apply_mapwContext::Apply_mapwContext(Apply_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Apply_mapwContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterApply_mapw(this);
}
void LustreParser::Apply_mapwContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitApply_mapw(this);
}

std::any LustreParser::Apply_mapwContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitApply_mapw(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Apply_foldwContext ------------------------------------------------------------------

LustreParser::Prefix_operatorContext* LustreParser::Apply_foldwContext::prefix_operator() {
  return getRuleContext<LustreParser::Prefix_operatorContext>(0);
}

LustreParser::Const_exprContext* LustreParser::Apply_foldwContext::const_expr() {
  return getRuleContext<LustreParser::Const_exprContext>(0);
}

LustreParser::Simple_exprContext* LustreParser::Apply_foldwContext::simple_expr() {
  return getRuleContext<LustreParser::Simple_exprContext>(0);
}

LustreParser::ListContext* LustreParser::Apply_foldwContext::list() {
  return getRuleContext<LustreParser::ListContext>(0);
}

LustreParser::Apply_foldwContext::Apply_foldwContext(Apply_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Apply_foldwContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterApply_foldw(this);
}
void LustreParser::Apply_foldwContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitApply_foldw(this);
}

std::any LustreParser::Apply_foldwContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitApply_foldw(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Apply_foldwiContext ------------------------------------------------------------------

LustreParser::Prefix_operatorContext* LustreParser::Apply_foldwiContext::prefix_operator() {
  return getRuleContext<LustreParser::Prefix_operatorContext>(0);
}

LustreParser::Const_exprContext* LustreParser::Apply_foldwiContext::const_expr() {
  return getRuleContext<LustreParser::Const_exprContext>(0);
}

LustreParser::Simple_exprContext* LustreParser::Apply_foldwiContext::simple_expr() {
  return getRuleContext<LustreParser::Simple_exprContext>(0);
}

LustreParser::ListContext* LustreParser::Apply_foldwiContext::list() {
  return getRuleContext<LustreParser::ListContext>(0);
}

LustreParser::Apply_foldwiContext::Apply_foldwiContext(Apply_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Apply_foldwiContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterApply_foldwi(this);
}
void LustreParser::Apply_foldwiContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitApply_foldwi(this);
}

std::any LustreParser::Apply_foldwiContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitApply_foldwi(this);
  else
    return visitor->visitChildren(this);
}
LustreParser::Apply_exprContext* LustreParser::apply_expr() {
  Apply_exprContext *_localctx = _tracker.createInstance<Apply_exprContext>(_ctx, getState());
  enterRule(_localctx, 146, LustreParser::RuleApply_expr);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1058);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 101, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<LustreParser::Apply_prefixContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(979);
      prefix_operator();
      setState(980);
      match(LustreParser::T__14);
      setState(981);
      list();
      setState(982);
      match(LustreParser::T__15);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<LustreParser::Apply_iteratorContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(984);
      iterator();
      setState(985);
      match(LustreParser::T__84);
      setState(986);
      prefix_operator();
      setState(987);
      match(LustreParser::T__6);
      setState(988);
      const_expr(0);
      setState(989);
      match(LustreParser::T__85);
      setState(990);
      match(LustreParser::T__14);
      setState(991);
      list();
      setState(992);
      match(LustreParser::T__15);
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<LustreParser::Apply_iterator_lv6Context>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(994);
      iterator_lv6();
      setState(995);
      match(LustreParser::T__84);
      setState(996);
      list();
      setState(997);
      match(LustreParser::T__85);
      setState(998);
      match(LustreParser::T__14);
      setState(999);
      list();
      setState(1000);
      match(LustreParser::T__15);
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<LustreParser::Apply_mapwContext>(_localctx);
      enterOuterAlt(_localctx, 4);
      setState(1002);
      match(LustreParser::T__86);
      setState(1003);
      match(LustreParser::T__84);
      setState(1004);
      prefix_operator();
      setState(1005);
      match(LustreParser::T__6);
      setState(1006);
      const_expr(0);
      setState(1007);
      match(LustreParser::T__85);
      setState(1008);
      match(LustreParser::T__63);
      setState(1009);
      simple_expr(0);
      setState(1010);
      match(LustreParser::T__75);
      setState(1011);
      match(LustreParser::T__14);
      setState(1012);
      list();
      setState(1013);
      match(LustreParser::T__15);
      setState(1014);
      match(LustreParser::T__14);
      setState(1015);
      list();
      setState(1016);
      match(LustreParser::T__15);
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<LustreParser::Apply_mapwIContext>(_localctx);
      enterOuterAlt(_localctx, 5);
      setState(1018);
      match(LustreParser::T__87);
      setState(1019);
      match(LustreParser::T__84);
      setState(1020);
      prefix_operator();
      setState(1021);
      match(LustreParser::T__6);
      setState(1022);
      const_expr(0);
      setState(1023);
      match(LustreParser::T__85);
      setState(1024);
      match(LustreParser::T__63);
      setState(1025);
      simple_expr(0);
      setState(1026);
      match(LustreParser::T__75);
      setState(1027);
      match(LustreParser::T__14);
      setState(1028);
      list();
      setState(1029);
      match(LustreParser::T__15);
      setState(1030);
      match(LustreParser::T__14);
      setState(1031);
      list();
      setState(1032);
      match(LustreParser::T__15);
      break;
    }

    case 6: {
      _localctx = _tracker.createInstance<LustreParser::Apply_foldwContext>(_localctx);
      enterOuterAlt(_localctx, 6);
      setState(1034);
      match(LustreParser::T__88);
      setState(1035);
      match(LustreParser::T__84);
      setState(1036);
      prefix_operator();
      setState(1037);
      match(LustreParser::T__6);
      setState(1038);
      const_expr(0);
      setState(1039);
      match(LustreParser::T__85);
      setState(1040);
      match(LustreParser::T__63);
      setState(1041);
      simple_expr(0);
      setState(1042);
      match(LustreParser::T__14);
      setState(1043);
      list();
      setState(1044);
      match(LustreParser::T__15);
      break;
    }

    case 7: {
      _localctx = _tracker.createInstance<LustreParser::Apply_foldwiContext>(_localctx);
      enterOuterAlt(_localctx, 7);
      setState(1046);
      match(LustreParser::T__89);
      setState(1047);
      match(LustreParser::T__84);
      setState(1048);
      prefix_operator();
      setState(1049);
      match(LustreParser::T__6);
      setState(1050);
      const_expr(0);
      setState(1051);
      match(LustreParser::T__85);
      setState(1052);
      match(LustreParser::T__63);
      setState(1053);
      simple_expr(0);
      setState(1054);
      match(LustreParser::T__14);
      setState(1055);
      list();
      setState(1056);
      match(LustreParser::T__15);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Prefix_operatorContext ------------------------------------------------------------------

LustreParser::Prefix_operatorContext::Prefix_operatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::Prefix_operatorContext::getRuleIndex() const {
  return LustreParser::RulePrefix_operator;
}

void LustreParser::Prefix_operatorContext::copyFrom(Prefix_operatorContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Perfix_flattenContext ------------------------------------------------------------------

tree::TerminalNode* LustreParser::Perfix_flattenContext::ID() {
  return getToken(LustreParser::ID, 0);
}

LustreParser::Perfix_flattenContext::Perfix_flattenContext(Prefix_operatorContext *ctx) { copyFrom(ctx); }

void LustreParser::Perfix_flattenContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPerfix_flatten(this);
}
void LustreParser::Perfix_flattenContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPerfix_flatten(this);
}

std::any LustreParser::Perfix_flattenContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitPerfix_flatten(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Prefix_unaryContext ------------------------------------------------------------------

LustreParser::Prefix_unary_operatorContext* LustreParser::Prefix_unaryContext::prefix_unary_operator() {
  return getRuleContext<LustreParser::Prefix_unary_operatorContext>(0);
}

LustreParser::Prefix_unaryContext::Prefix_unaryContext(Prefix_operatorContext *ctx) { copyFrom(ctx); }

void LustreParser::Prefix_unaryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrefix_unary(this);
}
void LustreParser::Prefix_unaryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrefix_unary(this);
}

std::any LustreParser::Prefix_unaryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitPrefix_unary(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Perfix_IDContext ------------------------------------------------------------------

tree::TerminalNode* LustreParser::Perfix_IDContext::ID() {
  return getToken(LustreParser::ID, 0);
}

LustreParser::Perfix_IDContext::Perfix_IDContext(Prefix_operatorContext *ctx) { copyFrom(ctx); }

void LustreParser::Perfix_IDContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPerfix_ID(this);
}
void LustreParser::Perfix_IDContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPerfix_ID(this);
}

std::any LustreParser::Perfix_IDContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitPerfix_ID(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Prefix_binaryContext ------------------------------------------------------------------

LustreParser::Prefix_binary_operatorContext* LustreParser::Prefix_binaryContext::prefix_binary_operator() {
  return getRuleContext<LustreParser::Prefix_binary_operatorContext>(0);
}

LustreParser::Prefix_binaryContext::Prefix_binaryContext(Prefix_operatorContext *ctx) { copyFrom(ctx); }

void LustreParser::Prefix_binaryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrefix_binary(this);
}
void LustreParser::Prefix_binaryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrefix_binary(this);
}

std::any LustreParser::Prefix_binaryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitPrefix_binary(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Perfix_makeContext ------------------------------------------------------------------

tree::TerminalNode* LustreParser::Perfix_makeContext::ID() {
  return getToken(LustreParser::ID, 0);
}

LustreParser::Perfix_makeContext::Perfix_makeContext(Prefix_operatorContext *ctx) { copyFrom(ctx); }

void LustreParser::Perfix_makeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPerfix_make(this);
}
void LustreParser::Perfix_makeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPerfix_make(this);
}

std::any LustreParser::Perfix_makeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitPerfix_make(this);
  else
    return visitor->visitChildren(this);
}
LustreParser::Prefix_operatorContext* LustreParser::prefix_operator() {
  Prefix_operatorContext *_localctx = _tracker.createInstance<Prefix_operatorContext>(_ctx, getState());
  enterRule(_localctx, 148, LustreParser::RulePrefix_operator);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1071);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 102, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<LustreParser::Perfix_IDContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(1060);
      match(LustreParser::ID);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<LustreParser::Prefix_unaryContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(1061);
      prefix_unary_operator();
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<LustreParser::Prefix_binaryContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(1062);
      prefix_binary_operator();
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<LustreParser::Perfix_makeContext>(_localctx);
      enterOuterAlt(_localctx, 4);
      setState(1063);
      match(LustreParser::T__14);
      setState(1064);
      match(LustreParser::T__90);
      setState(1065);
      match(LustreParser::ID);
      setState(1066);
      match(LustreParser::T__15);
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<LustreParser::Perfix_flattenContext>(_localctx);
      enterOuterAlt(_localctx, 5);
      setState(1067);
      match(LustreParser::T__14);
      setState(1068);
      match(LustreParser::T__91);
      setState(1069);
      match(LustreParser::ID);
      setState(1070);
      match(LustreParser::T__15);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Prefix_unary_operatorContext ------------------------------------------------------------------

LustreParser::Prefix_unary_operatorContext::Prefix_unary_operatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::Prefix_unary_operatorContext::getRuleIndex() const {
  return LustreParser::RulePrefix_unary_operator;
}

void LustreParser::Prefix_unary_operatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrefix_unary_operator(this);
}

void LustreParser::Prefix_unary_operatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrefix_unary_operator(this);
}


std::any LustreParser::Prefix_unary_operatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitPrefix_unary_operator(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Prefix_unary_operatorContext* LustreParser::prefix_unary_operator() {
  Prefix_unary_operatorContext *_localctx = _tracker.createInstance<Prefix_unary_operatorContext>(_ctx, getState());
  enterRule(_localctx, 150, LustreParser::RulePrefix_unary_operator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1073);
    _la = _input->LA(1);
    if (!(_la == LustreParser::T__7

    || _la == LustreParser::T__40 || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 2251799277339521) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Prefix_binary_operatorContext ------------------------------------------------------------------

LustreParser::Prefix_binary_operatorContext::Prefix_binary_operatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::Prefix_binary_operatorContext::getRuleIndex() const {
  return LustreParser::RulePrefix_binary_operator;
}

void LustreParser::Prefix_binary_operatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrefix_binary_operator(this);
}

void LustreParser::Prefix_binary_operatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrefix_binary_operator(this);
}


std::any LustreParser::Prefix_binary_operatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitPrefix_binary_operator(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Prefix_binary_operatorContext* LustreParser::prefix_binary_operator() {
  Prefix_binary_operatorContext *_localctx = _tracker.createInstance<Prefix_binary_operatorContext>(_ctx, getState());
  enterRule(_localctx, 152, LustreParser::RulePrefix_binary_operator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1075);
    _la = _input->LA(1);
    if (!(((((_la - 115) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 115)) & 32767) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IteratorContext ------------------------------------------------------------------

LustreParser::IteratorContext::IteratorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::IteratorContext::getRuleIndex() const {
  return LustreParser::RuleIterator;
}

void LustreParser::IteratorContext::copyFrom(IteratorContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Iterator_boolredContext ------------------------------------------------------------------

LustreParser::Iterator_boolredContext::Iterator_boolredContext(IteratorContext *ctx) { copyFrom(ctx); }

void LustreParser::Iterator_boolredContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIterator_boolred(this);
}
void LustreParser::Iterator_boolredContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIterator_boolred(this);
}

std::any LustreParser::Iterator_boolredContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitIterator_boolred(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Iterator_redContext ------------------------------------------------------------------

LustreParser::Iterator_redContext::Iterator_redContext(IteratorContext *ctx) { copyFrom(ctx); }

void LustreParser::Iterator_redContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIterator_red(this);
}
void LustreParser::Iterator_redContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIterator_red(this);
}

std::any LustreParser::Iterator_redContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitIterator_red(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Iterator_mapiContext ------------------------------------------------------------------

LustreParser::Iterator_mapiContext::Iterator_mapiContext(IteratorContext *ctx) { copyFrom(ctx); }

void LustreParser::Iterator_mapiContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIterator_mapi(this);
}
void LustreParser::Iterator_mapiContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIterator_mapi(this);
}

std::any LustreParser::Iterator_mapiContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitIterator_mapi(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Iterator_fillredContext ------------------------------------------------------------------

LustreParser::Iterator_fillredContext::Iterator_fillredContext(IteratorContext *ctx) { copyFrom(ctx); }

void LustreParser::Iterator_fillredContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIterator_fillred(this);
}
void LustreParser::Iterator_fillredContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIterator_fillred(this);
}

std::any LustreParser::Iterator_fillredContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitIterator_fillred(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Iterator_foldiContext ------------------------------------------------------------------

LustreParser::Iterator_foldiContext::Iterator_foldiContext(IteratorContext *ctx) { copyFrom(ctx); }

void LustreParser::Iterator_foldiContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIterator_foldi(this);
}
void LustreParser::Iterator_foldiContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIterator_foldi(this);
}

std::any LustreParser::Iterator_foldiContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitIterator_foldi(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Iterator_mapContext ------------------------------------------------------------------

LustreParser::Iterator_mapContext::Iterator_mapContext(IteratorContext *ctx) { copyFrom(ctx); }

void LustreParser::Iterator_mapContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIterator_map(this);
}
void LustreParser::Iterator_mapContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIterator_map(this);
}

std::any LustreParser::Iterator_mapContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitIterator_map(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Iterator_foldContext ------------------------------------------------------------------

LustreParser::Iterator_foldContext::Iterator_foldContext(IteratorContext *ctx) { copyFrom(ctx); }

void LustreParser::Iterator_foldContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIterator_fold(this);
}
void LustreParser::Iterator_foldContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIterator_fold(this);
}

std::any LustreParser::Iterator_foldContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitIterator_fold(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Iterator_fillContext ------------------------------------------------------------------

LustreParser::Iterator_fillContext::Iterator_fillContext(IteratorContext *ctx) { copyFrom(ctx); }

void LustreParser::Iterator_fillContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIterator_fill(this);
}
void LustreParser::Iterator_fillContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIterator_fill(this);
}

std::any LustreParser::Iterator_fillContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitIterator_fill(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Iterator_mapfoldContext ------------------------------------------------------------------

LustreParser::Iterator_mapfoldContext::Iterator_mapfoldContext(IteratorContext *ctx) { copyFrom(ctx); }

void LustreParser::Iterator_mapfoldContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIterator_mapfold(this);
}
void LustreParser::Iterator_mapfoldContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIterator_mapfold(this);
}

std::any LustreParser::Iterator_mapfoldContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitIterator_mapfold(this);
  else
    return visitor->visitChildren(this);
}
LustreParser::IteratorContext* LustreParser::iterator() {
  IteratorContext *_localctx = _tracker.createInstance<IteratorContext>(_ctx, getState());
  enterRule(_localctx, 154, LustreParser::RuleIterator);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1086);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LustreParser::T__129: {
        _localctx = _tracker.createInstance<LustreParser::Iterator_mapContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(1077);
        match(LustreParser::T__129);
        break;
      }

      case LustreParser::T__130: {
        _localctx = _tracker.createInstance<LustreParser::Iterator_foldContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(1078);
        match(LustreParser::T__130);
        break;
      }

      case LustreParser::T__131: {
        _localctx = _tracker.createInstance<LustreParser::Iterator_mapiContext>(_localctx);
        enterOuterAlt(_localctx, 3);
        setState(1079);
        match(LustreParser::T__131);
        break;
      }

      case LustreParser::T__132: {
        _localctx = _tracker.createInstance<LustreParser::Iterator_foldiContext>(_localctx);
        enterOuterAlt(_localctx, 4);
        setState(1080);
        match(LustreParser::T__132);
        break;
      }

      case LustreParser::T__133: {
        _localctx = _tracker.createInstance<LustreParser::Iterator_mapfoldContext>(_localctx);
        enterOuterAlt(_localctx, 5);
        setState(1081);
        match(LustreParser::T__133);
        break;
      }

      case LustreParser::T__134: {
        _localctx = _tracker.createInstance<LustreParser::Iterator_redContext>(_localctx);
        enterOuterAlt(_localctx, 6);
        setState(1082);
        match(LustreParser::T__134);
        break;
      }

      case LustreParser::T__135: {
        _localctx = _tracker.createInstance<LustreParser::Iterator_fillContext>(_localctx);
        enterOuterAlt(_localctx, 7);
        setState(1083);
        match(LustreParser::T__135);
        break;
      }

      case LustreParser::T__136: {
        _localctx = _tracker.createInstance<LustreParser::Iterator_fillredContext>(_localctx);
        enterOuterAlt(_localctx, 8);
        setState(1084);
        match(LustreParser::T__136);
        break;
      }

      case LustreParser::T__137: {
        _localctx = _tracker.createInstance<LustreParser::Iterator_boolredContext>(_localctx);
        enterOuterAlt(_localctx, 9);
        setState(1085);
        match(LustreParser::T__137);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Iterator_lv6Context ------------------------------------------------------------------

LustreParser::Iterator_lv6Context::Iterator_lv6Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::Iterator_lv6Context::getRuleIndex() const {
  return LustreParser::RuleIterator_lv6;
}

void LustreParser::Iterator_lv6Context::copyFrom(Iterator_lv6Context *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Iterator_lv6_fillredContext ------------------------------------------------------------------

LustreParser::Iterator_lv6_fillredContext::Iterator_lv6_fillredContext(Iterator_lv6Context *ctx) { copyFrom(ctx); }

void LustreParser::Iterator_lv6_fillredContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIterator_lv6_fillred(this);
}
void LustreParser::Iterator_lv6_fillredContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIterator_lv6_fillred(this);
}

std::any LustreParser::Iterator_lv6_fillredContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitIterator_lv6_fillred(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Iterator_lv6_redContext ------------------------------------------------------------------

LustreParser::Iterator_lv6_redContext::Iterator_lv6_redContext(Iterator_lv6Context *ctx) { copyFrom(ctx); }

void LustreParser::Iterator_lv6_redContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIterator_lv6_red(this);
}
void LustreParser::Iterator_lv6_redContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIterator_lv6_red(this);
}

std::any LustreParser::Iterator_lv6_redContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitIterator_lv6_red(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Iterator_lv6_fillContext ------------------------------------------------------------------

LustreParser::Iterator_lv6_fillContext::Iterator_lv6_fillContext(Iterator_lv6Context *ctx) { copyFrom(ctx); }

void LustreParser::Iterator_lv6_fillContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIterator_lv6_fill(this);
}
void LustreParser::Iterator_lv6_fillContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIterator_lv6_fill(this);
}

std::any LustreParser::Iterator_lv6_fillContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitIterator_lv6_fill(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Iterator_lv6_boolredContext ------------------------------------------------------------------

LustreParser::Iterator_lv6_boolredContext::Iterator_lv6_boolredContext(Iterator_lv6Context *ctx) { copyFrom(ctx); }

void LustreParser::Iterator_lv6_boolredContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIterator_lv6_boolred(this);
}
void LustreParser::Iterator_lv6_boolredContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIterator_lv6_boolred(this);
}

std::any LustreParser::Iterator_lv6_boolredContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitIterator_lv6_boolred(this);
  else
    return visitor->visitChildren(this);
}
LustreParser::Iterator_lv6Context* LustreParser::iterator_lv6() {
  Iterator_lv6Context *_localctx = _tracker.createInstance<Iterator_lv6Context>(_ctx, getState());
  enterRule(_localctx, 156, LustreParser::RuleIterator_lv6);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1092);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LustreParser::T__134: {
        _localctx = _tracker.createInstance<LustreParser::Iterator_lv6_redContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(1088);
        match(LustreParser::T__134);
        break;
      }

      case LustreParser::T__135: {
        _localctx = _tracker.createInstance<LustreParser::Iterator_lv6_fillContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(1089);
        match(LustreParser::T__135);
        break;
      }

      case LustreParser::T__136: {
        _localctx = _tracker.createInstance<LustreParser::Iterator_lv6_fillredContext>(_localctx);
        enterOuterAlt(_localctx, 3);
        setState(1090);
        match(LustreParser::T__136);
        break;
      }

      case LustreParser::T__137: {
        _localctx = _tracker.createInstance<LustreParser::Iterator_lv6_boolredContext>(_localctx);
        enterOuterAlt(_localctx, 4);
        setState(1091);
        match(LustreParser::T__137);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Simple_exprContext ------------------------------------------------------------------

LustreParser::Simple_exprContext::Simple_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::Simple_exprContext::getRuleIndex() const {
  return LustreParser::RuleSimple_expr;
}

void LustreParser::Simple_exprContext::copyFrom(Simple_exprContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Simple_expr_unary_arithContext ------------------------------------------------------------------

LustreParser::Unary_arith_opContext* LustreParser::Simple_expr_unary_arithContext::unary_arith_op() {
  return getRuleContext<LustreParser::Unary_arith_opContext>(0);
}

LustreParser::Simple_exprContext* LustreParser::Simple_expr_unary_arithContext::simple_expr() {
  return getRuleContext<LustreParser::Simple_exprContext>(0);
}

LustreParser::Simple_expr_unary_arithContext::Simple_expr_unary_arithContext(Simple_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Simple_expr_unary_arithContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimple_expr_unary_arith(this);
}
void LustreParser::Simple_expr_unary_arithContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimple_expr_unary_arith(this);
}

std::any LustreParser::Simple_expr_unary_arithContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitSimple_expr_unary_arith(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Simple_expr_parenContext ------------------------------------------------------------------

std::vector<LustreParser::Simple_exprContext *> LustreParser::Simple_expr_parenContext::simple_expr() {
  return getRuleContexts<LustreParser::Simple_exprContext>();
}

LustreParser::Simple_exprContext* LustreParser::Simple_expr_parenContext::simple_expr(size_t i) {
  return getRuleContext<LustreParser::Simple_exprContext>(i);
}

LustreParser::Simple_expr_parenContext::Simple_expr_parenContext(Simple_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Simple_expr_parenContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimple_expr_paren(this);
}
void LustreParser::Simple_expr_parenContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimple_expr_paren(this);
}

std::any LustreParser::Simple_expr_parenContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitSimple_expr_paren(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Simple_expr_typeContext ------------------------------------------------------------------

LustreParser::TypeContext* LustreParser::Simple_expr_typeContext::type() {
  return getRuleContext<LustreParser::TypeContext>(0);
}

LustreParser::Simple_exprContext* LustreParser::Simple_expr_typeContext::simple_expr() {
  return getRuleContext<LustreParser::Simple_exprContext>(0);
}

LustreParser::Simple_expr_typeContext::Simple_expr_typeContext(Simple_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Simple_expr_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimple_expr_type(this);
}
void LustreParser::Simple_expr_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimple_expr_type(this);
}

std::any LustreParser::Simple_expr_typeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitSimple_expr_type(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Simple_expr_structContext ------------------------------------------------------------------

LustreParser::Simple_exprContext* LustreParser::Simple_expr_structContext::simple_expr() {
  return getRuleContext<LustreParser::Simple_exprContext>(0);
}

tree::TerminalNode* LustreParser::Simple_expr_structContext::ID() {
  return getToken(LustreParser::ID, 0);
}

LustreParser::Simple_expr_structContext::Simple_expr_structContext(Simple_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Simple_expr_structContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimple_expr_struct(this);
}
void LustreParser::Simple_expr_structContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimple_expr_struct(this);
}

std::any LustreParser::Simple_expr_structContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitSimple_expr_struct(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Simple_expr_bin_relationContext ------------------------------------------------------------------

std::vector<LustreParser::Simple_exprContext *> LustreParser::Simple_expr_bin_relationContext::simple_expr() {
  return getRuleContexts<LustreParser::Simple_exprContext>();
}

LustreParser::Simple_exprContext* LustreParser::Simple_expr_bin_relationContext::simple_expr(size_t i) {
  return getRuleContext<LustreParser::Simple_exprContext>(i);
}

LustreParser::Bin_relation_opContext* LustreParser::Simple_expr_bin_relationContext::bin_relation_op() {
  return getRuleContext<LustreParser::Bin_relation_opContext>(0);
}

LustreParser::Simple_expr_bin_relationContext::Simple_expr_bin_relationContext(Simple_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Simple_expr_bin_relationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimple_expr_bin_relation(this);
}
void LustreParser::Simple_expr_bin_relationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimple_expr_bin_relation(this);
}

std::any LustreParser::Simple_expr_bin_relationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitSimple_expr_bin_relation(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Simple_expr_atomContext ------------------------------------------------------------------

LustreParser::AtomContext* LustreParser::Simple_expr_atomContext::atom() {
  return getRuleContext<LustreParser::AtomContext>(0);
}

LustreParser::Simple_expr_atomContext::Simple_expr_atomContext(Simple_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Simple_expr_atomContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimple_expr_atom(this);
}
void LustreParser::Simple_expr_atomContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimple_expr_atom(this);
}

std::any LustreParser::Simple_expr_atomContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitSimple_expr_atom(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Simple_expr_bin_boolContext ------------------------------------------------------------------

std::vector<LustreParser::Simple_exprContext *> LustreParser::Simple_expr_bin_boolContext::simple_expr() {
  return getRuleContexts<LustreParser::Simple_exprContext>();
}

LustreParser::Simple_exprContext* LustreParser::Simple_expr_bin_boolContext::simple_expr(size_t i) {
  return getRuleContext<LustreParser::Simple_exprContext>(i);
}

LustreParser::Bin_bool_opContext* LustreParser::Simple_expr_bin_boolContext::bin_bool_op() {
  return getRuleContext<LustreParser::Bin_bool_opContext>(0);
}

LustreParser::Simple_expr_bin_boolContext::Simple_expr_bin_boolContext(Simple_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Simple_expr_bin_boolContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimple_expr_bin_bool(this);
}
void LustreParser::Simple_expr_bin_boolContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimple_expr_bin_bool(this);
}

std::any LustreParser::Simple_expr_bin_boolContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitSimple_expr_bin_bool(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Simple_expr_idContext ------------------------------------------------------------------

tree::TerminalNode* LustreParser::Simple_expr_idContext::ID() {
  return getToken(LustreParser::ID, 0);
}

LustreParser::Simple_expr_idContext::Simple_expr_idContext(Simple_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Simple_expr_idContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimple_expr_id(this);
}
void LustreParser::Simple_expr_idContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimple_expr_id(this);
}

std::any LustreParser::Simple_expr_idContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitSimple_expr_id(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Simple_expr_bin_arithContext ------------------------------------------------------------------

std::vector<LustreParser::Simple_exprContext *> LustreParser::Simple_expr_bin_arithContext::simple_expr() {
  return getRuleContexts<LustreParser::Simple_exprContext>();
}

LustreParser::Simple_exprContext* LustreParser::Simple_expr_bin_arithContext::simple_expr(size_t i) {
  return getRuleContext<LustreParser::Simple_exprContext>(i);
}

LustreParser::Bin_arith_opContext* LustreParser::Simple_expr_bin_arithContext::bin_arith_op() {
  return getRuleContext<LustreParser::Bin_arith_opContext>(0);
}

LustreParser::Simple_expr_bin_arithContext::Simple_expr_bin_arithContext(Simple_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Simple_expr_bin_arithContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimple_expr_bin_arith(this);
}
void LustreParser::Simple_expr_bin_arithContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimple_expr_bin_arith(this);
}

std::any LustreParser::Simple_expr_bin_arithContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitSimple_expr_bin_arith(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Simple_expr_arrayContext ------------------------------------------------------------------

LustreParser::Simple_exprContext* LustreParser::Simple_expr_arrayContext::simple_expr() {
  return getRuleContext<LustreParser::Simple_exprContext>(0);
}

LustreParser::Const_exprContext* LustreParser::Simple_expr_arrayContext::const_expr() {
  return getRuleContext<LustreParser::Const_exprContext>(0);
}

LustreParser::Simple_expr_arrayContext::Simple_expr_arrayContext(Simple_exprContext *ctx) { copyFrom(ctx); }

void LustreParser::Simple_expr_arrayContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimple_expr_array(this);
}
void LustreParser::Simple_expr_arrayContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimple_expr_array(this);
}

std::any LustreParser::Simple_expr_arrayContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitSimple_expr_array(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Simple_exprContext* LustreParser::simple_expr() {
   return simple_expr(0);
}

LustreParser::Simple_exprContext* LustreParser::simple_expr(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  LustreParser::Simple_exprContext *_localctx = _tracker.createInstance<Simple_exprContext>(_ctx, parentState);
  LustreParser::Simple_exprContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 158;
  enterRecursionRule(_localctx, 158, LustreParser::RuleSimple_expr, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1114);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 106, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<Simple_expr_idContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;

      setState(1095);
      match(LustreParser::ID);
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<Simple_expr_atomContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1096);
      atom();
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<Simple_expr_parenContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1097);
      match(LustreParser::T__14);
      setState(1098);
      simple_expr(0);
      setState(1103);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == LustreParser::T__6) {
        setState(1099);
        match(LustreParser::T__6);
        setState(1100);
        simple_expr(0);
        setState(1105);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1106);
      match(LustreParser::T__15);
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<Simple_expr_unary_arithContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1108);
      unary_arith_op();
      setState(1109);
      simple_expr(5);
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<Simple_expr_typeContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(1111);
      type(0);
      setState(1112);
      simple_expr(1);
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(1138);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 108, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(1136);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 107, _ctx)) {
        case 1: {
          auto newContext = _tracker.createInstance<Simple_expr_bin_arithContext>(_tracker.createInstance<Simple_exprContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSimple_expr);
          setState(1116);

          if (!(precpred(_ctx, 4))) throw FailedPredicateException(this, "precpred(_ctx, 4)");
          setState(1117);
          bin_arith_op();
          setState(1118);
          simple_expr(5);
          break;
        }

        case 2: {
          auto newContext = _tracker.createInstance<Simple_expr_bin_boolContext>(_tracker.createInstance<Simple_exprContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSimple_expr);
          setState(1120);

          if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
          setState(1121);
          bin_bool_op();
          setState(1122);
          simple_expr(4);
          break;
        }

        case 3: {
          auto newContext = _tracker.createInstance<Simple_expr_bin_relationContext>(_tracker.createInstance<Simple_exprContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSimple_expr);
          setState(1124);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(1125);
          bin_relation_op();
          setState(1126);
          simple_expr(3);
          break;
        }

        case 4: {
          auto newContext = _tracker.createInstance<Simple_expr_arrayContext>(_tracker.createInstance<Simple_exprContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSimple_expr);
          setState(1128);

          if (!(precpred(_ctx, 7))) throw FailedPredicateException(this, "precpred(_ctx, 7)");
          setState(1129);
          match(LustreParser::T__37);
          setState(1130);
          const_expr(0);
          setState(1131);
          match(LustreParser::T__38);
          break;
        }

        case 5: {
          auto newContext = _tracker.createInstance<Simple_expr_structContext>(_tracker.createInstance<Simple_exprContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSimple_expr);
          setState(1133);

          if (!(precpred(_ctx, 6))) throw FailedPredicateException(this, "precpred(_ctx, 6)");
          setState(1134);
          match(LustreParser::T__74);
          setState(1135);
          match(LustreParser::ID);
          break;
        }

        default:
          break;
        } 
      }
      setState(1140);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 108, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Unary_arith_opContext ------------------------------------------------------------------

LustreParser::Unary_arith_opContext::Unary_arith_opContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::Unary_arith_opContext::getRuleIndex() const {
  return LustreParser::RuleUnary_arith_op;
}

void LustreParser::Unary_arith_opContext::copyFrom(Unary_arith_opContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Unary_arith_op_notContext ------------------------------------------------------------------

LustreParser::Unary_arith_op_notContext::Unary_arith_op_notContext(Unary_arith_opContext *ctx) { copyFrom(ctx); }

void LustreParser::Unary_arith_op_notContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnary_arith_op_not(this);
}
void LustreParser::Unary_arith_op_notContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnary_arith_op_not(this);
}

std::any LustreParser::Unary_arith_op_notContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitUnary_arith_op_not(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Unary_arith_op_subContext ------------------------------------------------------------------

LustreParser::Unary_arith_op_subContext::Unary_arith_op_subContext(Unary_arith_opContext *ctx) { copyFrom(ctx); }

void LustreParser::Unary_arith_op_subContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnary_arith_op_sub(this);
}
void LustreParser::Unary_arith_op_subContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnary_arith_op_sub(this);
}

std::any LustreParser::Unary_arith_op_subContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitUnary_arith_op_sub(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Unary_arith_op_addContext ------------------------------------------------------------------

LustreParser::Unary_arith_op_addContext::Unary_arith_op_addContext(Unary_arith_opContext *ctx) { copyFrom(ctx); }

void LustreParser::Unary_arith_op_addContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnary_arith_op_add(this);
}
void LustreParser::Unary_arith_op_addContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnary_arith_op_add(this);
}

std::any LustreParser::Unary_arith_op_addContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitUnary_arith_op_add(this);
  else
    return visitor->visitChildren(this);
}
LustreParser::Unary_arith_opContext* LustreParser::unary_arith_op() {
  Unary_arith_opContext *_localctx = _tracker.createInstance<Unary_arith_opContext>(_ctx, getState());
  enterRule(_localctx, 160, LustreParser::RuleUnary_arith_op);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1144);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LustreParser::T__82: {
        _localctx = _tracker.createInstance<LustreParser::Unary_arith_op_subContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(1141);
        match(LustreParser::T__82);
        break;
      }

      case LustreParser::T__111: {
        _localctx = _tracker.createInstance<LustreParser::Unary_arith_op_addContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(1142);
        match(LustreParser::T__111);
        break;
      }

      case LustreParser::T__40: {
        _localctx = _tracker.createInstance<LustreParser::Unary_arith_op_notContext>(_localctx);
        enterOuterAlt(_localctx, 3);
        setState(1143);
        match(LustreParser::T__40);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bin_arith_opContext ------------------------------------------------------------------

LustreParser::Bin_arith_opContext::Bin_arith_opContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::Bin_arith_opContext::getRuleIndex() const {
  return LustreParser::RuleBin_arith_op;
}

void LustreParser::Bin_arith_opContext::copyFrom(Bin_arith_opContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Bin_arith_op_mulContext ------------------------------------------------------------------

LustreParser::Bin_arith_op_mulContext::Bin_arith_op_mulContext(Bin_arith_opContext *ctx) { copyFrom(ctx); }

void LustreParser::Bin_arith_op_mulContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBin_arith_op_mul(this);
}
void LustreParser::Bin_arith_op_mulContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBin_arith_op_mul(this);
}

std::any LustreParser::Bin_arith_op_mulContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitBin_arith_op_mul(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Bin_arith_op_dividedContext ------------------------------------------------------------------

LustreParser::Bin_arith_op_dividedContext::Bin_arith_op_dividedContext(Bin_arith_opContext *ctx) { copyFrom(ctx); }

void LustreParser::Bin_arith_op_dividedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBin_arith_op_divided(this);
}
void LustreParser::Bin_arith_op_dividedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBin_arith_op_divided(this);
}

std::any LustreParser::Bin_arith_op_dividedContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitBin_arith_op_divided(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Bin_arith_op_subContext ------------------------------------------------------------------

LustreParser::Bin_arith_op_subContext::Bin_arith_op_subContext(Bin_arith_opContext *ctx) { copyFrom(ctx); }

void LustreParser::Bin_arith_op_subContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBin_arith_op_sub(this);
}
void LustreParser::Bin_arith_op_subContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBin_arith_op_sub(this);
}

std::any LustreParser::Bin_arith_op_subContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitBin_arith_op_sub(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Bin_arith_op_modContext ------------------------------------------------------------------

LustreParser::Bin_arith_op_modContext::Bin_arith_op_modContext(Bin_arith_opContext *ctx) { copyFrom(ctx); }

void LustreParser::Bin_arith_op_modContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBin_arith_op_mod(this);
}
void LustreParser::Bin_arith_op_modContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBin_arith_op_mod(this);
}

std::any LustreParser::Bin_arith_op_modContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitBin_arith_op_mod(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Bin_arith_op_addContext ------------------------------------------------------------------

LustreParser::Bin_arith_op_addContext::Bin_arith_op_addContext(Bin_arith_opContext *ctx) { copyFrom(ctx); }

void LustreParser::Bin_arith_op_addContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBin_arith_op_add(this);
}
void LustreParser::Bin_arith_op_addContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBin_arith_op_add(this);
}

std::any LustreParser::Bin_arith_op_addContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitBin_arith_op_add(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Bin_arith_op_divContext ------------------------------------------------------------------

LustreParser::Bin_arith_op_divContext::Bin_arith_op_divContext(Bin_arith_opContext *ctx) { copyFrom(ctx); }

void LustreParser::Bin_arith_op_divContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBin_arith_op_div(this);
}
void LustreParser::Bin_arith_op_divContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBin_arith_op_div(this);
}

std::any LustreParser::Bin_arith_op_divContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitBin_arith_op_div(this);
  else
    return visitor->visitChildren(this);
}
LustreParser::Bin_arith_opContext* LustreParser::bin_arith_op() {
  Bin_arith_opContext *_localctx = _tracker.createInstance<Bin_arith_opContext>(_ctx, getState());
  enterRule(_localctx, 162, LustreParser::RuleBin_arith_op);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1152);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LustreParser::T__111: {
        _localctx = _tracker.createInstance<LustreParser::Bin_arith_op_addContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(1146);
        match(LustreParser::T__111);
        break;
      }

      case LustreParser::T__82: {
        _localctx = _tracker.createInstance<LustreParser::Bin_arith_op_subContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(1147);
        match(LustreParser::T__82);
        break;
      }

      case LustreParser::T__112: {
        _localctx = _tracker.createInstance<LustreParser::Bin_arith_op_mulContext>(_localctx);
        enterOuterAlt(_localctx, 3);
        setState(1148);
        match(LustreParser::T__112);
        break;
      }

      case LustreParser::T__113: {
        _localctx = _tracker.createInstance<LustreParser::Bin_arith_op_dividedContext>(_localctx);
        enterOuterAlt(_localctx, 4);
        setState(1149);
        match(LustreParser::T__113);
        break;
      }

      case LustreParser::T__110: {
        _localctx = _tracker.createInstance<LustreParser::Bin_arith_op_modContext>(_localctx);
        enterOuterAlt(_localctx, 5);
        setState(1150);
        match(LustreParser::T__110);
        break;
      }

      case LustreParser::T__109: {
        _localctx = _tracker.createInstance<LustreParser::Bin_arith_op_divContext>(_localctx);
        enterOuterAlt(_localctx, 6);
        setState(1151);
        match(LustreParser::T__109);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bin_relation_opContext ------------------------------------------------------------------

LustreParser::Bin_relation_opContext::Bin_relation_opContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::Bin_relation_opContext::getRuleIndex() const {
  return LustreParser::RuleBin_relation_op;
}

void LustreParser::Bin_relation_opContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBin_relation_op(this);
}

void LustreParser::Bin_relation_opContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBin_relation_op(this);
}


std::any LustreParser::Bin_relation_opContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitBin_relation_op(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Bin_relation_opContext* LustreParser::bin_relation_op() {
  Bin_relation_opContext *_localctx = _tracker.createInstance<Bin_relation_opContext>(_ctx, getState());
  enterRule(_localctx, 164, LustreParser::RuleBin_relation_op);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1154);
    _la = _input->LA(1);
    if (!(_la == LustreParser::T__7 || ((((_la - 105) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 105)) & 31) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bin_bool_opContext ------------------------------------------------------------------

LustreParser::Bin_bool_opContext::Bin_bool_opContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::Bin_bool_opContext::getRuleIndex() const {
  return LustreParser::RuleBin_bool_op;
}

void LustreParser::Bin_bool_opContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBin_bool_op(this);
}

void LustreParser::Bin_bool_opContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBin_bool_op(this);
}


std::any LustreParser::Bin_bool_opContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitBin_bool_op(this);
  else
    return visitor->visitChildren(this);
}

LustreParser::Bin_bool_opContext* LustreParser::bin_bool_op() {
  Bin_bool_opContext *_localctx = _tracker.createInstance<Bin_bool_opContext>(_ctx, getState());
  enterRule(_localctx, 166, LustreParser::RuleBin_bool_op);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1156);
    _la = _input->LA(1);
    if (!(((((_la - 101) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 101)) & 7) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AtomContext ------------------------------------------------------------------

LustreParser::AtomContext::AtomContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LustreParser::AtomContext::getRuleIndex() const {
  return LustreParser::RuleAtom;
}

void LustreParser::AtomContext::copyFrom(AtomContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- Atom_CHARContext ------------------------------------------------------------------

tree::TerminalNode* LustreParser::Atom_CHARContext::CHAR() {
  return getToken(LustreParser::CHAR, 0);
}

LustreParser::Atom_CHARContext::Atom_CHARContext(AtomContext *ctx) { copyFrom(ctx); }

void LustreParser::Atom_CHARContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAtom_CHAR(this);
}
void LustreParser::Atom_CHARContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAtom_CHAR(this);
}

std::any LustreParser::Atom_CHARContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitAtom_CHAR(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Atom_SHORTContext ------------------------------------------------------------------

tree::TerminalNode* LustreParser::Atom_SHORTContext::SHORT() {
  return getToken(LustreParser::SHORT, 0);
}

LustreParser::Atom_SHORTContext::Atom_SHORTContext(AtomContext *ctx) { copyFrom(ctx); }

void LustreParser::Atom_SHORTContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAtom_SHORT(this);
}
void LustreParser::Atom_SHORTContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAtom_SHORT(this);
}

std::any LustreParser::Atom_SHORTContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitAtom_SHORT(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Atom_UINTContext ------------------------------------------------------------------

tree::TerminalNode* LustreParser::Atom_UINTContext::UINT() {
  return getToken(LustreParser::UINT, 0);
}

LustreParser::Atom_UINTContext::Atom_UINTContext(AtomContext *ctx) { copyFrom(ctx); }

void LustreParser::Atom_UINTContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAtom_UINT(this);
}
void LustreParser::Atom_UINTContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAtom_UINT(this);
}

std::any LustreParser::Atom_UINTContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitAtom_UINT(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Atom_FLOATContext ------------------------------------------------------------------

tree::TerminalNode* LustreParser::Atom_FLOATContext::FLOAT() {
  return getToken(LustreParser::FLOAT, 0);
}

LustreParser::Atom_FLOATContext::Atom_FLOATContext(AtomContext *ctx) { copyFrom(ctx); }

void LustreParser::Atom_FLOATContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAtom_FLOAT(this);
}
void LustreParser::Atom_FLOATContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAtom_FLOAT(this);
}

std::any LustreParser::Atom_FLOATContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitAtom_FLOAT(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Atom_REALContext ------------------------------------------------------------------

tree::TerminalNode* LustreParser::Atom_REALContext::REAL() {
  return getToken(LustreParser::REAL, 0);
}

LustreParser::Atom_REALContext::Atom_REALContext(AtomContext *ctx) { copyFrom(ctx); }

void LustreParser::Atom_REALContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAtom_REAL(this);
}
void LustreParser::Atom_REALContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAtom_REAL(this);
}

std::any LustreParser::Atom_REALContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitAtom_REAL(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Atom_BOOLContext ------------------------------------------------------------------

tree::TerminalNode* LustreParser::Atom_BOOLContext::BOOL() {
  return getToken(LustreParser::BOOL, 0);
}

LustreParser::Atom_BOOLContext::Atom_BOOLContext(AtomContext *ctx) { copyFrom(ctx); }

void LustreParser::Atom_BOOLContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAtom_BOOL(this);
}
void LustreParser::Atom_BOOLContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAtom_BOOL(this);
}

std::any LustreParser::Atom_BOOLContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitAtom_BOOL(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Atom_INTEGERContext ------------------------------------------------------------------

tree::TerminalNode* LustreParser::Atom_INTEGERContext::INTEGER() {
  return getToken(LustreParser::INTEGER, 0);
}

LustreParser::Atom_INTEGERContext::Atom_INTEGERContext(AtomContext *ctx) { copyFrom(ctx); }

void LustreParser::Atom_INTEGERContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAtom_INTEGER(this);
}
void LustreParser::Atom_INTEGERContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAtom_INTEGER(this);
}

std::any LustreParser::Atom_INTEGERContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitAtom_INTEGER(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Atom_USHORTContext ------------------------------------------------------------------

tree::TerminalNode* LustreParser::Atom_USHORTContext::USHORT() {
  return getToken(LustreParser::USHORT, 0);
}

LustreParser::Atom_USHORTContext::Atom_USHORTContext(AtomContext *ctx) { copyFrom(ctx); }

void LustreParser::Atom_USHORTContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAtom_USHORT(this);
}
void LustreParser::Atom_USHORTContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<LustreListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAtom_USHORT(this);
}

std::any LustreParser::Atom_USHORTContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LustreVisitor*>(visitor))
    return parserVisitor->visitAtom_USHORT(this);
  else
    return visitor->visitChildren(this);
}
LustreParser::AtomContext* LustreParser::atom() {
  AtomContext *_localctx = _tracker.createInstance<AtomContext>(_ctx, getState());
  enterRule(_localctx, 168, LustreParser::RuleAtom);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1166);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LustreParser::BOOL: {
        _localctx = _tracker.createInstance<LustreParser::Atom_BOOLContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(1158);
        match(LustreParser::BOOL);
        break;
      }

      case LustreParser::CHAR: {
        _localctx = _tracker.createInstance<LustreParser::Atom_CHARContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(1159);
        match(LustreParser::CHAR);
        break;
      }

      case LustreParser::INTEGER: {
        _localctx = _tracker.createInstance<LustreParser::Atom_INTEGERContext>(_localctx);
        enterOuterAlt(_localctx, 3);
        setState(1160);
        match(LustreParser::INTEGER);
        break;
      }

      case LustreParser::UINT: {
        _localctx = _tracker.createInstance<LustreParser::Atom_UINTContext>(_localctx);
        enterOuterAlt(_localctx, 4);
        setState(1161);
        match(LustreParser::UINT);
        break;
      }

      case LustreParser::FLOAT: {
        _localctx = _tracker.createInstance<LustreParser::Atom_FLOATContext>(_localctx);
        enterOuterAlt(_localctx, 5);
        setState(1162);
        match(LustreParser::FLOAT);
        break;
      }

      case LustreParser::REAL: {
        _localctx = _tracker.createInstance<LustreParser::Atom_REALContext>(_localctx);
        enterOuterAlt(_localctx, 6);
        setState(1163);
        match(LustreParser::REAL);
        break;
      }

      case LustreParser::USHORT: {
        _localctx = _tracker.createInstance<LustreParser::Atom_USHORTContext>(_localctx);
        enterOuterAlt(_localctx, 7);
        setState(1164);
        match(LustreParser::USHORT);
        break;
      }

      case LustreParser::SHORT: {
        _localctx = _tracker.createInstance<LustreParser::Atom_SHORTContext>(_localctx);
        enterOuterAlt(_localctx, 8);
        setState(1165);
        match(LustreParser::SHORT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

bool LustreParser::sempred(RuleContext *context, size_t ruleIndex, size_t predicateIndex) {
  switch (ruleIndex) {
    case 22: return typeSempred(antlrcpp::downCast<TypeContext *>(context), predicateIndex);
    case 26: return const_exprSempred(antlrcpp::downCast<Const_exprContext *>(context), predicateIndex);
    case 79: return simple_exprSempred(antlrcpp::downCast<Simple_exprContext *>(context), predicateIndex);

  default:
    break;
  }
  return true;
}

bool LustreParser::typeSempred(TypeContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 0: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

bool LustreParser::const_exprSempred(Const_exprContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 1: return precpred(_ctx, 5);
    case 2: return precpred(_ctx, 4);
    case 3: return precpred(_ctx, 3);

  default:
    break;
  }
  return true;
}

bool LustreParser::simple_exprSempred(Simple_exprContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 4: return precpred(_ctx, 4);
    case 5: return precpred(_ctx, 3);
    case 6: return precpred(_ctx, 2);
    case 7: return precpred(_ctx, 7);
    case 8: return precpred(_ctx, 6);

  default:
    break;
  }
  return true;
}

void LustreParser::initialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  lustreParserInitialize();
#else
  ::antlr4::internal::call_once(lustreParserOnceFlag, lustreParserInitialize);
#endif
}
